fn _tp_Lexer_set_keywords(self:Lexer, keywords:vector<text>) {#block(1):void
  OpGetField(self(0), 28i32, 23i32);
  {#For block(2):void
    _vector_1(2):vector<text>["keywords"] = keywords(0);
    k#index(2):integer = -1i32;
    loop {#For loop_3
      k(3):text["_vector_1"] = {#iter next(4):text
        k#index(2):integer = OpAddInt(k#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, k#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(k(3))) {#break(5):void
        OpFreeText(k(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        _elm_2(6):ref(Keyword)["self"] = OpNewRecord(self(0), 22i32, 9i32);
        OpSetText(_elm_2(6), 4i32, k(3));
        OpFinishRecord(self(0), _elm_2(6), 22i32, 9i32);
      }#block(6):void;
      OpFreeText(k(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_keywords(self: ref(Lexer)[0], keywords: vector<text>[12]) [1074]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<Keyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
   6[40]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=keywords[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=k#index[56]:integer
  14[56]: Text() var=k[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=k#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["keywords"]
  30[92]: VarInt(var[56]) -> integer var=k#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=102)
  60[80]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  63[92]: NewRecord(data: ref(reference), parent_tp=22, fld=9) -> ref(reference)
  68[92]: VarRef(var[84]) -> ref(reference) type=Keyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(Keyword)["self"]
  71[104]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  74[120]: SetText(v1: ref(reference), fld=4, val: text)
  77[92]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[104]: VarRef(var[84]) -> ref(reference) type=Keyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(Keyword)["self"]
  83[116]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=9)
  88[92]: FreeStack(value=0, discard=12)
  92[80]: FreeText(var[60])
  95[80]: FreeStack(value=0, discard=24)
  99[56]: GotoWord(jump=14)
 102[56]: FreeStack(value=0, discard=16)
 106[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_set_tokens(self:Lexer, tokens:vector<text>) {#block(1):void
  OpGetField(self(0), 32i32, 24i32);
  {#For block(2):void
    _vector_1(2):vector<text>["tokens"] = tokens(0);
    t#index(2):integer = -1i32;
    loop {#For loop_3
      t(3):text["_vector_1"] = {#iter next(4):text
        t#index(2):integer = OpAddInt(t#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, t#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(t(3))) {#break(5):void
        OpFreeText(t(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        f(6):character = OpTextCharacter(t(3), 0i32);
        if OpNot(OpConvBoolFromCharacter(f(6))) {#block(7):void
          OpFreeText(t(3));
          continue(0);
        }#block(7):void else null;
        if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, OpConvIntFromCharacter(f(6)))) {#block(8):void
          _elm_2(8):ref(Possible)["self"] = OpNewRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, OpConvIntFromCharacter(f(6))), 20i32, 1i32);
          OpSetInt(_elm_2(8), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_2(8), 4i32, t(3));
          OpFinishRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, OpConvIntFromCharacter(f(6))), _elm_2(8), 20i32, 1i32);
        }#block(8):void else {#block(9):void
          _elm_3(9):ref(Token)["self"] = OpNewRecord(self(0), 22i32, 10i32);
          OpSetInt(_elm_3(9), 4i32, OpConvIntFromCharacter(f(6)));
          OpSetInt(_elm_3(9), 8i32, 0i32);
          _elm_4(9):ref(Possible)["_elm_3"] = OpNewRecord(_elm_3(9), 20i32, 1i32);
          OpSetInt(_elm_4(9), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_4(9), 4i32, t(3));
          OpFinishRecord(_elm_3(9), _elm_4(9), 20i32, 1i32);
          OpFinishRecord(self(0), _elm_3(9), 22i32, 10i32);
        }#block(9):void;
      }#block(6):void;
      OpFreeText(t(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_tokens(self: ref(Lexer)[0], tokens: vector<text>[12]) [1186]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<Token[start]>[4]:Hash(20, [0]) keys [tp:1 desc:false field:4, ][24]
   6[40]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=tokens[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=t#index[56]:integer
  14[56]: Text() var=t[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=t#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["tokens"]
  30[92]: VarInt(var[56]) -> integer var=t#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=280)
  60[80]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  63[96]: ConstInt(val=0) -> integer
  68[100]: TextCharacter(v1: text, v2: integer) -> character
  69[84]: VarCharacter(var[84]) -> character var=f[84]:character
  72[88]: ConvBoolFromCharacter(v1: character) -> boolean
  73[85]: Not(v1: boolean) -> boolean
  74[85]: GotoFalseWord(jump=87, if_false: boolean)
  77[84]: FreeText(var[60])
  80[84]: FreeStack(value=0, discard=28)
  84[56]: GotoWord(jump=14)
  87[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  90[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<Token[start]>[4]:Hash(20, [0]) keys [tp:1 desc:false field:4, ][24]
  93[96]: VarCharacter(var[84]) -> character var=f[84]:character
  96[100]: ConvIntFromCharacter(v1: character) -> integer
  97[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 101[96]: ConvBoolFromRef(val: ref(reference)) -> boolean
 102[85]: GotoFalseWord(jump=178, if_false: boolean)
 105[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 108[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<Token[start]>[4]:Hash(20, [0]) keys [tp:1 desc:false field:4, ][24]
 111[96]: VarCharacter(var[84]) -> character var=f[84]:character
 114[100]: ConvIntFromCharacter(v1: character) -> integer
 115[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 119[96]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 124[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 127[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 130[124]: Call(size=0, call=_tp_text_len[318])
 137[112]: SetInt(v1: ref(reference), fld=0, val: integer)
 140[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 143[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 146[124]: SetText(v1: ref(reference), fld=4, val: text)
 149[96]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 152[108]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<Token[start]>[4]:Hash(20, [0]) keys [tp:1 desc:false field:4, ][24]
 155[108]: VarCharacter(var[84]) -> character var=f[84]:character
 158[112]: ConvIntFromCharacter(v1: character) -> integer
 159[112]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 163[108]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 166[120]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 171[96]: FreeStack(value=0, discard=12)
 175[84]: GotoWord(jump=266)
 178[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 181[96]: NewRecord(data: ref(reference), parent_tp=22, fld=10) -> ref(reference)
 186[96]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(Token)["self"]
 189[108]: VarCharacter(var[84]) -> character var=f[84]:character
 192[112]: ConvIntFromCharacter(v1: character) -> integer
 193[112]: SetInt(v1: ref(reference), fld=4, val: integer)
 196[96]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(Token)["self"]
 199[108]: ConstInt(val=0) -> integer
 204[112]: SetInt(v1: ref(reference), fld=8, val: integer)
 207[96]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(Token)["self"]
 210[108]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 215[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 218[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 221[136]: Call(size=0, call=_tp_text_len[318])
 228[124]: SetInt(v1: ref(reference), fld=0, val: integer)
 231[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 234[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 237[136]: SetText(v1: ref(reference), fld=4, val: text)
 240[108]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(Token)["self"]
 243[120]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 246[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 251[108]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 254[120]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(Token)["self"]
 257[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=10)
 262[108]: FreeStack(value=0, discard=24)
 266[84]: FreeStack(value=0, discard=4)
 270[80]: FreeText(var[60])
 273[80]: FreeStack(value=0, discard=24)
 277[56]: GotoWord(jump=14)
 280[56]: FreeStack(value=0, discard=16)
 284[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_parse(self:Lexer, filename:text) {#block(1):void
  __ref_1(1):ref(File) = null;
  __work_1(1):text = "";
  v(1):integer = _tp_text_rfind(filename(0), "/");
  OpSetText(self(0), 4i32, if OpConvBoolFromInt(v(1)) {#block(2):text["filename"]
    OpGetTextSub(filename(0), OpAddInt(v(1), 1i32), 2147483647i32);
  }#block(2):text["filename"] else {#block(3):text["filename"]
    filename(0);
  }#block(3):text["filename"]);
  OpSetText(self(0), 8i32, _tp_File_content(file(filename(0), __ref_1(1)), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]));
  OpSetInt(self(0), 12i32, 0i32);
  OpSetInt(self(0), 16i32, 1i32);
  OpSetInt(self(0), 20i32, 1i32);
  OpFreeRef(__ref_1(1));
  OpFreeText(__work_1(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse(self: ref(Lexer)[0], filename: text[12]) [1476]
   0[28]: return-address
   0[32]: ConvRefFromNull() -> ref(reference) var=__ref_1[36]:ref(File)
   1[44]: Text() var=__work_1[48]:text
   2[68]: ArgText(var[16]) -> text var=filename[16]:text
   5[84]: ConstText(_value="/") -> text
   8[100]: StaticCall(_tp_text_rfind)
  11[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[84]: VarInt(var[72]) -> integer var=v[72]:integer
  17[88]: ConvBoolFromInt(v1: integer) -> boolean
  18[85]: GotoFalseWord(jump=42, if_false: boolean)
  21[84]: ArgText(var[16]) -> text var=filename[16]:text
  24[100]: VarInt(var[72]) -> integer var=v[72]:integer
  27[104]: ConstInt(val=1) -> integer
  32[108]: AddInt(v1: integer, v2: integer) -> integer
  33[104]: ConstInt(val=2147483647) -> integer
  38[108]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  39[100]: GotoWord(jump=45)
  42[84]: ArgText(var[16]) -> text var=filename[16]:text
  45[100]: SetText(v1: ref(reference), fld=4, val: text)
  48[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  51[84]: ArgText(var[16]) -> text var=filename[16]:text
  54[100]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
  57[112]: Call(size=0, call=file[695])
  64[96]: CreateRef(var[48]) -> ref(reference)
  67[108]: Call(size=0, call=_tp_File_content[414])
  74[100]: SetText(v1: ref(reference), fld=8, val: text)
  77[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[84]: ConstInt(val=0) -> integer
  85[88]: SetInt(v1: ref(reference), fld=12, val: integer)
  88[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  91[84]: ConstInt(val=1) -> integer
  96[88]: SetInt(v1: ref(reference), fld=16, val: integer)
  99[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 102[84]: ConstInt(val=1) -> integer
 107[88]: SetInt(v1: ref(reference), fld=20, val: integer)
 110[72]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
 113[84]: FreeRef(v1: ref(reference))
 114[72]: FreeText(var[48])
 117[72]: Return(ret=28, value=0, discard=72)

fn _tp_Lexer_parse_string(self:Lexer, name:text, content:text) {#block(1):void
  OpSetText(self(0), 4i32, name(0));
  OpSetText(self(0), 8i32, content(0));
  OpSetInt(self(0), 12i32, 0i32);
  OpSetInt(self(0), 16i32, 1i32);
  OpSetInt(self(0), 20i32, 1i32);
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse_string(self: ref(Lexer)[0], name: text[12], content: text[28]) [1599]
   0[44]: return-address
   0[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[60]: ArgText(var[16]) -> text var=name[16]:text
   6[76]: SetText(v1: ref(reference), fld=4, val: text)
   9[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[60]: ArgText(var[32]) -> text var=content[32]:text
  15[76]: SetText(v1: ref(reference), fld=8, val: text)
  18[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  21[60]: ConstInt(val=0) -> integer
  26[64]: SetInt(v1: ref(reference), fld=12, val: integer)
  29[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  32[60]: ConstInt(val=1) -> integer
  37[64]: SetInt(v1: ref(reference), fld=16, val: integer)
  40[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  43[60]: ConstInt(val=1) -> integer
  48[64]: SetInt(v1: ref(reference), fld=20, val: integer)
  51[48]: Return(ret=44, value=0, discard=48)

fn _tp_Lexer_skip_whitespace(self:Lexer) {#block(1):void
  s(1):integer = OpGetInt(self(0), 12i32);
  {#For block(2):void
    t#index(2):integer = OpConvIntFromNull();
    loop {#For loop_3
      t(3):integer = {#Iter range(4):integer
        t#index(2):integer = if OpNot(OpConvBoolFromInt(t#index(2))) 0i32 else OpAddInt(t#index(2), 1i32);
        if OpGeInt(t#index(2), 300i32) break(0) else null;
        t#index(2);
      }#Iter range(4):integer;
      {#block(5):void
        if if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(32i32)) true else OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(9i32)) {#block(6):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(6):void else if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(7):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 16i32, OpAddInt(OpGetInt(self(0), 16i32), 1i32));
          OpSetInt(self(0), 20i32, 1i32);
        }#block(7):void else if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), 2i32)), "//") {#block(8):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 2i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
          {#For block(9):void
            c#index(9):integer = OpConvIntFromNull();
            loop {#For loop_10
              c(10):integer = {#Iter range(11):integer
                c#index(9):integer = if OpNot(OpConvBoolFromInt(c#index(9))) 0i32 else OpAddInt(c#index(9), 1i32);
                if OpGeInt(c#index(9), 1000i32) break(0) else null;
                c#index(9);
              }#Iter range(11):integer;
              {#block(12):void
                if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(13):void
                  break(0);
                }#block(13):void else null;
                OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
                OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
              }#block(12):void;
            }#For loop_10;
          }#For block(9):void;
        }#block(8):void else {#block(14):void
          break(0);
        }#block(14):void;
      }#block(5):void;
    }#For loop_3;
  }#For block(2):void;
  OpSetInt(self(0), 24i32, OpGetInt(self(0), 24i32));
  OpSetEnum(self(0), 40i32, 1u8(17));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_skip_whitespace(self: ref(Lexer)[0]) [1656]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetInt(v1: ref(reference), fld=12) -> integer
   6[20]: ConvIntFromNull() -> integer var=t#index[24]:integer
   7[24]: VarInt(var[24]) -> integer var=t#index[24]:integer
  10[28]: ConvBoolFromInt(v1: integer) -> boolean
  11[25]: Not(v1: boolean) -> boolean
  12[25]: GotoFalseWord(jump=23, if_false: boolean)
  15[24]: ConstInt(val=0) -> integer
  20[28]: GotoWord(jump=32)
  23[24]: VarInt(var[24]) -> integer var=t#index[24]:integer
  26[28]: ConstInt(val=1) -> integer
  31[32]: AddInt(v1: integer, v2: integer) -> integer
  32[28]: PutInt(var[24], value: integer)
  35[24]: VarInt(var[24]) -> integer var=t#index[24]:integer
  38[28]: ConstInt(val=300) -> integer
  43[32]: GeInt(v1: integer, v2: integer) -> boolean
  44[25]: GotoFalseWord(jump=50, if_false: boolean)
  47[24]: GotoWord(jump=429)
  50[24]: VarInt(var[24]) -> integer var=t#index[24]:integer
  53[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  56[40]: GetText(v1: ref(reference), fld=8) -> text["self"]
  59[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  62[56]: GetInt(v1: ref(reference), fld=12) -> integer
  65[48]: TextCharacter(v1: text, v2: integer) -> character
  66[32]: ConvIntFromCharacter(v1: character) -> integer
  67[32]: ConstInt(val=32) -> integer
  72[36]: ConvIntFromCharacter(v1: character) -> integer
  73[36]: EqInt(v1: integer, v2: integer) -> boolean
  74[29]: GotoFalseWord(jump=81, if_false: boolean)
  77[28]: ConstTrue() -> boolean
  78[29]: GotoWord(jump=102)
  81[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  84[40]: GetText(v1: ref(reference), fld=8) -> text["self"]
  87[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  90[56]: GetInt(v1: ref(reference), fld=12) -> integer
  93[48]: TextCharacter(v1: text, v2: integer) -> character
  94[32]: ConvIntFromCharacter(v1: character) -> integer
  95[32]: ConstInt(val=9) -> integer
 100[36]: ConvIntFromCharacter(v1: character) -> integer
 101[36]: EqInt(v1: integer, v2: integer) -> boolean
 102[29]: GotoFalseWord(jump=144, if_false: boolean)
 105[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 108[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 111[52]: GetInt(v1: ref(reference), fld=12) -> integer
 114[44]: ConstInt(val=1) -> integer
 119[48]: AddInt(v1: integer, v2: integer) -> integer
 120[44]: SetInt(v1: ref(reference), fld=12, val: integer)
 123[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 126[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 129[52]: GetInt(v1: ref(reference), fld=20) -> integer
 132[44]: ConstInt(val=1) -> integer
 137[48]: AddInt(v1: integer, v2: integer) -> integer
 138[44]: SetInt(v1: ref(reference), fld=20, val: integer)
 141[28]: GotoWord(jump=422)
 144[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 147[40]: GetText(v1: ref(reference), fld=8) -> text["self"]
 150[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 153[56]: GetInt(v1: ref(reference), fld=12) -> integer
 156[48]: TextCharacter(v1: text, v2: integer) -> character
 157[32]: ConvIntFromCharacter(v1: character) -> integer
 158[32]: ConstInt(val=10) -> integer
 163[36]: ConvIntFromCharacter(v1: character) -> integer
 164[36]: EqInt(v1: integer, v2: integer) -> boolean
 165[29]: GotoFalseWord(jump=218, if_false: boolean)
 168[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 171[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 174[52]: GetInt(v1: ref(reference), fld=12) -> integer
 177[44]: ConstInt(val=1) -> integer
 182[48]: AddInt(v1: integer, v2: integer) -> integer
 183[44]: SetInt(v1: ref(reference), fld=12, val: integer)
 186[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 189[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 192[52]: GetInt(v1: ref(reference), fld=16) -> integer
 195[44]: ConstInt(val=1) -> integer
 200[48]: AddInt(v1: integer, v2: integer) -> integer
 201[44]: SetInt(v1: ref(reference), fld=16, val: integer)
 204[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 207[40]: ConstInt(val=1) -> integer
 212[44]: SetInt(v1: ref(reference), fld=20, val: integer)
 215[28]: GotoWord(jump=422)
 218[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 221[40]: GetText(v1: ref(reference), fld=8) -> text["self"]
 224[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 227[56]: GetInt(v1: ref(reference), fld=12) -> integer
 230[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 233[60]: GetInt(v1: ref(reference), fld=12) -> integer
 236[52]: ConstInt(val=2) -> integer
 241[56]: AddInt(v1: integer, v2: integer) -> integer
 242[52]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 243[44]: ConstText(_value="//") -> text
 247[60]: EqText(v1: text, v2: text) -> boolean
 248[29]: GotoFalseWord(jump=415, if_false: boolean)
 251[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 254[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 257[52]: GetInt(v1: ref(reference), fld=12) -> integer
 260[44]: ConstInt(val=2) -> integer
 265[48]: AddInt(v1: integer, v2: integer) -> integer
 266[44]: SetInt(v1: ref(reference), fld=12, val: integer)
 269[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 272[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 275[52]: GetInt(v1: ref(reference), fld=20) -> integer
 278[44]: ConstInt(val=1) -> integer
 283[48]: AddInt(v1: integer, v2: integer) -> integer
 284[44]: SetInt(v1: ref(reference), fld=20, val: integer)
 287[28]: ConvIntFromNull() -> integer var=c#index[32]:integer
 288[32]: VarInt(var[32]) -> integer var=c#index[32]:integer
 291[36]: ConvBoolFromInt(v1: integer) -> boolean
 292[33]: Not(v1: boolean) -> boolean
 293[33]: GotoFalseWord(jump=304, if_false: boolean)
 296[32]: ConstInt(val=0) -> integer
 301[36]: GotoWord(jump=313)
 304[32]: VarInt(var[32]) -> integer var=c#index[32]:integer
 307[36]: ConstInt(val=1) -> integer
 312[40]: AddInt(v1: integer, v2: integer) -> integer
 313[36]: PutInt(var[32], value: integer)
 316[32]: VarInt(var[32]) -> integer var=c#index[32]:integer
 319[36]: ConstInt(val=1000) -> integer
 324[40]: GeInt(v1: integer, v2: integer) -> boolean
 325[33]: GotoFalseWord(jump=331, if_false: boolean)
 328[32]: GotoWord(jump=408)
 331[32]: VarInt(var[32]) -> integer var=c#index[32]:integer
 334[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 337[48]: GetText(v1: ref(reference), fld=8) -> text["self"]
 340[52]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 343[64]: GetInt(v1: ref(reference), fld=12) -> integer
 346[56]: TextCharacter(v1: text, v2: integer) -> character
 347[40]: ConvIntFromCharacter(v1: character) -> integer
 348[40]: ConstInt(val=10) -> integer
 353[44]: ConvIntFromCharacter(v1: character) -> integer
 354[44]: EqInt(v1: integer, v2: integer) -> boolean
 355[37]: GotoFalseWord(jump=365, if_false: boolean)
 358[36]: FreeStack(value=0, discard=4)
 362[32]: GotoWord(jump=408)
 365[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 368[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 371[60]: GetInt(v1: ref(reference), fld=12) -> integer
 374[52]: ConstInt(val=1) -> integer
 379[56]: AddInt(v1: integer, v2: integer) -> integer
 380[52]: SetInt(v1: ref(reference), fld=12, val: integer)
 383[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 386[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 389[60]: GetInt(v1: ref(reference), fld=20) -> integer
 392[52]: ConstInt(val=1) -> integer
 397[56]: AddInt(v1: integer, v2: integer) -> integer
 398[52]: SetInt(v1: ref(reference), fld=20, val: integer)
 401[36]: FreeStack(value=0, discard=4)
 405[32]: GotoWord(jump=288)
 408[32]: FreeStack(value=0, discard=4)
 412[28]: GotoWord(jump=422)
 415[28]: FreeStack(value=0, discard=4)
 419[24]: GotoWord(jump=429)
 422[28]: FreeStack(value=0, discard=4)
 426[24]: GotoWord(jump=7)
 429[24]: FreeStack(value=0, discard=4)
 433[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 436[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 439[44]: GetInt(v1: ref(reference), fld=24) -> integer
 442[36]: SetInt(v1: ref(reference), fld=24, val: integer)
 445[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 448[32]: ConstEnum(val=1) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Identifier", "SToken", "SKeyword"])[17]
 450[33]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 453[20]: Return(ret=12, value=0, discard=20)

fn _tp_Lexer_test(self:Lexer, with:text) -> boolean {#block(1):boolean
  _tp_Lexer_skip_whitespace(self(0));
  false;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_test(self: ref(Lexer)[0], with: text[12]) [2115] -> boolean
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: Call(size=0, call=_tp_Lexer_skip_whitespace[1656])
  10[32]: ConstFalse() -> boolean
  11[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_match(self:Lexer, with:text) -> boolean {#block(1):boolean
  if _tp_Lexer_test(self(0), with(0)) {#block(2):boolean
    OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), _tp_text_len(with(0))));
    OpSetByte(self(0), 43i32, 0i32, if false 1i32 else 0i32);
    OpSetText(self(0), 36i32, "");
    true;
  }#block(2):boolean else {#block(3):boolean
    false;
  }#block(3):boolean;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_match(self: ref(Lexer)[0], with: text[12]) [2132] -> boolean
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: ArgText(var[16]) -> text var=with[16]:text
   6[60]: Call(size=0, call=_tp_Lexer_test[2115])
  13[33]: GotoFalseWord(jump=76, if_false: boolean)
  16[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  19[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  22[56]: GetInt(v1: ref(reference), fld=20) -> integer
  25[48]: ArgText(var[16]) -> text var=with[16]:text
  28[64]: Call(size=0, call=_tp_text_len[318])
  35[52]: AddInt(v1: integer, v2: integer) -> integer
  36[48]: SetInt(v1: ref(reference), fld=20, val: integer)
  39[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  42[44]: ConstFalse() -> boolean
  43[45]: GotoFalseWord(jump=54, if_false: boolean)
  46[44]: ConstInt(val=1) -> integer
  51[48]: GotoWord(jump=59)
  54[44]: ConstInt(val=0) -> integer
  59[48]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
  64[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  67[44]: ConstText(_value="") -> text
  69[60]: SetText(v1: ref(reference), fld=36, val: text)
  72[32]: ConstTrue() -> boolean
  73[33]: GotoWord(jump=77)
  76[32]: ConstFalse() -> boolean
  77[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_scan(self:Lexer) {#block(1):void
  _tp_Lexer_skip_whitespace(self(0));
  negative(1):boolean = false;
  if _tp_character_is_alphabetic(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))) {#block(2):void
    OpSetEnum(self(0), 40i32, 8u8(17));
    {#For block(3):void
      t#index(3):integer = OpConvIntFromNull();
      loop {#For loop_4
        t(4):integer = {#Iter range(5):integer
          t#index(3):integer = if OpNot(OpConvBoolFromInt(t#index(3))) 0i32 else OpAddInt(t#index(3), 1i32);
          if OpGeInt(t#index(3), 300i32) break(0) else null;
          t#index(3);
        }#Iter range(5):integer;
        {#block(6):void
          l(6):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if OpNot(_tp_character_is_alphanumeric(l(6))) {#block(7):void
            break(0);
          }#block(7):void else null;
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(6):void;
      }#For loop_4;
    }#For block(3):void;
  }#block(2):void else null;
  if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(45i32)) {#block(8):void
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
    negative(1):boolean = true;
  }#block(8):void else null;
  if if OpGeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(48i32)) OpLeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(57i32)) else false {#block(9):void
    OpSetEnum(self(0), 40i32, 2u8(17));
    {#For block(10):void
      t#index(10):integer = OpConvIntFromNull();
      loop {#For loop_11
        t(11):integer = {#Iter range(12):integer
          t#index(10):integer = if OpNot(OpConvBoolFromInt(t#index(10))) 0i32 else OpAddInt(t#index(10), 1i32);
          if OpGeInt(t#index(10), 30i32) break(0) else null;
          t#index(10);
        }#Iter range(12):integer;
        {#block(13):void
          l(13):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if if if if if OpNeInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(95i32)) OpNeInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(46i32)) else false OpNeInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(101i32)) else false OpNeInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(45i32)) else false if OpLtInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(48i32)) true else OpGtInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(57i32)) else false {#block(14):void
            break(0);
          }#block(14):void else null;
          if OpEqInt(OpConvIntFromCharacter(l(13)), OpConvIntFromCharacter(108i32)) {#block(15):void
            res(15):Scanned = 5u8(17);
          }#block(15):void else null;
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(13):void;
      }#For loop_11;
    }#For block(10):void;
  }#block(9):void else {#block(16):null
    if negative(1) {#block(17):void
      OpSetInt(self(0), 12i32, OpMinInt(OpGetInt(self(0), 12i32), 1i32));
      OpSetInt(self(0), 20i32, OpMinInt(OpGetInt(self(0), 20i32), 1i32));
    }#block(17):void else null;
    drop null;
  }#block(16):null;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_scan(self: ref(Lexer)[0]) [2215]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: Call(size=0, call=_tp_Lexer_skip_whitespace[1656])
  10[16]: ConstFalse() -> boolean var=negative[20]:boolean
  11[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
  17[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  20[45]: GetInt(v1: ref(reference), fld=12) -> integer
  23[37]: TextCharacter(v1: text, v2: integer) -> character
  24[21]: StaticCall(_tp_character_is_alphabetic)
  27[18]: GotoFalseWord(jump=166, if_false: boolean)
  30[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  33[29]: ConstEnum(val=8) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Identifier", "SToken", "SKeyword"])[17]
  35[30]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
  38[17]: ConvIntFromNull() -> integer var=t#index[21]:integer
  39[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
  42[25]: ConvBoolFromInt(v1: integer) -> boolean
  43[22]: Not(v1: boolean) -> boolean
  44[22]: GotoFalseWord(jump=55, if_false: boolean)
  47[21]: ConstInt(val=0) -> integer
  52[25]: GotoWord(jump=64)
  55[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
  58[25]: ConstInt(val=1) -> integer
  63[29]: AddInt(v1: integer, v2: integer) -> integer
  64[25]: PutInt(var[21], value: integer)
  67[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
  70[25]: ConstInt(val=300) -> integer
  75[29]: GeInt(v1: integer, v2: integer) -> boolean
  76[22]: GotoFalseWord(jump=82, if_false: boolean)
  79[21]: GotoWord(jump=162)
  82[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
  85[25]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  88[37]: GetText(v1: ref(reference), fld=8) -> text["self"]
  91[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  94[53]: GetInt(v1: ref(reference), fld=12) -> integer
  97[45]: TextCharacter(v1: text, v2: integer) -> character
  98[29]: VarCharacter(var[29]) -> character var=l[29]:character
 101[33]: StaticCall(_tp_character_is_alphanumeric)
 104[30]: Not(v1: boolean) -> boolean
 105[30]: GotoFalseWord(jump=115, if_false: boolean)
 108[29]: FreeStack(value=0, discard=8)
 112[21]: GotoWord(jump=162)
 115[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 118[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 121[53]: GetInt(v1: ref(reference), fld=12) -> integer
 124[45]: ConstInt(val=1) -> integer
 129[49]: AddInt(v1: integer, v2: integer) -> integer
 130[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 133[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 136[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 139[53]: GetInt(v1: ref(reference), fld=20) -> integer
 142[45]: ConstInt(val=1) -> integer
 147[49]: AddInt(v1: integer, v2: integer) -> integer
 148[45]: SetInt(v1: ref(reference), fld=20, val: integer)
 151[29]: FreeStack(value=0, discard=4)
 155[25]: FreeStack(value=0, discard=4)
 159[21]: GotoWord(jump=39)
 162[21]: FreeStack(value=0, discard=4)
 166[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 169[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
 172[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 175[45]: GetInt(v1: ref(reference), fld=12) -> integer
 178[37]: TextCharacter(v1: text, v2: integer) -> character
 179[21]: ConvIntFromCharacter(v1: character) -> integer
 180[21]: ConstInt(val=45) -> integer
 185[25]: ConvIntFromCharacter(v1: character) -> integer
 186[25]: EqInt(v1: integer, v2: integer) -> boolean
 187[18]: GotoFalseWord(jump=230, if_false: boolean)
 190[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 193[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 196[41]: GetInt(v1: ref(reference), fld=12) -> integer
 199[33]: ConstInt(val=1) -> integer
 204[37]: AddInt(v1: integer, v2: integer) -> integer
 205[33]: SetInt(v1: ref(reference), fld=12, val: integer)
 208[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 211[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 214[41]: GetInt(v1: ref(reference), fld=20) -> integer
 217[33]: ConstInt(val=1) -> integer
 222[37]: AddInt(v1: integer, v2: integer) -> integer
 223[33]: SetInt(v1: ref(reference), fld=20, val: integer)
 226[17]: ConstTrue() -> boolean var=negative[20]:boolean
 227[18]: PutBool(var=2, value: boolean)
 230[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 233[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
 236[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 239[45]: GetInt(v1: ref(reference), fld=12) -> integer
 242[37]: TextCharacter(v1: text, v2: integer) -> character
 243[21]: ConvIntFromCharacter(v1: character) -> integer
 244[21]: ConstInt(val=48) -> integer
 249[25]: ConvIntFromCharacter(v1: character) -> integer
 250[25]: GeInt(v1: integer, v2: integer) -> boolean
 251[18]: GotoFalseWord(jump=278, if_false: boolean)
 254[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 257[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
 260[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 263[45]: GetInt(v1: ref(reference), fld=12) -> integer
 266[37]: TextCharacter(v1: text, v2: integer) -> character
 267[21]: ConvIntFromCharacter(v1: character) -> integer
 268[21]: ConstInt(val=57) -> integer
 273[25]: ConvIntFromCharacter(v1: character) -> integer
 274[25]: LeInt(v1: integer, v2: integer) -> boolean
 275[18]: GotoWord(jump=279)
 278[17]: ConstFalse() -> boolean
 279[18]: GotoFalseWord(jump=535, if_false: boolean)
 282[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 285[29]: ConstEnum(val=2) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Identifier", "SToken", "SKeyword"])[17]
 287[30]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 290[17]: ConvIntFromNull() -> integer var=t#index[21]:integer
 291[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 294[25]: ConvBoolFromInt(v1: integer) -> boolean
 295[22]: Not(v1: boolean) -> boolean
 296[22]: GotoFalseWord(jump=307, if_false: boolean)
 299[21]: ConstInt(val=0) -> integer
 304[25]: GotoWord(jump=316)
 307[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 310[25]: ConstInt(val=1) -> integer
 315[29]: AddInt(v1: integer, v2: integer) -> integer
 316[25]: PutInt(var[21], value: integer)
 319[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 322[25]: ConstInt(val=30) -> integer
 327[29]: GeInt(v1: integer, v2: integer) -> boolean
 328[22]: GotoFalseWord(jump=334, if_false: boolean)
 331[21]: GotoWord(jump=528)
 334[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 337[25]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 340[37]: GetText(v1: ref(reference), fld=8) -> text["self"]
 343[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 346[53]: GetInt(v1: ref(reference), fld=12) -> integer
 349[45]: TextCharacter(v1: text, v2: integer) -> character
 350[29]: VarCharacter(var[29]) -> character var=l[29]:character
 353[33]: ConvIntFromCharacter(v1: character) -> integer
 354[33]: ConstInt(val=95) -> integer
 359[37]: ConvIntFromCharacter(v1: character) -> integer
 360[37]: NeInt(v1: integer, v2: integer) -> boolean
 361[30]: GotoFalseWord(jump=378, if_false: boolean)
 364[29]: VarCharacter(var[29]) -> character var=l[29]:character
 367[33]: ConvIntFromCharacter(v1: character) -> integer
 368[33]: ConstInt(val=46) -> integer
 373[37]: ConvIntFromCharacter(v1: character) -> integer
 374[37]: NeInt(v1: integer, v2: integer) -> boolean
 375[30]: GotoWord(jump=379)
 378[29]: ConstFalse() -> boolean
 379[30]: GotoFalseWord(jump=396, if_false: boolean)
 382[29]: VarCharacter(var[29]) -> character var=l[29]:character
 385[33]: ConvIntFromCharacter(v1: character) -> integer
 386[33]: ConstInt(val=101) -> integer
 391[37]: ConvIntFromCharacter(v1: character) -> integer
 392[37]: NeInt(v1: integer, v2: integer) -> boolean
 393[30]: GotoWord(jump=397)
 396[29]: ConstFalse() -> boolean
 397[30]: GotoFalseWord(jump=414, if_false: boolean)
 400[29]: VarCharacter(var[29]) -> character var=l[29]:character
 403[33]: ConvIntFromCharacter(v1: character) -> integer
 404[33]: ConstInt(val=45) -> integer
 409[37]: ConvIntFromCharacter(v1: character) -> integer
 410[37]: NeInt(v1: integer, v2: integer) -> boolean
 411[30]: GotoWord(jump=415)
 414[29]: ConstFalse() -> boolean
 415[30]: GotoFalseWord(jump=450, if_false: boolean)
 418[29]: VarCharacter(var[29]) -> character var=l[29]:character
 421[33]: ConvIntFromCharacter(v1: character) -> integer
 422[33]: ConstInt(val=48) -> integer
 427[37]: ConvIntFromCharacter(v1: character) -> integer
 428[37]: LtInt(v1: integer, v2: integer) -> boolean
 429[30]: GotoFalseWord(jump=436, if_false: boolean)
 432[29]: ConstTrue() -> boolean
 433[30]: GotoWord(jump=447)
 436[29]: VarCharacter(var[29]) -> character var=l[29]:character
 439[33]: ConvIntFromCharacter(v1: character) -> integer
 440[33]: ConstInt(val=57) -> integer
 445[37]: ConvIntFromCharacter(v1: character) -> integer
 446[37]: GtInt(v1: integer, v2: integer) -> boolean
 447[30]: GotoWord(jump=451)
 450[29]: ConstFalse() -> boolean
 451[30]: GotoFalseWord(jump=461, if_false: boolean)
 454[29]: FreeStack(value=0, discard=8)
 458[21]: GotoWord(jump=528)
 461[29]: VarCharacter(var[29]) -> character var=l[29]:character
 464[33]: ConvIntFromCharacter(v1: character) -> integer
 465[33]: ConstInt(val=108) -> integer
 470[37]: ConvIntFromCharacter(v1: character) -> integer
 471[37]: EqInt(v1: integer, v2: integer) -> boolean
 472[30]: GotoFalseWord(jump=481, if_false: boolean)
 475[29]: ConstEnum(val=5) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Identifier", "SToken", "SKeyword"])[17] var=res[33]:Scanned
 477[30]: FreeStack(value=0, discard=1)
 481[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 484[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 487[53]: GetInt(v1: ref(reference), fld=12) -> integer
 490[45]: ConstInt(val=1) -> integer
 495[49]: AddInt(v1: integer, v2: integer) -> integer
 496[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 499[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 502[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 505[53]: GetInt(v1: ref(reference), fld=20) -> integer
 508[45]: ConstInt(val=1) -> integer
 513[49]: AddInt(v1: integer, v2: integer) -> integer
 514[45]: SetInt(v1: ref(reference), fld=20, val: integer)
 517[29]: FreeStack(value=0, discard=4)
 521[25]: FreeStack(value=0, discard=4)
 525[21]: GotoWord(jump=291)
 528[21]: FreeStack(value=0, discard=4)
 532[17]: GotoWord(jump=577)
 535[17]: VarBool(var[20]) -> boolean var=negative[20]:boolean
 538[18]: GotoFalseWord(jump=577, if_false: boolean)
 541[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 544[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 547[41]: GetInt(v1: ref(reference), fld=12) -> integer
 550[33]: ConstInt(val=1) -> integer
 555[37]: MinInt(v1: integer, v2: integer) -> integer
 556[33]: SetInt(v1: ref(reference), fld=12, val: integer)
 559[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 562[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 565[41]: GetInt(v1: ref(reference), fld=20) -> integer
 568[33]: ConstInt(val=1) -> integer
 573[37]: MinInt(v1: integer, v2: integer) -> integer
 574[33]: SetInt(v1: ref(reference), fld=20, val: integer)
 577[17]: Return(ret=12, value=0, discard=17)

fn _tp_Lexer_peek(self:Lexer) -> text {#block(1):text
  "";
}#block(1):text

byte-code for lib/lexer.lav:_tp_Lexer_peek(self: ref(Lexer)[0]) [2798] -> text
   0[12]: return-address
   0[16]: ConstText(_value="") -> text
   2[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_position(self:Lexer) -> text {#block(1):text
  __work_1(1):text = "";
  {#Formatted string(2):text
    __work_1(1):text = "";
    OpFormatText(__work_1(1), OpGetText(self(0), 4i32), 0i32, -1i32, 32i32);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 16i32), 10i32, 0i32, 32i32, false, false);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 20i32), 10i32, 0i32, 32i32, false, false);
    __work_1(1);
  }#Formatted string(2):text;
}#block(1):text

byte-code for lib/lexer.lav:_tp_Lexer_position(self: ref(Lexer)[0]) [2806] -> text
   0[12]: return-address
   0[16]: Text() var=__work_1[20]:text
   1[40]: ClearText(var[20]) var=__work_1[20]:text
   4[40]: ConstText(_value="") -> text
   6[56]: AppendText(var[20], v1: text)
   9[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[52]: GetText(v1: ref(reference), fld=4) -> text["self"]
  15[56]: ConstInt(val=0) -> integer
  20[60]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
  25[40]: ConstText(_value=":") -> text
  28[56]: AppendText(var[20], v1: text)
  31[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  34[52]: GetInt(v1: ref(reference), fld=16) -> integer
  37[44]: ConstInt(val=0) -> integer
  42[48]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  49[40]: ConstText(_value=":") -> text
  52[56]: AppendText(var[20], v1: text)
  55[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  58[52]: GetInt(v1: ref(reference), fld=20) -> integer
  61[44]: ConstInt(val=0) -> integer
  66[48]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  73[40]: VarText(var[20]) -> text var=__work_1[20]:text
  76[56]: Return(ret=12, value=16, discard=56) type=text[4]:Base[5]

fn _tp_Lexer_identifier(self:Lexer) -> text 

byte-code for lib/lexer.lav:_tp_Lexer_identifier(self: ref(Lexer)[0]) [2888] -> text
   0[12]: return-address

fn _tp_Lexer_int(self:Lexer) -> integer {#block(1):integer
  0i32;
}#block(1):integer

byte-code for lib/lexer.lav:_tp_Lexer_int(self: ref(Lexer)[0]) [2888] -> integer
   0[12]: return-address
   0[16]: ConstInt(val=0) -> integer
   5[20]: Return(ret=12, value=4, discard=20) type=integer[4]:Base[0]

fn _tp_Lexer_long_int(self:Lexer) -> long 

byte-code for lib/lexer.lav:_tp_Lexer_long_int(self: ref(Lexer)[0]) [2899] -> long
   0[12]: return-address

fn _tp_Lexer_long_float(self:Lexer) -> float 

byte-code for lib/lexer.lav:_tp_Lexer_long_float(self: ref(Lexer)[0]) [2899] -> float
   0[12]: return-address

fn _tp_Lexer_single_float(self:Lexer) -> single 

byte-code for lib/lexer.lav:_tp_Lexer_single_float(self: ref(Lexer)[0]) [2899] -> single
   0[12]: return-address

fn _tp_Lexer_constant_string(self:Lexer) -> text 

byte-code for lib/lexer.lav:_tp_Lexer_constant_string(self: ref(Lexer)[0]) [2899] -> text
   0[12]: return-address

fn _tp_Lexer_string_finished(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 42i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_string_finished(self: ref(Lexer)[0]) [2899] -> boolean
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=42, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_last_comment(self:Lexer) -> text["self"] {#block(1):text["self"]
  OpGetText(self(0), 36i32);
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_last_comment(self: ref(Lexer)[0]) [2919] -> text["self"]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=36) -> text["self"]
   6[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_comment_behind(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 43i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_comment_behind(self: ref(Lexer)[0]) [2931] -> boolean
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=43, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_anchor(self:Lexer) -> Anchor {#block(1):ref(Anchor)
  __ref_1(1):ref(Anchor) = null;
  {#Object(2):ref(Anchor)["__ref_1"]
    OpDatabase(__ref_1(1), 25i32);
    OpSetInt(__ref_1(1), 4i32, OpGetInt(self(0), 12i32));
    OpSetInt(__ref_1(1), 8i32, OpGetInt(self(0), 16i32));
    OpSetInt(__ref_1(1), 12i32, OpGetInt(self(0), 20i32));
    __ref_1(1);
  }#Object(2):ref(Anchor)["__ref_1"];
}#block(1):ref(Anchor)

byte-code for lib/lexer.lav:_tp_Lexer_anchor(self: ref(Lexer)[0]) [2951] -> ref(Anchor)
   0[12]: return-address
   0[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(Anchor)
   1[28]: Database(var[20], db_tp=25) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]
   6[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
   9[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[52]: GetInt(v1: ref(reference), fld=12) -> integer
  15[44]: SetInt(v1: ref(reference), fld=4, val: integer)
  18[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  21[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  24[52]: GetInt(v1: ref(reference), fld=16) -> integer
  27[44]: SetInt(v1: ref(reference), fld=8, val: integer)
  30[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  33[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  36[52]: GetInt(v1: ref(reference), fld=20) -> integer
  39[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  45[40]: Return(ret=12, value=12, discard=40) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]

fn _tp_Lexer_revert(self:Lexer, to:Anchor) {#block(1):void
  OpSetInt(self(0), 12i32, OpGetInt(to(0), 4i32));
  OpSetInt(self(0), 16i32, OpGetInt(to(0), 8i32));
  OpSetInt(self(0), 20i32, OpGetInt(to(0), 12i32));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_revert(self: ref(Lexer)[0], to: ref(Anchor)[12]) [3002]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
   6[52]: GetInt(v1: ref(reference), fld=4) -> integer
   9[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  12[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  18[52]: GetInt(v1: ref(reference), fld=8) -> integer
  21[44]: SetInt(v1: ref(reference), fld=16, val: integer)
  24[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  27[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  30[52]: GetInt(v1: ref(reference), fld=12) -> integer
  33[44]: SetInt(v1: ref(reference), fld=20, val: integer)
  36[28]: Return(ret=24, value=0, discard=28)

fn testing(l:Lexer) {#block(1):void
  __work_2(1):text = "";
  __work_1(1):text = "";
  if OpNot(_tp_Lexer_match(l(0), "+")) null else OpPanic("Incorrect plus");
  if OpNeText(_tp_Lexer_peek(l(0)), "+") null else OpPanic("Incorrect plus");
  if _tp_Lexer_match(l(0), "+=") null else OpPanic("Incorrect plus_is");
  if OpEqInt(_tp_Lexer_int(l(0)), OpMinSingleInt(2i32)) null else OpPanic("Integer");
  if _tp_Lexer_match(l(0), "*") null else OpPanic("Incorrect multi");
  if OpNeInt(_tp_Lexer_int(l(0)), 3i32) null else OpPanic("Incorrect integer");
  if OpEqLong(_tp_Lexer_long_int(l(0)), OpConvLongFromInt(3i32)) null else OpPanic("Incorrect long");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:14") null else OpPanic({#Formatted string(2):text
    __work_1(1):text = "Incorrect position ";
    OpFormatText(__work_1(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_1(1);
  }#Formatted string(2):text);
  if OpNot(_tp_Lexer_match(l(0), ">")) null else OpPanic("Incorrect higher");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:15") null else OpPanic({#Formatted string(3):text
    __work_2(1):text = "Incorrect position ";
    OpFormatText(__work_2(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_2(1);
  }#Formatted string(3):text);
  if _tp_Lexer_match(l(0), ">>") null else OpPanic("Incorrect logical shift");
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:testing(l: ref(Lexer)[0]) [3044]
   0[12]: return-address
   0[16]: Text() var=__work_2[20]:text
   1[40]: Text() var=__work_1[44]:text
   2[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
   5[76]: ConstText(_value="+") -> text
   8[92]: Call(size=0, call=_tp_Lexer_match[2132])
  15[65]: Not(v1: boolean) -> boolean
  16[65]: GotoFalseWord(jump=22, if_false: boolean)
  19[64]: GotoWord(jump=39)
  22[64]: ConstText(_value="Incorrect plus") -> text
  38[80]: Panic(message: text)
  39[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
  42[76]: Call(size=0, call=_tp_Lexer_peek[2798])
  49[80]: ConstText(_value="+") -> text
  52[96]: NeText(v1: text, v2: text) -> boolean
  53[65]: GotoFalseWord(jump=59, if_false: boolean)
  56[64]: GotoWord(jump=76)
  59[64]: ConstText(_value="Incorrect plus") -> text
  75[80]: Panic(message: text)
  76[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
  79[76]: ConstText(_value="+=") -> text
  83[92]: Call(size=0, call=_tp_Lexer_match[2132])
  90[65]: GotoFalseWord(jump=96, if_false: boolean)
  93[64]: GotoWord(jump=116)
  96[64]: ConstText(_value="Incorrect plus_is") -> text
 115[80]: Panic(message: text)
 116[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 119[76]: Call(size=0, call=_tp_Lexer_int[2888])
 126[68]: ConstInt(val=2) -> integer
 131[72]: MinSingleInt(v1: integer) -> integer
 132[72]: EqInt(v1: integer, v2: integer) -> boolean
 133[65]: GotoFalseWord(jump=139, if_false: boolean)
 136[64]: GotoWord(jump=149)
 139[64]: ConstText(_value="Integer") -> text
 148[80]: Panic(message: text)
 149[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 152[76]: ConstText(_value="*") -> text
 155[92]: Call(size=0, call=_tp_Lexer_match[2132])
 162[65]: GotoFalseWord(jump=168, if_false: boolean)
 165[64]: GotoWord(jump=186)
 168[64]: ConstText(_value="Incorrect multi") -> text
 185[80]: Panic(message: text)
 186[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 189[76]: Call(size=0, call=_tp_Lexer_int[2888])
 196[68]: ConstInt(val=3) -> integer
 201[72]: NeInt(v1: integer, v2: integer) -> boolean
 202[65]: GotoFalseWord(jump=208, if_false: boolean)
 205[64]: GotoWord(jump=228)
 208[64]: ConstText(_value="Incorrect integer") -> text
 227[80]: Panic(message: text)
 228[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 231[76]: Call(size=0, call=_tp_Lexer_string_finished[2899])
 238[72]: ConstInt(val=3) -> integer
 243[76]: ConvLongFromInt(v1: integer) -> long
 244[80]: EqLong(v1: long, v2: long) -> boolean
 245[65]: GotoFalseWord(jump=251, if_false: boolean)
 248[64]: GotoWord(jump=268)
 251[64]: ConstText(_value="Incorrect long") -> text
 267[80]: Panic(message: text)
 268[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 271[76]: Call(size=0, call=_tp_Lexer_position[2806])
 278[80]: ConstText(_value="Tokens:1:14") -> text
 291[96]: EqText(v1: text, v2: text) -> boolean
 292[65]: GotoFalseWord(jump=298, if_false: boolean)
 295[64]: GotoWord(jump=349)
 298[64]: ClearText(var[44]) var=__work_1[44]:text
 301[64]: ConstText(_value="Incorrect position ") -> text
 322[80]: AppendText(var[44], v1: text)
 325[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 328[76]: Call(size=0, call=_tp_Lexer_position[2806])
 335[80]: ConstInt(val=0) -> integer
 340[84]: FormatText(var[44], val: text, width: integer, dir=-1, token=32)
 345[64]: VarText(var[44]) -> text var=__work_1[44]:text
 348[80]: Panic(message: text)
 349[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 352[76]: ConstText(_value=">") -> text
 355[92]: Call(size=0, call=_tp_Lexer_match[2132])
 362[65]: Not(v1: boolean) -> boolean
 363[65]: GotoFalseWord(jump=369, if_false: boolean)
 366[64]: GotoWord(jump=388)
 369[64]: ConstText(_value="Incorrect higher") -> text
 387[80]: Panic(message: text)
 388[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 391[76]: Call(size=0, call=_tp_Lexer_position[2806])
 398[80]: ConstText(_value="Tokens:1:15") -> text
 411[96]: EqText(v1: text, v2: text) -> boolean
 412[65]: GotoFalseWord(jump=418, if_false: boolean)
 415[64]: GotoWord(jump=469)
 418[64]: ClearText(var[20]) var=__work_2[20]:text
 421[64]: ConstText(_value="Incorrect position ") -> text
 442[80]: AppendText(var[20], v1: text)
 445[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 448[76]: Call(size=0, call=_tp_Lexer_position[2806])
 455[80]: ConstInt(val=0) -> integer
 460[84]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
 465[64]: VarText(var[20]) -> text var=__work_2[20]:text
 468[80]: Panic(message: text)
 469[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 472[76]: ConstText(_value=">>") -> text
 476[92]: Call(size=0, call=_tp_Lexer_match[2132])
 483[65]: GotoFalseWord(jump=489, if_false: boolean)
 486[64]: GotoWord(jump=515)
 489[64]: ConstText(_value="Incorrect logical shift") -> text
 514[80]: Panic(message: text)
 515[64]: FreeText(var[44])
 518[64]: FreeText(var[20])
 521[64]: Return(ret=12, value=0, discard=64)

fn main() {#block(1):void
  __ref_1(1):ref(main_vector<text>) = null;
  l(1):ref(Lexer) = null;
  OpDatabase(l(1), 22i32);
  OpSetText(l(1), 4i32, "");
  OpSetText(l(1), 8i32, "");
  OpSetInt(l(1), 12i32, 0i32);
  OpSetInt(l(1), 16i32, 0i32);
  OpSetInt(l(1), 20i32, 0i32);
  OpSetInt(l(1), 24i32, 0i32);
  OpSetEnum(l(1), 40i32, 0i32);
  OpSetByte(l(1), 41i32, 0i32, if false 1i32 else 0i32);
  OpSetByte(l(1), 42i32, 0i32, if false 1i32 else 0i32);
  OpSetInt(l(1), 28i32, 0i32);
  OpSetInt(l(1), 32i32, 0i32);
  OpSetByte(l(1), 43i32, 0i32, if false 1i32 else 0i32);
  OpSetText(l(1), 36i32, "");
  _tp_Lexer_set_tokens(l(1), {#Vector(2):vector<text>
    OpDatabase(__ref_1(1), 14i32);
    _vec_1(2):vector<text>["__ref_1"] = OpGetField(__ref_1(1), 4i32, 7i32);
    OpSetInt(__ref_1(1), 4i32, 0i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "+=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "*=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "-=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<<");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _vec_1(2);
  }#Vector(2):vector<text>);
  _tp_Lexer_parse_string(l(1), "Tokens", "12 += -2 * 3l >> 4");
  if OpEqInt(_tp_Lexer_int(l(1)), 12i32) null else OpPanic("Integer");
  if OpNot(_tp_Lexer_match(l(1), "+")) null else OpPanic("Incorrect plus");
  OpFreeRef(l(1));
  OpFreeRef(__ref_1(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:main() [3571]
   0[0]: return-address
   0[4]: ConvRefFromNull() -> ref(reference) var=__ref_1[8]:ref(main_vector<text>)
   1[16]: ConvRefFromNull() -> ref(reference) var=l[20]:ref(Lexer)
   2[28]: Database(var[20], db_tp=22) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22]
   7[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  10[40]: ConstText(_value="") -> text
  12[56]: SetText(v1: ref(reference), fld=4, val: text)
  15[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  18[40]: ConstText(_value="") -> text
  20[56]: SetText(v1: ref(reference), fld=8, val: text)
  23[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  26[40]: ConstInt(val=0) -> integer
  31[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  34[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  37[40]: ConstInt(val=0) -> integer
  42[44]: SetInt(v1: ref(reference), fld=16, val: integer)
  45[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  48[40]: ConstInt(val=0) -> integer
  53[44]: SetInt(v1: ref(reference), fld=20, val: integer)
  56[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  59[40]: ConstInt(val=0) -> integer
  64[44]: SetInt(v1: ref(reference), fld=24, val: integer)
  67[28]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  70[40]: ConstInt(val=0) -> integer
  75[44]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
  78[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
  81[43]: ConstFalse() -> boolean
  82[44]: GotoFalseWord(jump=93, if_false: boolean)
  85[43]: ConstInt(val=1) -> integer
  90[47]: GotoWord(jump=98)
  93[43]: ConstInt(val=0) -> integer
  98[47]: SetByte(v1: ref(reference), fld=41, min=0, val: integer)
 103[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 106[43]: ConstFalse() -> boolean
 107[44]: GotoFalseWord(jump=118, if_false: boolean)
 110[43]: ConstInt(val=1) -> integer
 115[47]: GotoWord(jump=123)
 118[43]: ConstInt(val=0) -> integer
 123[47]: SetByte(v1: ref(reference), fld=42, min=0, val: integer)
 128[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 131[43]: ConstInt(val=0) -> integer
 136[47]: SetInt(v1: ref(reference), fld=28, val: integer)
 139[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 142[43]: ConstInt(val=0) -> integer
 147[47]: SetInt(v1: ref(reference), fld=32, val: integer)
 150[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 153[43]: ConstFalse() -> boolean
 154[44]: GotoFalseWord(jump=165, if_false: boolean)
 157[43]: ConstInt(val=1) -> integer
 162[47]: GotoWord(jump=170)
 165[43]: ConstInt(val=0) -> integer
 170[47]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
 175[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 178[43]: ConstText(_value="") -> text
 180[59]: SetText(v1: ref(reference), fld=36, val: text)
 183[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 186[43]: Database(var[8], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 191[43]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 194[55]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 197[55]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 200[67]: ConstInt(val=0) -> integer
 205[71]: SetInt(v1: ref(reference), fld=4, val: integer)
 208[55]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 211[67]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 216[67]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 219[79]: ConstText(_value="+=") -> text
 223[95]: SetText(v1: ref(reference), fld=0, val: text)
 226[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 229[79]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 232[91]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 237[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 240[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 245[79]: PutRef(var[59], value: ref(reference))
 248[67]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 251[79]: ConstText(_value="*=") -> text
 255[95]: SetText(v1: ref(reference), fld=0, val: text)
 258[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 261[79]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 264[91]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 269[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 272[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 277[79]: PutRef(var[59], value: ref(reference))
 280[67]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 283[79]: ConstText(_value="-=") -> text
 287[95]: SetText(v1: ref(reference), fld=0, val: text)
 290[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 293[79]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 296[91]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 301[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 304[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 309[79]: PutRef(var[59], value: ref(reference))
 312[67]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 315[79]: ConstText(_value=">>") -> text
 319[95]: SetText(v1: ref(reference), fld=0, val: text)
 322[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 325[79]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 328[91]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 333[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 336[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 341[79]: PutRef(var[59], value: ref(reference))
 344[67]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 347[79]: ConstText(_value="<<") -> text
 351[95]: SetText(v1: ref(reference), fld=0, val: text)
 354[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 357[79]: VarRef(var[59]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[59]:ref(boolean)["_vec_1"]
 360[91]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 365[67]: VarVector(var[47]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[47]:vector<text>["__ref_1"]
 368[79]: FreeStack(value=12, discard=36)
 372[55]: Call(size=0, call=_tp_Lexer_set_tokens[1186])
 379[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 382[43]: ConstText(_value="Tokens") -> text
 390[59]: ConstText(_value="12 += -2 * 3l >> 4") -> text
 410[75]: Call(size=0, call=_tp_Lexer_parse_string[1599])
 417[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 420[43]: Call(size=0, call=_tp_Lexer_int[2888])
 427[35]: ConstInt(val=12) -> integer
 432[39]: EqInt(v1: integer, v2: integer) -> boolean
 433[32]: GotoFalseWord(jump=439, if_false: boolean)
 436[31]: GotoWord(jump=449)
 439[31]: ConstText(_value="Integer") -> text
 448[47]: Panic(message: text)
 449[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 452[43]: ConstText(_value="+") -> text
 455[59]: Call(size=0, call=_tp_Lexer_match[2132])
 462[32]: Not(v1: boolean) -> boolean
 463[32]: GotoFalseWord(jump=469, if_false: boolean)
 466[31]: GotoWord(jump=486)
 469[31]: ConstText(_value="Incorrect plus") -> text
 485[47]: Panic(message: text)
 486[31]: VarRef(var[20]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<Keyword[name]>[28], tokens:hash<Token[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[20]:ref(Lexer)
 489[43]: FreeRef(v1: ref(reference))
 490[31]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 493[43]: FreeRef(v1: ref(reference))
 494[31]: Return(ret=0, value=0, discard=31)

