Type 17:Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])

Type 18:SKeyword[8]:
    name:text[4]

Type 19:Possible[8]:
    length:integer[0]
    token:text[4]

Type 20:SToken[12]:
    start:character[4]
    possible:sorted<Possible[-length,token]>[8]

Type 21:sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ]

Type 22:Lexer[44]:
    file:text[4]
    data:text[8]
    index:integer[12]
    line:integer[16]
    pos:integer[20]
    start:integer[24]
    scanned:Scanned[40]
    string:boolean[41]
    finished:boolean[42]
    keywords:hash<SKeyword[name]>[28]
    tokens:hash<SToken[start]>[32]
    behind:boolean[43]
    comment:text[36]

Type 23:hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ]

Type 24:hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ]

Type 25:Anchor[16]:
    index:integer[4]
    line:integer[8]
    pos:integer[12]

Type 26:vector<SKeyword>[4]:Vector(18)

Type 27:vector<Possible>[4]:Vector(19)

Type 28:vector<SToken>[4]:Vector(20)

fn _tp_Lexer_set_keywords(self:Lexer, keywords:vector<text>) {#block(1):void
  [50] OpGetField(self(0), 28i32, 23i32);
  [51] {#For block(2):void
    _vector_1(2):vector<text>["keywords"] = keywords(0);
    k#index(2):integer = -1i32;
    loop {#For loop_3
      k(3):text["_vector_1"] = {#iter next(4):text
        k#index(2):integer = OpAddInt(k#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, k#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(k(3))) {#break(5):void
        OpFreeText(k(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        [52] _elm_2(6):ref(SKeyword)["self"] = OpNewRecord(self(0), 22i32, 9i32);
        OpSetText(_elm_2(6), 4i32, k(3));
        OpFinishRecord(self(0), _elm_2(6), 22i32, 9i32);
      }#block(6):void;
      OpFreeText(k(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_keywords(self: ref(Lexer)[0], keywords: vector<text>[12])
   0[24]: return-address
   0[28]: [50] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
   6[40]: [51] VarVector(var[12]) -> vector type=vector<text>[4]:Vector(5)[7] var=keywords[12]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=k#index[52]:integer
  14[56]: Text() var=k[56]:text["_vector_1"]
  15[80]: VarInt(var[52]) -> integer var=k#index[52]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[52], value: integer)
  27[80]: VarVector(var[40]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[40]:vector<text>["keywords"]
  30[92]: VarInt(var[52]) -> integer var=k#index[52]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[56], v1: text)
  42[80]: VarText(var[56]) -> text var=k[56]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[56])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=102)
  60[80]: [52] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  63[92]: NewRecord(data: ref(reference), parent_tp=22, fld=9) -> ref(reference)
  68[92]: VarRef(var[80]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[80]:ref(SKeyword)["self"]
  71[104]: VarText(var[56]) -> text var=k[56]:text["_vector_1"]
  74[120]: SetText(v1: ref(reference), fld=4, val: text)
  77[92]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  80[104]: VarRef(var[80]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[80]:ref(SKeyword)["self"]
  83[116]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=9)
  88[92]: FreeStack(value=0, discard=12)
  92[80]: FreeText(var[56])
  95[80]: FreeStack(value=0, discard=24)
  99[56]: GotoWord(jump=14)
 102[56]: FreeStack(value=0, discard=16)
 106[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_set_tokens(self:Lexer, tokens:vector<text>) {#block(1):void
  [58] OpGetField(self(0), 32i32, 24i32);
  [59] {#For block(2):void
    _vector_1(2):vector<text>["tokens"] = tokens(0);
    t#index(2):integer = -1i32;
    loop {#For loop_3
      t(3):text["_vector_1"] = {#iter next(4):text
        t#index(2):integer = OpAddInt(t#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, t#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(t(3))) {#break(5):void
        OpFreeText(t(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        [60] f(6):character = OpTextCharacter(t(3), 0i32);
        [61] if OpNot(OpConvBoolFromCharacter(f(6))) {#block(7):void
          [62] OpFreeText(t(3));
          continue(0);
        }#block(7):void else null;
        [64] if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6))) {#block(8):void
          [65] _elm_2(8):ref(Possible)["self"] = OpNewRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), 20i32, 1i32);
          OpSetInt(_elm_2(8), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_2(8), 4i32, t(3));
          OpFinishRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), _elm_2(8), 20i32, 1i32);
        }#block(8):void else {#block(9):void
          [67] _elm_3(9):ref(SToken)["self"] = OpNewRecord(self(0), 22i32, 10i32);
          OpSetInt(_elm_3(9), 4i32, f(6));
          OpSetInt(_elm_3(9), 8i32, 0i32);
          _elm_4(9):ref(Possible)["_elm_3"] = OpNewRecord(_elm_3(9), 20i32, 1i32);
          OpSetInt(_elm_4(9), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_4(9), 4i32, t(3));
          OpFinishRecord(_elm_3(9), _elm_4(9), 20i32, 1i32);
          OpFinishRecord(self(0), _elm_3(9), 22i32, 10i32);
        }#block(9):void;
      }#block(6):void;
      OpFreeText(t(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_tokens(self: ref(Lexer)[0], tokens: vector<text>[12])
   0[24]: return-address
   0[28]: [58] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
   6[40]: [59] VarVector(var[12]) -> vector type=vector<text>[4]:Vector(5)[7] var=tokens[12]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=t#index[52]:integer
  14[56]: Text() var=t[56]:text["_vector_1"]
  15[80]: VarInt(var[52]) -> integer var=t#index[52]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[52], value: integer)
  27[80]: VarVector(var[40]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[40]:vector<text>["tokens"]
  30[92]: VarInt(var[52]) -> integer var=t#index[52]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[56], v1: text)
  42[80]: VarText(var[56]) -> text var=t[56]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[56])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=276)
  60[80]: [60] VarText(var[56]) -> text var=t[56]:text["_vector_1"]
  63[96]: ConstInt(val=0) -> integer
  68[100]: TextCharacter(v1: text, v2: integer) -> character
  69[84]: [61] VarCharacter(var[80]) -> character var=f[80]:character
  72[88]: ConvBoolFromCharacter(v1: character) -> boolean
  73[85]: Not(v1: boolean) -> boolean
  74[85]: GotoFalseWord(jump=87, if_false: boolean)
  77[84]: [62] FreeText(var[56])
  80[84]: FreeStack(value=0, discard=28)
  84[56]: GotoWord(jump=14)
  87[84]: [64] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  90[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
  93[96]: VarCharacter(var[80]) -> character var=f[80]:character
  96[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 100[96]: ConvBoolFromRef(val: ref(reference)) -> boolean
 101[85]: GotoFalseWord(jump=175, if_false: boolean)
 104[84]: [65] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 107[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 110[96]: VarCharacter(var[80]) -> character var=f[80]:character
 113[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 117[96]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 122[96]: VarRef(var[84]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[84]:ref(Possible)["self"]
 125[108]: VarText(var[56]) -> text var=t[56]:text["_vector_1"]
 128[124]: Call(size=0, fn=_tp_text_len)
 135[112]: SetInt(v1: ref(reference), fld=0, val: integer)
 138[96]: VarRef(var[84]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[84]:ref(Possible)["self"]
 141[108]: VarText(var[56]) -> text var=t[56]:text["_vector_1"]
 144[124]: SetText(v1: ref(reference), fld=4, val: text)
 147[96]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 150[108]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 153[108]: VarCharacter(var[80]) -> character var=f[80]:character
 156[112]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 160[108]: VarRef(var[84]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[84]:ref(Possible)["self"]
 163[120]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 168[96]: FreeStack(value=0, discard=12)
 172[84]: GotoWord(jump=262)
 175[84]: [67] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 178[96]: NewRecord(data: ref(reference), parent_tp=22, fld=10) -> ref(reference)
 183[96]: VarRef(var[84]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[84]:ref(SToken)["self"]
 186[108]: VarCharacter(var[80]) -> character var=f[80]:character
 189[112]: SetInt(v1: ref(reference), fld=4, val: integer)
 192[96]: VarRef(var[84]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[84]:ref(SToken)["self"]
 195[108]: ConstInt(val=0) -> integer
 200[112]: SetInt(v1: ref(reference), fld=8, val: integer)
 203[96]: VarRef(var[84]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[84]:ref(SToken)["self"]
 206[108]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 211[108]: VarRef(var[96]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[96]:ref(Possible)["_elm_3"]
 214[120]: VarText(var[56]) -> text var=t[56]:text["_vector_1"]
 217[136]: Call(size=0, fn=_tp_text_len)
 224[124]: SetInt(v1: ref(reference), fld=0, val: integer)
 227[108]: VarRef(var[96]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[96]:ref(Possible)["_elm_3"]
 230[120]: VarText(var[56]) -> text var=t[56]:text["_vector_1"]
 233[136]: SetText(v1: ref(reference), fld=4, val: text)
 236[108]: VarRef(var[84]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[84]:ref(SToken)["self"]
 239[120]: VarRef(var[96]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[96]:ref(Possible)["_elm_3"]
 242[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 247[108]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 250[120]: VarRef(var[84]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[84]:ref(SToken)["self"]
 253[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=10)
 258[108]: FreeStack(value=0, discard=24)
 262[84]: FreeStack(value=0, discard=4)
 266[80]: FreeText(var[56])
 269[80]: FreeStack(value=0, discard=24)
 273[56]: GotoWord(jump=14)
 276[56]: FreeStack(value=0, discard=16)
 280[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_skip_whitespace(self:Lexer) {#block(1):void
  __work_2(1):text = "";
  __work_1(1):text = "";
  [74] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), OpMinInt(OpGetInt(self(0), 12i32), OpGetInt(self(0), 24i32))));
  [75] start(1):boolean = OpEqInt(OpGetInt(self(0), 20i32), 1i32);
  [76] {#For block(2):void
    t#index(2):integer = OpConvIntFromNull();
    loop {#For loop_3
      t(3):integer = {#Iter range(4):integer
        t#index(2):integer = if OpNot(OpConvBoolFromInt(t#index(2))) 0i32 else OpAddInt(t#index(2), 1i32);
        if OpGeInt(t#index(2), 300i32) break(0) else null;
        t#index(2);
      }#Iter range(4):integer;
      {#block(5):void
        [77] if if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(32i32)) true else OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(9i32)) {#block(6):void
          [78] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          [79] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(6):void else if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(7):void
          [81] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          [82] OpSetInt(self(0), 16i32, OpAddInt(OpGetInt(self(0), 16i32), 1i32));
          [83] OpSetInt(self(0), 20i32, 1i32);
          [84] start(1):boolean = true;
          [85] println({#Formatted string(8):text["__work_1"]
            __work_1(1):text = "new_line start ";
            OpFormatText(__work_1(1), OpCastTextFromBool(start(1)), 0i32, -1i32, 32i32);
            OpAppendText(__work_1(1), " pos:");
            OpFormatLong(__work_1(1), OpConvLongFromInt(OpGetInt(self(0), 20i32)), 10i32, 0i32, 32i32, false, false);
            __work_1(1);
          }#Formatted string(8):text["__work_1"]);
        }#block(7):void else if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), 2i32)), "//") {#block(9):void
          [87] println({#Formatted string(10):text["__work_2"]
            __work_2(1):text = "comment start ";
            OpFormatText(__work_2(1), OpCastTextFromBool(start(1)), 0i32, -1i32, 32i32);
            OpAppendText(__work_2(1), " pos:");
            OpFormatLong(__work_2(1), OpConvLongFromInt(OpGetInt(self(0), 20i32)), 10i32, 0i32, 32i32, false, false);
            __work_2(1);
          }#Formatted string(10):text["__work_2"]);
          [88] if OpNot(start(1)) {#block(11):void
            [89] OpSetByte(self(0), 43i32, 0i32, if true 1i32 else 0i32);
          }#block(11):void else null;
          [91] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 2i32));
          [92] com(9):integer = OpGetInt(self(0), 12i32);
          [93] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
          [94] {#For block(12):void
            c#index(12):integer = OpConvIntFromNull();
            loop {#For loop_13
              c(13):integer = {#Iter range(14):integer
                c#index(12):integer = if OpNot(OpConvBoolFromInt(c#index(12))) 0i32 else OpAddInt(c#index(12), 1i32);
                if OpGeInt(c#index(12), 1000i32) break(0) else null;
                c#index(12);
              }#Iter range(14):integer;
              {#block(15):void
                [95] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(16):void
                  [96] if OpNeText(OpGetText(self(0), 36i32), "") {#block(17):void
                    [97] _field_1(17):text = OpGetText(self(0), 36i32);
                    OpAppendCharacter(_field_1(17), 10i32);
                    OpSetText(self(0), 36i32, _field_1(17));
                    OpFreeText(_field_1(17));
                  }#block(17):void else null;
                  [99] _field_2(16):text = OpGetText(self(0), 36i32);
                  OpAppendText(_field_2(16), _tp_text_trim_start(OpGetTextSub(OpGetText(self(0), 8i32), com(9), OpGetInt(self(0), 12i32))));
                  OpSetText(self(0), 36i32, _field_2(16));
                  [100] OpFreeText(_field_2(16));
                  break(0);
                  OpFreeText(_field_2(16));
                }#block(16):void else null;
                [102] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
                [103] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
              }#block(15):void;
            }#For loop_13;
          }#For block(12):void;
        }#block(9):void else {#block(18):void
          [106] break(0);
        }#block(18):void;
      }#block(5):void;
    }#For loop_3;
  }#For block(2):void;
  [109] OpSetInt(self(0), 24i32, OpGetInt(self(0), 12i32));
  [110] OpSetEnum(self(0), 40i32, 1u8(17));
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_skip_whitespace(self: ref(Lexer)[0])
   0[12]: return-address
   0[16]: Text() var=__work_2[16]:text
   1[40]: Text() var=__work_1[40]:text
   2[64]: [74] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   5[76]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   8[88]: GetInt(v1: ref(reference), fld=20) -> integer
  11[80]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  14[92]: GetInt(v1: ref(reference), fld=12) -> integer
  17[84]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  20[96]: GetInt(v1: ref(reference), fld=24) -> integer
  23[88]: MinInt(v1: integer, v2: integer) -> integer
  24[84]: AddInt(v1: integer, v2: integer) -> integer
  25[80]: SetInt(v1: ref(reference), fld=20, val: integer)
  28[64]: [75] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  31[76]: GetInt(v1: ref(reference), fld=20) -> integer
  34[68]: ConstInt(val=1) -> integer
  39[72]: EqInt(v1: integer, v2: integer) -> boolean
  40[65]: [76] ConvIntFromNull() -> integer var=t#index[65]:integer
  41[69]: VarInt(var[65]) -> integer var=t#index[65]:integer
  44[73]: ConvBoolFromInt(v1: integer) -> boolean
  45[70]: Not(v1: boolean) -> boolean
  46[70]: GotoFalseWord(jump=57, if_false: boolean)
  49[69]: ConstInt(val=0) -> integer
  54[73]: GotoWord(jump=66)
  57[69]: VarInt(var[65]) -> integer var=t#index[65]:integer
  60[73]: ConstInt(val=1) -> integer
  65[77]: AddInt(v1: integer, v2: integer) -> integer
  66[73]: PutInt(var[65], value: integer)
  69[69]: VarInt(var[65]) -> integer var=t#index[65]:integer
  72[73]: ConstInt(val=300) -> integer
  77[77]: GeInt(v1: integer, v2: integer) -> boolean
  78[70]: GotoFalseWord(jump=84, if_false: boolean)
  81[69]: GotoWord(jump=757)
  84[69]: VarInt(var[65]) -> integer var=t#index[65]:integer
  87[73]: [77] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  90[85]: GetText(v1: ref(reference), fld=8) -> text["self"]
  93[89]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  96[101]: GetInt(v1: ref(reference), fld=12) -> integer
  99[93]: TextCharacter(v1: text, v2: integer) -> character
 100[77]: ConvIntFromCharacter(v1: character) -> integer
 101[77]: ConstInt(val=32) -> integer
 106[81]: ConvIntFromCharacter(v1: character) -> integer
 107[81]: EqInt(v1: integer, v2: integer) -> boolean
 108[74]: GotoFalseWord(jump=115, if_false: boolean)
 111[73]: ConstTrue() -> boolean
 112[74]: GotoWord(jump=136)
 115[73]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 118[85]: GetText(v1: ref(reference), fld=8) -> text["self"]
 121[89]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 124[101]: GetInt(v1: ref(reference), fld=12) -> integer
 127[93]: TextCharacter(v1: text, v2: integer) -> character
 128[77]: ConvIntFromCharacter(v1: character) -> integer
 129[77]: ConstInt(val=9) -> integer
 134[81]: ConvIntFromCharacter(v1: character) -> integer
 135[81]: EqInt(v1: integer, v2: integer) -> boolean
 136[74]: GotoFalseWord(jump=178, if_false: boolean)
 139[73]: [78] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 142[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 145[97]: GetInt(v1: ref(reference), fld=12) -> integer
 148[89]: ConstInt(val=1) -> integer
 153[93]: AddInt(v1: integer, v2: integer) -> integer
 154[89]: SetInt(v1: ref(reference), fld=12, val: integer)
 157[73]: [79] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 160[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 163[97]: GetInt(v1: ref(reference), fld=20) -> integer
 166[89]: ConstInt(val=1) -> integer
 171[93]: AddInt(v1: integer, v2: integer) -> integer
 172[89]: SetInt(v1: ref(reference), fld=20, val: integer)
 175[73]: GotoWord(jump=750)
 178[73]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 181[85]: GetText(v1: ref(reference), fld=8) -> text["self"]
 184[89]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 187[101]: GetInt(v1: ref(reference), fld=12) -> integer
 190[93]: TextCharacter(v1: text, v2: integer) -> character
 191[77]: ConvIntFromCharacter(v1: character) -> integer
 192[77]: ConstInt(val=10) -> integer
 197[81]: ConvIntFromCharacter(v1: character) -> integer
 198[81]: EqInt(v1: integer, v2: integer) -> boolean
 199[74]: GotoFalseWord(jump=332, if_false: boolean)
 202[73]: [81] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 205[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 208[97]: GetInt(v1: ref(reference), fld=12) -> integer
 211[89]: ConstInt(val=1) -> integer
 216[93]: AddInt(v1: integer, v2: integer) -> integer
 217[89]: SetInt(v1: ref(reference), fld=12, val: integer)
 220[73]: [82] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 223[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 226[97]: GetInt(v1: ref(reference), fld=16) -> integer
 229[89]: ConstInt(val=1) -> integer
 234[93]: AddInt(v1: integer, v2: integer) -> integer
 235[89]: SetInt(v1: ref(reference), fld=16, val: integer)
 238[73]: [83] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 241[85]: ConstInt(val=1) -> integer
 246[89]: SetInt(v1: ref(reference), fld=20, val: integer)
 249[73]: [84] ConstTrue() -> boolean var=start[64]:boolean
 250[74]: PutBool(var=10, value: boolean)
 253[73]: [85] ClearText(var[40]) var=__work_1[40]:text
 256[73]: ConstText(_value="new_line start ") -> text
 273[89]: AppendText(var[40], v1: text)
 276[73]: VarBool(var[64]) -> boolean var=start[64]:boolean
 279[74]: CastTextFromBool(v1: boolean) -> text
 280[89]: ConstInt(val=0) -> integer
 285[93]: FormatText(var[40], val: text, width: integer, dir=-1, token=32)
 290[73]: ConstText(_value=" pos:") -> text
 297[89]: AppendText(var[40], v1: text)
 300[73]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 303[85]: GetInt(v1: ref(reference), fld=20) -> integer
 306[77]: ConvLongFromInt(v1: integer) -> long
 307[81]: ConstInt(val=0) -> integer
 312[85]: FormatLong(var[40], val: long, radix=10, width: integer, token=32, plus=false, note=false)
 319[73]: VarText(var[40]) -> text var=__work_1[40]:text
 322[89]: Call(size=0, fn=println)
 329[73]: GotoWord(jump=750)
 332[73]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 335[85]: GetText(v1: ref(reference), fld=8) -> text["self"]
 338[89]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 341[101]: GetInt(v1: ref(reference), fld=12) -> integer
 344[93]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 347[105]: GetInt(v1: ref(reference), fld=12) -> integer
 350[97]: ConstInt(val=2) -> integer
 355[101]: AddInt(v1: integer, v2: integer) -> integer
 356[97]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 357[89]: ConstText(_value="//") -> text
 361[105]: EqText(v1: text, v2: text) -> boolean
 362[74]: GotoFalseWord(jump=743, if_false: boolean)
 365[73]: [87] ClearText(var[16]) var=__work_2[16]:text
 368[73]: ConstText(_value="comment start ") -> text
 384[89]: AppendText(var[16], v1: text)
 387[73]: VarBool(var[64]) -> boolean var=start[64]:boolean
 390[74]: CastTextFromBool(v1: boolean) -> text
 391[89]: ConstInt(val=0) -> integer
 396[93]: FormatText(var[16], val: text, width: integer, dir=-1, token=32)
 401[73]: ConstText(_value=" pos:") -> text
 408[89]: AppendText(var[16], v1: text)
 411[73]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 414[85]: GetInt(v1: ref(reference), fld=20) -> integer
 417[77]: ConvLongFromInt(v1: integer) -> long
 418[81]: ConstInt(val=0) -> integer
 423[85]: FormatLong(var[16], val: long, radix=10, width: integer, token=32, plus=false, note=false)
 430[73]: VarText(var[16]) -> text var=__work_2[16]:text
 433[89]: Call(size=0, fn=println)
 440[73]: [88] VarBool(var[64]) -> boolean var=start[64]:boolean
 443[74]: Not(v1: boolean) -> boolean
 444[74]: GotoFalseWord(jump=472, if_false: boolean)
 447[73]: [89] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 450[85]: ConstTrue() -> boolean
 451[86]: GotoFalseWord(jump=462, if_false: boolean)
 454[85]: ConstInt(val=1) -> integer
 459[89]: GotoWord(jump=467)
 462[85]: ConstInt(val=0) -> integer
 467[89]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
 472[73]: [91] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 475[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 478[97]: GetInt(v1: ref(reference), fld=12) -> integer
 481[89]: ConstInt(val=2) -> integer
 486[93]: AddInt(v1: integer, v2: integer) -> integer
 487[89]: SetInt(v1: ref(reference), fld=12, val: integer)
 490[73]: [92] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 493[85]: GetInt(v1: ref(reference), fld=12) -> integer
 496[77]: [93] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 499[89]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 502[101]: GetInt(v1: ref(reference), fld=20) -> integer
 505[93]: ConstInt(val=1) -> integer
 510[97]: AddInt(v1: integer, v2: integer) -> integer
 511[93]: SetInt(v1: ref(reference), fld=20, val: integer)
 514[77]: [94] ConvIntFromNull() -> integer var=c#index[77]:integer
 515[81]: VarInt(var[77]) -> integer var=c#index[77]:integer
 518[85]: ConvBoolFromInt(v1: integer) -> boolean
 519[82]: Not(v1: boolean) -> boolean
 520[82]: GotoFalseWord(jump=531, if_false: boolean)
 523[81]: ConstInt(val=0) -> integer
 528[85]: GotoWord(jump=540)
 531[81]: VarInt(var[77]) -> integer var=c#index[77]:integer
 534[85]: ConstInt(val=1) -> integer
 539[89]: AddInt(v1: integer, v2: integer) -> integer
 540[85]: PutInt(var[77], value: integer)
 543[81]: VarInt(var[77]) -> integer var=c#index[77]:integer
 546[85]: ConstInt(val=1000) -> integer
 551[89]: GeInt(v1: integer, v2: integer) -> boolean
 552[82]: GotoFalseWord(jump=558, if_false: boolean)
 555[81]: GotoWord(jump=732)
 558[81]: VarInt(var[77]) -> integer var=c#index[77]:integer
 561[85]: [95] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 564[97]: GetText(v1: ref(reference), fld=8) -> text["self"]
 567[101]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 570[113]: GetInt(v1: ref(reference), fld=12) -> integer
 573[105]: TextCharacter(v1: text, v2: integer) -> character
 574[89]: ConvIntFromCharacter(v1: character) -> integer
 575[89]: ConstInt(val=10) -> integer
 580[93]: ConvIntFromCharacter(v1: character) -> integer
 581[93]: EqInt(v1: integer, v2: integer) -> boolean
 582[86]: GotoFalseWord(jump=689, if_false: boolean)
 585[85]: [96] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 588[97]: GetText(v1: ref(reference), fld=36) -> text["self"]
 591[101]: ConstText(_value="") -> text
 593[117]: NeText(v1: text, v2: text) -> boolean
 594[86]: GotoFalseWord(jump=631, if_false: boolean)
 597[85]: [97] Text() var=_field_1[85]:text
 598[109]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 601[121]: GetText(v1: ref(reference), fld=36) -> text["self"]
 604[125]: AppendText(var[85], v1: text)
 607[109]: ConstInt(val=10) -> integer
 612[113]: AppendCharacter(var[85], v1: character)
 615[109]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 618[121]: VarText(var[85]) -> text var=_field_1[85]:text
 621[137]: SetText(v1: ref(reference), fld=36, val: text)
 624[109]: FreeText(var[85])
 627[109]: FreeStack(value=0, discard=24)
 631[85]: [99] Text() var=_field_2[85]:text
 632[109]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 635[121]: GetText(v1: ref(reference), fld=36) -> text["self"]
 638[125]: AppendText(var[85], v1: text)
 641[109]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 644[121]: GetText(v1: ref(reference), fld=8) -> text["self"]
 647[125]: VarInt(var[73]) -> integer var=com[73]:integer
 650[129]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 653[141]: GetInt(v1: ref(reference), fld=12) -> integer
 656[133]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 657[125]: StaticCall(_tp_text_trim_start)
 660[125]: AppendText(var[85], v1: text)
 663[109]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 666[121]: VarText(var[85]) -> text var=_field_2[85]:text
 669[137]: SetText(v1: ref(reference), fld=36, val: text)
 672[109]: [100] FreeText(var[85])
 675[109]: FreeStack(value=0, discard=28)
 679[81]: GotoWord(jump=732)
 682[109]: FreeText(var[85])
 685[109]: FreeStack(value=0, discard=24)
 689[85]: [102] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 692[97]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 695[109]: GetInt(v1: ref(reference), fld=12) -> integer
 698[101]: ConstInt(val=1) -> integer
 703[105]: AddInt(v1: integer, v2: integer) -> integer
 704[101]: SetInt(v1: ref(reference), fld=12, val: integer)
 707[85]: [103] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 710[97]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 713[109]: GetInt(v1: ref(reference), fld=20) -> integer
 716[101]: ConstInt(val=1) -> integer
 721[105]: AddInt(v1: integer, v2: integer) -> integer
 722[101]: SetInt(v1: ref(reference), fld=20, val: integer)
 725[85]: FreeStack(value=0, discard=4)
 729[81]: GotoWord(jump=515)
 732[81]: FreeStack(value=0, discard=4)
 736[77]: FreeStack(value=0, discard=4)
 740[73]: GotoWord(jump=750)
 743[73]: [106] FreeStack(value=0, discard=4)
 747[69]: GotoWord(jump=757)
 750[73]: FreeStack(value=0, discard=4)
 754[69]: GotoWord(jump=41)
 757[69]: FreeStack(value=0, discard=4)
 761[65]: [109] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 764[77]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 767[89]: GetInt(v1: ref(reference), fld=12) -> integer
 770[81]: SetInt(v1: ref(reference), fld=24, val: integer)
 773[65]: [110] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 776[77]: ConstEnum(val=1) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 778[78]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 781[65]: FreeText(var[40])
 784[65]: FreeText(var[16])
 787[65]: Return(ret=12, value=0, discard=65)

fn _tp_Lexer_scan(self:Lexer) {#block(1):void
  [116] OpSetText(self(0), 36i32, "");
  [117] OpSetByte(self(0), 43i32, 0i32, if false 1i32 else 0i32);
  [118] _tp_Lexer_skip_whitespace(self(0));
  [119] negative(1):boolean = false;
  [120] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
  [121] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromNull()) {#block(2):void
    [122] OpSetEnum(self(0), 40i32, 12u8(17));
    [123] return null;
  }#block(2):void else null;
  [125] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(3):void
    [126] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [127] OpSetEnum(self(0), 40i32, 8u8(17));
    [128] {#For block(4):void
      t#index(4):integer = OpConvIntFromNull();
      loop {#For loop_5
        t(5):integer = {#Iter range(6):integer
          t#index(4):integer = if OpNot(OpConvBoolFromInt(t#index(4))) 0i32 else OpAddInt(t#index(4), 1i32);
          if OpGeInt(t#index(4), 20i32) break(0) else null;
          t#index(4);
        }#Iter range(6):integer;
        {#block(7):void
          [129] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [130] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(8):void
            [131] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [132] return null;
          }#block(8):void else null;
          [134] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(9):void
            [135] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [136] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(39i32)) {#block(10):void
              [137] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(10):void else null;
          }#block(9):void else {#block(11):void
            [140] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          }#block(11):void;
        }#block(7):void;
      }#For loop_5;
    }#For block(4):void;
  }#block(3):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(12):void
    [144] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [145] OpSetEnum(self(0), 40i32, 6u8(17));
    [146] {#For block(13):void
      t#index(13):integer = OpConvIntFromNull();
      loop {#For loop_14
        t(14):integer = {#Iter range(15):integer
          t#index(13):integer = if OpNot(OpConvBoolFromInt(t#index(13))) 0i32 else OpAddInt(t#index(13), 1i32);
          if OpGeInt(t#index(13), 60000i32) break(0) else null;
          t#index(13);
        }#Iter range(15):integer;
        {#block(16):void
          [147] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [148] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(17):void
            [149] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [150] return null;
          }#block(17):void else null;
          [152] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(18):void
            [153] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [154] n(18):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
            [155] if if OpEqInt(OpConvIntFromCharacter(n(18)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(n(18)), OpConvIntFromCharacter(10i32)) {#block(19):void
              [156] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(19):void else null;
          }#block(18):void else {#block(20):void
            [159] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          }#block(20):void;
        }#block(16):void;
      }#For loop_14;
    }#For block(13):void;
    [162] return null;
  }#block(12):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(21):void
    [164] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [165] negative(1):boolean = true;
  }#block(21):void else null;
  [167] if if OpGeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(48i32)) OpLeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(57i32)) else false {#block(22):void
    [168] OpSetEnum(self(0), 40i32, 2u8(17));
    [169] {#For block(23):void
      t#index(13):integer = OpConvIntFromNull();
      loop {#For loop_24
        t(14):integer = {#Iter range(25):integer
          t#index(13):integer = if OpNot(OpConvBoolFromInt(t#index(13))) 0i32 else OpAddInt(t#index(13), 1i32);
          if OpGeInt(t#index(13), 30i32) break(0) else null;
          t#index(13);
        }#Iter range(25):integer;
        {#block(26):void
          [170] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [171] if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(46i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(101i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(27):void
            [172] OpSetEnum(self(0), 40i32, 3u8(17));
          }#block(27):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(108i32)) {#block(28):void
            [174] OpSetEnum(self(0), 40i32, 5u8(17));
          }#block(28):void else if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(120i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(111i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(98i32))  else if if OpNeInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(95i32)) if OpLtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(48i32)) true else OpGtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(57i32)) else false {#block(30):void
            [177] break(0);
          }#block(30):void else null;
          [179] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(26):void;
      }#For loop_24;
    }#For block(23):void;
    [181] return null;
  }#block(22):void else if negative(1) {#block(31):void
    [183] OpSetInt(self(0), 12i32, OpMinInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(31):void else null;
  [185] if _tp_character_is_alphabetic(l(1)) {#block(32):void
    [186] OpSetEnum(self(0), 40i32, 9u8(17));
    [187] {#For block(33):void
      t#index(13):integer = OpConvIntFromNull();
      loop {#For loop_34
        t(14):integer = {#Iter range(35):integer
          t#index(13):integer = if OpNot(OpConvBoolFromInt(t#index(13))) 0i32 else OpAddInt(t#index(13), 1i32);
          if OpGeInt(t#index(13), 300i32) break(0) else null;
          t#index(13);
        }#Iter range(35):integer;
        {#block(36):void
          [188] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [189] if OpNot(_tp_character_is_alphanumeric(l(1))) {#block(37):void
            [190] break(0);
          }#block(37):void else null;
          [192] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(36):void;
      }#For loop_34;
    }#For block(33):void;
    [194] return null;
  }#block(32):void else null;
  [197] OpSetEnum(self(0), 40i32, 10u8(17));
  [198] {#For block(38):void
    pt#index(38):integer = OpIterate(OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32, &[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], 0i32, 0i32);
    loop {#For loop_39
      pt(39):ref(Possible)["self"] = OpStep(pt#index(38), OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32);
      if OpNot(OpConvBoolFromRef(pt(39))) {#break(40):void
        break(0);
      }#break(40):void else null;
      {#block(41):void
        [199] tok(41):text["pt"] = OpGetText(pt(39), 4i32);
        [200] if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(41)))), tok(41)) {#block(42):void
          [201] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(41))));
          [202] OpFreeText(tok(41));
          return null;
        }#block(42):void else null;
        OpFreeText(tok(41));
      }#block(41):void;
    }#For loop_39;
  }#For block(38):void;
  [205] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_scan(self: ref(Lexer)[0])
   0[12]: return-address
   0[16]: [116] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: ConstText(_value="") -> text
   5[44]: SetText(v1: ref(reference), fld=36, val: text)
   8[16]: [117] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  11[28]: ConstFalse() -> boolean
  12[29]: GotoFalseWord(jump=23, if_false: boolean)
  15[28]: ConstInt(val=1) -> integer
  20[32]: GotoWord(jump=28)
  23[28]: ConstInt(val=0) -> integer
  28[32]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
  33[16]: [118] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  36[28]: Call(size=0, fn=_tp_Lexer_skip_whitespace)
  43[16]: [119] ConstFalse() -> boolean var=negative[16]:boolean
  44[17]: [120] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  47[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
  50[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  53[45]: GetInt(v1: ref(reference), fld=12) -> integer
  56[37]: TextCharacter(v1: text, v2: integer) -> character
  57[21]: [121] VarCharacter(var[17]) -> character var=l[17]:character
  60[25]: ConvIntFromCharacter(v1: character) -> integer
  61[25]: ConvIntFromNull() -> integer
  62[29]: EqInt(v1: integer, v2: integer) -> boolean
  63[22]: GotoFalseWord(jump=86, if_false: boolean)
  66[21]: [122] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  69[33]: ConstEnum(val=12) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
  71[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
  74[21]: [123] Return(ret=12, value=0, discard=21)
  80[21]: Return(ret=12, value=0, discard=21)
  86[21]: [125] VarCharacter(var[17]) -> character var=l[17]:character
  89[25]: ConvIntFromCharacter(v1: character) -> integer
  90[25]: ConstInt(val=39) -> integer
  95[29]: ConvIntFromCharacter(v1: character) -> integer
  96[29]: EqInt(v1: integer, v2: integer) -> boolean
  97[22]: GotoFalseWord(jump=342, if_false: boolean)
 100[21]: [126] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 103[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 106[45]: GetInt(v1: ref(reference), fld=12) -> integer
 109[37]: ConstInt(val=1) -> integer
 114[41]: AddInt(v1: integer, v2: integer) -> integer
 115[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 118[21]: [127] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 121[33]: ConstEnum(val=8) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 123[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 126[21]: [128] ConvIntFromNull() -> integer var=t#index[21]:integer
 127[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 130[29]: ConvBoolFromInt(v1: integer) -> boolean
 131[26]: Not(v1: boolean) -> boolean
 132[26]: GotoFalseWord(jump=143, if_false: boolean)
 135[25]: ConstInt(val=0) -> integer
 140[29]: GotoWord(jump=152)
 143[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 146[29]: ConstInt(val=1) -> integer
 151[33]: AddInt(v1: integer, v2: integer) -> integer
 152[29]: PutInt(var[21], value: integer)
 155[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 158[29]: ConstInt(val=20) -> integer
 163[33]: GeInt(v1: integer, v2: integer) -> boolean
 164[26]: GotoFalseWord(jump=170, if_false: boolean)
 167[25]: GotoWord(jump=335)
 170[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 173[29]: [129] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 176[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 179[45]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 182[57]: GetInt(v1: ref(reference), fld=12) -> integer
 185[49]: TextCharacter(v1: text, v2: integer) -> character
 186[33]: PutCharacter(var[17], value: character)
 189[29]: [130] VarCharacter(var[17]) -> character var=l[17]:character
 192[33]: ConvIntFromCharacter(v1: character) -> integer
 193[33]: ConstInt(val=39) -> integer
 198[37]: ConvIntFromCharacter(v1: character) -> integer
 199[37]: EqInt(v1: integer, v2: integer) -> boolean
 200[30]: GotoFalseWord(jump=233, if_false: boolean)
 203[29]: [131] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 206[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 209[53]: GetInt(v1: ref(reference), fld=12) -> integer
 212[45]: ConstInt(val=1) -> integer
 217[49]: AddInt(v1: integer, v2: integer) -> integer
 218[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 221[29]: [132] Return(ret=12, value=0, discard=29)
 227[29]: Return(ret=12, value=0, discard=29)
 233[29]: [134] VarCharacter(var[17]) -> character var=l[17]:character
 236[33]: ConvIntFromCharacter(v1: character) -> integer
 237[33]: ConstInt(val=92) -> integer
 242[37]: ConvIntFromCharacter(v1: character) -> integer
 243[37]: EqInt(v1: integer, v2: integer) -> boolean
 244[30]: GotoFalseWord(jump=310, if_false: boolean)
 247[29]: [135] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 250[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 253[53]: GetInt(v1: ref(reference), fld=12) -> integer
 256[45]: ConstInt(val=1) -> integer
 261[49]: AddInt(v1: integer, v2: integer) -> integer
 262[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 265[29]: [136] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 268[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 271[45]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 274[57]: GetInt(v1: ref(reference), fld=12) -> integer
 277[49]: TextCharacter(v1: text, v2: integer) -> character
 278[33]: ConvIntFromCharacter(v1: character) -> integer
 279[33]: ConstInt(val=39) -> integer
 284[37]: ConvIntFromCharacter(v1: character) -> integer
 285[37]: EqInt(v1: integer, v2: integer) -> boolean
 286[30]: GotoFalseWord(jump=307, if_false: boolean)
 289[29]: [137] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 292[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 295[53]: GetInt(v1: ref(reference), fld=12) -> integer
 298[45]: ConstInt(val=1) -> integer
 303[49]: AddInt(v1: integer, v2: integer) -> integer
 304[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 307[29]: GotoWord(jump=328)
 310[29]: [140] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 313[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 316[53]: GetInt(v1: ref(reference), fld=12) -> integer
 319[45]: ConstInt(val=1) -> integer
 324[49]: AddInt(v1: integer, v2: integer) -> integer
 325[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 328[29]: FreeStack(value=0, discard=4)
 332[25]: GotoWord(jump=127)
 335[25]: FreeStack(value=0, discard=4)
 339[21]: GotoWord(jump=671)
 342[21]: VarCharacter(var[17]) -> character var=l[17]:character
 345[25]: ConvIntFromCharacter(v1: character) -> integer
 346[25]: ConstInt(val=34) -> integer
 351[29]: ConvIntFromCharacter(v1: character) -> integer
 352[29]: EqInt(v1: integer, v2: integer) -> boolean
 353[22]: GotoFalseWord(jump=635, if_false: boolean)
 356[21]: [144] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 359[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 362[45]: GetInt(v1: ref(reference), fld=12) -> integer
 365[37]: ConstInt(val=1) -> integer
 370[41]: AddInt(v1: integer, v2: integer) -> integer
 371[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 374[21]: [145] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 377[33]: ConstEnum(val=6) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 379[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 382[21]: [146] ConvIntFromNull() -> integer var=t#index[21]:integer
 383[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 386[29]: ConvBoolFromInt(v1: integer) -> boolean
 387[26]: Not(v1: boolean) -> boolean
 388[26]: GotoFalseWord(jump=399, if_false: boolean)
 391[25]: ConstInt(val=0) -> integer
 396[29]: GotoWord(jump=408)
 399[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 402[29]: ConstInt(val=1) -> integer
 407[33]: AddInt(v1: integer, v2: integer) -> integer
 408[29]: PutInt(var[21], value: integer)
 411[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 414[29]: ConstInt(val=60000) -> integer
 419[33]: GeInt(v1: integer, v2: integer) -> boolean
 420[26]: GotoFalseWord(jump=426, if_false: boolean)
 423[25]: GotoWord(jump=616)
 426[25]: VarInt(var[21]) -> integer var=t#index[21]:integer
 429[29]: [147] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 432[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 435[45]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 438[57]: GetInt(v1: ref(reference), fld=12) -> integer
 441[49]: TextCharacter(v1: text, v2: integer) -> character
 442[33]: PutCharacter(var[17], value: character)
 445[29]: [148] VarCharacter(var[17]) -> character var=l[17]:character
 448[33]: ConvIntFromCharacter(v1: character) -> integer
 449[33]: ConstInt(val=34) -> integer
 454[37]: ConvIntFromCharacter(v1: character) -> integer
 455[37]: EqInt(v1: integer, v2: integer) -> boolean
 456[30]: GotoFalseWord(jump=489, if_false: boolean)
 459[29]: [149] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 462[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 465[53]: GetInt(v1: ref(reference), fld=12) -> integer
 468[45]: ConstInt(val=1) -> integer
 473[49]: AddInt(v1: integer, v2: integer) -> integer
 474[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 477[29]: [150] Return(ret=12, value=0, discard=29)
 483[29]: Return(ret=12, value=0, discard=29)
 489[29]: [152] VarCharacter(var[17]) -> character var=l[17]:character
 492[33]: ConvIntFromCharacter(v1: character) -> integer
 493[33]: ConstInt(val=92) -> integer
 498[37]: ConvIntFromCharacter(v1: character) -> integer
 499[37]: EqInt(v1: integer, v2: integer) -> boolean
 500[30]: GotoFalseWord(jump=591, if_false: boolean)
 503[29]: [153] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 506[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 509[53]: GetInt(v1: ref(reference), fld=12) -> integer
 512[45]: ConstInt(val=1) -> integer
 517[49]: AddInt(v1: integer, v2: integer) -> integer
 518[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 521[29]: [154] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 524[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 527[45]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 530[57]: GetInt(v1: ref(reference), fld=12) -> integer
 533[49]: TextCharacter(v1: text, v2: integer) -> character
 534[33]: [155] VarCharacter(var[29]) -> character var=n[29]:character
 537[37]: ConvIntFromCharacter(v1: character) -> integer
 538[37]: ConstInt(val=34) -> integer
 543[41]: ConvIntFromCharacter(v1: character) -> integer
 544[41]: EqInt(v1: integer, v2: integer) -> boolean
 545[34]: GotoFalseWord(jump=552, if_false: boolean)
 548[33]: ConstTrue() -> boolean
 549[34]: GotoWord(jump=563)
 552[33]: VarCharacter(var[29]) -> character var=n[29]:character
 555[37]: ConvIntFromCharacter(v1: character) -> integer
 556[37]: ConstInt(val=10) -> integer
 561[41]: ConvIntFromCharacter(v1: character) -> integer
 562[41]: EqInt(v1: integer, v2: integer) -> boolean
 563[34]: GotoFalseWord(jump=584, if_false: boolean)
 566[33]: [156] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 569[45]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 572[57]: GetInt(v1: ref(reference), fld=12) -> integer
 575[49]: ConstInt(val=1) -> integer
 580[53]: AddInt(v1: integer, v2: integer) -> integer
 581[49]: SetInt(v1: ref(reference), fld=12, val: integer)
 584[33]: FreeStack(value=0, discard=4)
 588[29]: GotoWord(jump=609)
 591[29]: [159] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 594[41]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 597[53]: GetInt(v1: ref(reference), fld=12) -> integer
 600[45]: ConstInt(val=1) -> integer
 605[49]: AddInt(v1: integer, v2: integer) -> integer
 606[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 609[29]: FreeStack(value=0, discard=4)
 613[25]: GotoWord(jump=383)
 616[25]: FreeStack(value=0, discard=4)
 620[21]: [162] Return(ret=12, value=0, discard=21)
 626[21]: Return(ret=12, value=0, discard=21)
 632[21]: GotoWord(jump=671)
 635[21]: VarCharacter(var[17]) -> character var=l[17]:character
 638[25]: ConvIntFromCharacter(v1: character) -> integer
 639[25]: ConstInt(val=45) -> integer
 644[29]: ConvIntFromCharacter(v1: character) -> integer
 645[29]: EqInt(v1: integer, v2: integer) -> boolean
 646[22]: GotoFalseWord(jump=671, if_false: boolean)
 649[21]: [164] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 652[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 655[45]: GetInt(v1: ref(reference), fld=12) -> integer
 658[37]: ConstInt(val=1) -> integer
 663[41]: AddInt(v1: integer, v2: integer) -> integer
 664[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 667[21]: [165] ConstTrue() -> boolean var=negative[16]:boolean
 668[22]: PutBool(var=6, value: boolean)
 671[21]: [167] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 674[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 677[37]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 680[49]: GetInt(v1: ref(reference), fld=12) -> integer
 683[41]: TextCharacter(v1: text, v2: integer) -> character
 684[25]: ConvIntFromCharacter(v1: character) -> integer
 685[25]: ConstInt(val=48) -> integer
 690[29]: ConvIntFromCharacter(v1: character) -> integer
 691[29]: GeInt(v1: integer, v2: integer) -> boolean
 692[22]: GotoFalseWord(jump=719, if_false: boolean)
 695[21]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 698[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 701[37]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 704[49]: GetInt(v1: ref(reference), fld=12) -> integer
 707[41]: TextCharacter(v1: text, v2: integer) -> character
 708[25]: ConvIntFromCharacter(v1: character) -> integer
 709[25]: ConstInt(val=57) -> integer
 714[29]: ConvIntFromCharacter(v1: character) -> integer
 715[29]: LeInt(v1: integer, v2: integer) -> boolean
 716[22]: GotoWord(jump=720)
 719[21]: ConstFalse() -> boolean
 720[22]: GotoFalseWord(jump=1028, if_false: boolean)
 723[21]: [168] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 726[33]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 728[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 731[21]: [169] ConvIntFromNull() -> integer var=t#index[21]:integer
 732[25]: PutInt(var[21], value: integer)
 735[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 738[25]: ConvBoolFromInt(v1: integer) -> boolean
 739[22]: Not(v1: boolean) -> boolean
 740[22]: GotoFalseWord(jump=751, if_false: boolean)
 743[21]: ConstInt(val=0) -> integer
 748[25]: GotoWord(jump=760)
 751[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 754[25]: ConstInt(val=1) -> integer
 759[29]: AddInt(v1: integer, v2: integer) -> integer
 760[25]: PutInt(var[21], value: integer)
 763[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 766[25]: ConstInt(val=30) -> integer
 771[29]: GeInt(v1: integer, v2: integer) -> boolean
 772[22]: GotoFalseWord(jump=778, if_false: boolean)
 775[21]: GotoWord(jump=1013)
 778[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
 781[25]: PutInt(var[25], value: integer)
 784[21]: [170] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 787[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 790[37]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 793[49]: GetInt(v1: ref(reference), fld=12) -> integer
 796[41]: TextCharacter(v1: text, v2: integer) -> character
 797[25]: PutCharacter(var[17], value: character)
 800[21]: [171] VarCharacter(var[17]) -> character var=l[17]:character
 803[25]: ConvIntFromCharacter(v1: character) -> integer
 804[25]: ConstInt(val=46) -> integer
 809[29]: ConvIntFromCharacter(v1: character) -> integer
 810[29]: EqInt(v1: integer, v2: integer) -> boolean
 811[22]: GotoFalseWord(jump=818, if_false: boolean)
 814[21]: ConstTrue() -> boolean
 815[22]: GotoWord(jump=829)
 818[21]: VarCharacter(var[17]) -> character var=l[17]:character
 821[25]: ConvIntFromCharacter(v1: character) -> integer
 822[25]: ConstInt(val=101) -> integer
 827[29]: ConvIntFromCharacter(v1: character) -> integer
 828[29]: EqInt(v1: integer, v2: integer) -> boolean
 829[22]: GotoFalseWord(jump=836, if_false: boolean)
 832[21]: ConstTrue() -> boolean
 833[22]: GotoWord(jump=847)
 836[21]: VarCharacter(var[17]) -> character var=l[17]:character
 839[25]: ConvIntFromCharacter(v1: character) -> integer
 840[25]: ConstInt(val=45) -> integer
 845[29]: ConvIntFromCharacter(v1: character) -> integer
 846[29]: EqInt(v1: integer, v2: integer) -> boolean
 847[22]: GotoFalseWord(jump=861, if_false: boolean)
 850[21]: [172] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 853[33]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 855[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 858[21]: GotoWord(jump=992)
 861[21]: VarCharacter(var[17]) -> character var=l[17]:character
 864[25]: ConvIntFromCharacter(v1: character) -> integer
 865[25]: ConstInt(val=108) -> integer
 870[29]: ConvIntFromCharacter(v1: character) -> integer
 871[29]: EqInt(v1: integer, v2: integer) -> boolean
 872[22]: GotoFalseWord(jump=886, if_false: boolean)
 875[21]: [174] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 878[33]: ConstEnum(val=5) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
 880[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 883[21]: GotoWord(jump=992)
 886[21]: VarCharacter(var[17]) -> character var=l[17]:character
 889[25]: ConvIntFromCharacter(v1: character) -> integer
 890[25]: ConstInt(val=120) -> integer
 895[29]: ConvIntFromCharacter(v1: character) -> integer
 896[29]: EqInt(v1: integer, v2: integer) -> boolean
 897[22]: GotoFalseWord(jump=904, if_false: boolean)
 900[21]: ConstTrue() -> boolean
 901[22]: GotoWord(jump=915)
 904[21]: VarCharacter(var[17]) -> character var=l[17]:character
 907[25]: ConvIntFromCharacter(v1: character) -> integer
 908[25]: ConstInt(val=111) -> integer
 913[29]: ConvIntFromCharacter(v1: character) -> integer
 914[29]: EqInt(v1: integer, v2: integer) -> boolean
 915[22]: GotoFalseWord(jump=922, if_false: boolean)
 918[21]: ConstTrue() -> boolean
 919[22]: GotoWord(jump=933)
 922[21]: VarCharacter(var[17]) -> character var=l[17]:character
 925[25]: ConvIntFromCharacter(v1: character) -> integer
 926[25]: ConstInt(val=98) -> integer
 931[29]: ConvIntFromCharacter(v1: character) -> integer
 932[29]: EqInt(v1: integer, v2: integer) -> boolean
 933[22]: GotoFalseWord(jump=939, if_false: boolean)
 936[21]: GotoWord(jump=992)
 939[21]: VarCharacter(var[17]) -> character var=l[17]:character
 942[25]: ConvIntFromCharacter(v1: character) -> integer
 943[25]: ConstInt(val=95) -> integer
 948[29]: ConvIntFromCharacter(v1: character) -> integer
 949[29]: NeInt(v1: integer, v2: integer) -> boolean
 950[22]: GotoFalseWord(jump=985, if_false: boolean)
 953[21]: VarCharacter(var[17]) -> character var=l[17]:character
 956[25]: ConvIntFromCharacter(v1: character) -> integer
 957[25]: ConstInt(val=48) -> integer
 962[29]: ConvIntFromCharacter(v1: character) -> integer
 963[29]: LtInt(v1: integer, v2: integer) -> boolean
 964[22]: GotoFalseWord(jump=971, if_false: boolean)
 967[21]: ConstTrue() -> boolean
 968[22]: GotoWord(jump=982)
 971[21]: VarCharacter(var[17]) -> character var=l[17]:character
 974[25]: ConvIntFromCharacter(v1: character) -> integer
 975[25]: ConstInt(val=57) -> integer
 980[29]: ConvIntFromCharacter(v1: character) -> integer
 981[29]: GtInt(v1: integer, v2: integer) -> boolean
 982[22]: GotoWord(jump=986)
 985[21]: ConstFalse() -> boolean
 986[22]: GotoFalseWord(jump=992, if_false: boolean)
 989[21]: [177] GotoWord(jump=1013)
 992[21]: [179] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 995[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 998[45]: GetInt(v1: ref(reference), fld=12) -> integer
1001[37]: ConstInt(val=1) -> integer
1006[41]: AddInt(v1: integer, v2: integer) -> integer
1007[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1010[21]: GotoWord(jump=735)
1013[21]: [181] Return(ret=12, value=0, discard=21)
1019[21]: Return(ret=12, value=0, discard=21)
1025[21]: GotoWord(jump=1052)
1028[21]: VarBool(var[16]) -> boolean var=negative[16]:boolean
1031[22]: GotoFalseWord(jump=1052, if_false: boolean)
1034[21]: [183] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1037[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1040[45]: GetInt(v1: ref(reference), fld=12) -> integer
1043[37]: ConstInt(val=1) -> integer
1048[41]: MinInt(v1: integer, v2: integer) -> integer
1049[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1052[21]: [185] VarCharacter(var[17]) -> character var=l[17]:character
1055[25]: StaticCall(_tp_character_is_alphabetic)
1058[22]: GotoFalseWord(jump=1184, if_false: boolean)
1061[21]: [186] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1064[33]: ConstEnum(val=9) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
1066[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
1069[21]: [187] ConvIntFromNull() -> integer var=t#index[21]:integer
1070[25]: PutInt(var[21], value: integer)
1073[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
1076[25]: ConvBoolFromInt(v1: integer) -> boolean
1077[22]: Not(v1: boolean) -> boolean
1078[22]: GotoFalseWord(jump=1089, if_false: boolean)
1081[21]: ConstInt(val=0) -> integer
1086[25]: GotoWord(jump=1098)
1089[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
1092[25]: ConstInt(val=1) -> integer
1097[29]: AddInt(v1: integer, v2: integer) -> integer
1098[25]: PutInt(var[21], value: integer)
1101[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
1104[25]: ConstInt(val=300) -> integer
1109[29]: GeInt(v1: integer, v2: integer) -> boolean
1110[22]: GotoFalseWord(jump=1116, if_false: boolean)
1113[21]: GotoWord(jump=1172)
1116[21]: VarInt(var[21]) -> integer var=t#index[21]:integer
1119[25]: PutInt(var[25], value: integer)
1122[21]: [188] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1125[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
1128[37]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1131[49]: GetInt(v1: ref(reference), fld=12) -> integer
1134[41]: TextCharacter(v1: text, v2: integer) -> character
1135[25]: PutCharacter(var[17], value: character)
1138[21]: [189] VarCharacter(var[17]) -> character var=l[17]:character
1141[25]: StaticCall(_tp_character_is_alphanumeric)
1144[22]: Not(v1: boolean) -> boolean
1145[22]: GotoFalseWord(jump=1151, if_false: boolean)
1148[21]: [190] GotoWord(jump=1172)
1151[21]: [192] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1154[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1157[45]: GetInt(v1: ref(reference), fld=12) -> integer
1160[37]: ConstInt(val=1) -> integer
1165[41]: AddInt(v1: integer, v2: integer) -> integer
1166[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1169[21]: GotoWord(jump=1073)
1172[21]: [194] Return(ret=12, value=0, discard=21)
1178[21]: Return(ret=12, value=0, discard=21)
1184[21]: [197] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1187[33]: ConstEnum(val=10) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
1189[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
1192[21]: [198] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1195[33]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1198[33]: VarCharacter(var[17]) -> character var=l[17]:character
1201[37]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1205[33]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1208[33]: Iterate(data: ref(reference), on=130, arg=8, keys=[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], from_key=0, till_key=0) -> long
1221[29]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1224[41]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1227[41]: VarCharacter(var[17]) -> character var=l[17]:character
1230[45]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1234[41]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1237[41]: Step(state_var=20, data: ref(reference), on=130, arg=8) -> ref(reference)
1243[41]: VarRef(var[29]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[29]:ref(Possible)["self"]
1246[53]: ConvBoolFromRef(val: ref(reference)) -> boolean
1247[42]: Not(v1: boolean) -> boolean
1248[42]: GotoFalseWord(jump=1258, if_false: boolean)
1251[41]: FreeStack(value=0, discard=12)
1255[29]: GotoWord(jump=1357)
1258[41]: [199] Text() var=tok[41]:text["pt"]
1259[65]: VarRef(var[29]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[29]:ref(Possible)["self"]
1262[77]: GetText(v1: ref(reference), fld=4) -> text["self"]
1265[81]: AppendText(var[41], v1: text)
1268[65]: [200] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1271[77]: GetText(v1: ref(reference), fld=8) -> text["self"]
1274[81]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1277[93]: GetInt(v1: ref(reference), fld=12) -> integer
1280[85]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1283[97]: GetInt(v1: ref(reference), fld=12) -> integer
1286[89]: VarText(var[41]) -> text var=tok[41]:text["pt"]
1289[105]: Call(size=0, fn=_tp_text_len)
1296[93]: AddInt(v1: integer, v2: integer) -> integer
1297[89]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
1298[81]: VarText(var[41]) -> text var=tok[41]:text["pt"]
1301[97]: EqText(v1: text, v2: text) -> boolean
1302[66]: GotoFalseWord(jump=1343, if_false: boolean)
1305[65]: [201] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1308[77]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1311[89]: GetInt(v1: ref(reference), fld=12) -> integer
1314[81]: VarText(var[41]) -> text var=tok[41]:text["pt"]
1317[97]: Call(size=0, fn=_tp_text_len)
1324[85]: AddInt(v1: integer, v2: integer) -> integer
1325[81]: SetInt(v1: ref(reference), fld=12, val: integer)
1328[65]: [202] FreeText(var[41])
1331[65]: Return(ret=12, value=0, discard=65)
1337[65]: Return(ret=12, value=0, discard=65)
1343[65]: FreeText(var[41])
1346[65]: FreeStack(value=0, discard=24)
1350[41]: FreeStack(value=0, discard=12)
1354[29]: GotoWord(jump=1221)
1357[29]: FreeStack(value=0, discard=8)
1361[21]: [205] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1364[33]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
1367[45]: GetInt(v1: ref(reference), fld=12) -> integer
1370[37]: ConstInt(val=1) -> integer
1375[41]: AddInt(v1: integer, v2: integer) -> integer
1376[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1379[21]: Return(ret=12, value=0, discard=21)

fn _tp_Lexer_parse(self:Lexer, filename:text) {#block(1):void
  __ref_1(1):ref(File) = null;
  __work_1(1):text = "";
  [210] v(1):integer = _tp_text_rfind(filename(0), "/");
  [211] OpSetText(self(0), 4i32, if OpConvBoolFromInt(v(1)) {#block(2):text["filename"]
    [212] OpGetTextSub(filename(0), OpAddInt(v(1), 1i32), 2147483647i32);
  }#block(2):text["filename"] else {#block(3):text["filename"]
    [214] filename(0);
  }#block(3):text["filename"]);
  [216] OpSetText(self(0), 8i32, _tp_File_content(file(filename(0), __ref_1(1)), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]));
  [217] OpSetInt(self(0), 12i32, 0i32);
  [218] OpSetInt(self(0), 24i32, 0i32);
  [219] OpSetInt(self(0), 16i32, 1i32);
  [220] OpSetInt(self(0), 20i32, 1i32);
  [221] _tp_Lexer_scan(self(0));
  OpFreeRef(__ref_1(1));
  OpFreeText(__work_1(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse(self: ref(Lexer)[0], filename: text[12])
   0[28]: return-address
   0[32]: ConvRefFromNull() -> ref(reference) var=__ref_1[32]:ref(File)
   1[44]: Text() var=__work_1[44]:text
   2[68]: [210] ArgText(var[12]) -> text var=filename[12]:text
   5[84]: ConstText(_value="/") -> text
   8[100]: StaticCall(_tp_text_rfind)
  11[72]: [211] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  14[84]: VarInt(var[68]) -> integer var=v[68]:integer
  17[88]: ConvBoolFromInt(v1: integer) -> boolean
  18[85]: GotoFalseWord(jump=42, if_false: boolean)
  21[84]: [212] ArgText(var[12]) -> text var=filename[12]:text
  24[100]: VarInt(var[68]) -> integer var=v[68]:integer
  27[104]: ConstInt(val=1) -> integer
  32[108]: AddInt(v1: integer, v2: integer) -> integer
  33[104]: ConstInt(val=2147483647) -> integer
  38[108]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  39[100]: GotoWord(jump=45)
  42[84]: [214] ArgText(var[12]) -> text var=filename[12]:text
  45[100]: SetText(v1: ref(reference), fld=4, val: text)
  48[72]: [216] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  51[84]: ArgText(var[12]) -> text var=filename[12]:text
  54[100]: VarRef(var[32]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[32]:ref(File)
  57[112]: Call(size=0, fn=file)
  64[96]: CreateRef(var[44]) -> ref(reference)
  67[108]: Call(size=0, fn=_tp_File_content)
  74[100]: SetText(v1: ref(reference), fld=8, val: text)
  77[72]: [217] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  80[84]: ConstInt(val=0) -> integer
  85[88]: SetInt(v1: ref(reference), fld=12, val: integer)
  88[72]: [218] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  91[84]: ConstInt(val=0) -> integer
  96[88]: SetInt(v1: ref(reference), fld=24, val: integer)
  99[72]: [219] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 102[84]: ConstInt(val=1) -> integer
 107[88]: SetInt(v1: ref(reference), fld=16, val: integer)
 110[72]: [220] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 113[84]: ConstInt(val=1) -> integer
 118[88]: SetInt(v1: ref(reference), fld=20, val: integer)
 121[72]: [221] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 124[84]: Call(size=0, fn=_tp_Lexer_scan)
 131[72]: VarRef(var[32]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[32]:ref(File)
 134[84]: FreeRef(v1: ref(reference))
 135[72]: FreeText(var[44])
 138[72]: Return(ret=28, value=0, discard=72)

fn _tp_Lexer_parse_string(self:Lexer, name:text, content:text) {#block(1):void
  [226] OpSetText(self(0), 4i32, name(0));
  [227] OpSetText(self(0), 8i32, content(0));
  [228] OpSetInt(self(0), 12i32, 0i32);
  [229] OpSetInt(self(0), 24i32, 0i32);
  [230] OpSetInt(self(0), 16i32, 1i32);
  [231] OpSetInt(self(0), 20i32, 1i32);
  [232] _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse_string(self: ref(Lexer)[0], name: text[12], content: text[28])
   0[44]: return-address
   0[48]: [226] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[60]: ArgText(var[12]) -> text var=name[12]:text
   6[76]: SetText(v1: ref(reference), fld=4, val: text)
   9[48]: [227] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  12[60]: ArgText(var[28]) -> text var=content[28]:text
  15[76]: SetText(v1: ref(reference), fld=8, val: text)
  18[48]: [228] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  21[60]: ConstInt(val=0) -> integer
  26[64]: SetInt(v1: ref(reference), fld=12, val: integer)
  29[48]: [229] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  32[60]: ConstInt(val=0) -> integer
  37[64]: SetInt(v1: ref(reference), fld=24, val: integer)
  40[48]: [230] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  43[60]: ConstInt(val=1) -> integer
  48[64]: SetInt(v1: ref(reference), fld=16, val: integer)
  51[48]: [231] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  54[60]: ConstInt(val=1) -> integer
  59[64]: SetInt(v1: ref(reference), fld=20, val: integer)
  62[48]: [232] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  65[60]: Call(size=0, fn=_tp_Lexer_scan)
  72[48]: Return(ret=44, value=0, discard=48)

fn _tp_Lexer_test(self:Lexer, with:text) -> boolean {#block(1):boolean
  [237] OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)), with(0));
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_test(self: ref(Lexer)[0], with: text[12]) -> boolean
   0[28]: return-address
   0[32]: [237] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[44]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[48]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   9[60]: GetInt(v1: ref(reference), fld=24) -> integer
  12[52]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  15[64]: GetInt(v1: ref(reference), fld=12) -> integer
  18[56]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[48]: ArgText(var[12]) -> text var=with[12]:text
  22[64]: EqText(v1: text, v2: text) -> boolean
  23[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_matches(self:Lexer, with:text) -> boolean {#block(1):boolean
  [242] if _tp_Lexer_test(self(0), with(0)) {#block(2):boolean
    [243] _tp_Lexer_scan(self(0));
    [244] true;
  }#block(2):boolean else {#block(3):boolean
    [246] false;
  }#block(3):boolean;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_matches(self: ref(Lexer)[0], with: text[12]) -> boolean
   0[28]: return-address
   0[32]: [242] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[44]: ArgText(var[12]) -> text var=with[12]:text
   6[60]: Call(size=0, fn=_tp_Lexer_test)
  13[33]: GotoFalseWord(jump=30, if_false: boolean)
  16[32]: [243] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  19[44]: Call(size=0, fn=_tp_Lexer_scan)
  26[32]: [244] ConstTrue() -> boolean
  27[33]: GotoWord(jump=31)
  30[32]: [246] ConstFalse() -> boolean
  31[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_peek(self:Lexer) -> text["self"] {#block(1):text["self"]
  [253] OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_peek(self: ref(Lexer)[0]) -> text["self"]
   0[12]: return-address
   0[16]: [253] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   9[44]: GetInt(v1: ref(reference), fld=24) -> integer
  12[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  15[48]: GetInt(v1: ref(reference), fld=12) -> integer
  18[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_position(self:Lexer, __work_1:&text) -> text["__work_1"] {#block(1):text["__work_1"]
  __work_1(0):&text = "";
  [258] {#Formatted string(2):text["__work_1"]
    __work_1(0):&text = "";
    OpFormatRefText(__work_1(0), OpGetText(self(0), 4i32), 0i32, -1i32, 32i32);
    OpAppendRefText(__work_1(0), ":");
    OpFormatRefLong(__work_1(0), OpConvLongFromInt(OpGetInt(self(0), 16i32)), 10i32, 0i32, 32i32, false, false);
    OpAppendRefText(__work_1(0), ":");
    OpFormatRefLong(__work_1(0), OpConvLongFromInt(OpGetInt(self(0), 20i32)), 10i32, 0i32, 32i32, false, false);
    __work_1(0);
  }#Formatted string(2):text["__work_1"];
}#block(1):text["__work_1"]

byte-code for lib/lexer.lav:_tp_Lexer_position(self: ref(Lexer)[0], __work_1: &text[12]) -> text["__work_1"]
   0[24]: return-address
   0[28]: [258] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: GetText(v1: ref(reference), fld=4) -> text["self"]
   6[44]: ConstInt(val=0) -> integer
  11[48]: FormatRefText(var[12], val: text, width: integer, dir=-1, token=32)
  16[28]: ConstText(_value=":") -> text
  19[44]: AppendRefText(var[12], v1: text)
  22[28]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  25[40]: GetInt(v1: ref(reference), fld=16) -> integer
  28[32]: ConvLongFromInt(v1: integer) -> long
  29[36]: ConstInt(val=0) -> integer
  34[40]: FormatRefLong(var[12], val: long, radix=10, width: integer, token=32, plus=false, note=false)
  41[28]: ConstText(_value=":") -> text
  44[44]: AppendRefText(var[12], v1: text)
  47[28]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  50[40]: GetInt(v1: ref(reference), fld=20) -> integer
  53[32]: ConvLongFromInt(v1: integer) -> long
  54[36]: ConstInt(val=0) -> integer
  59[40]: FormatRefLong(var[12], val: long, radix=10, width: integer, token=32, plus=false, note=false)
  66[28]: VarRef(var[12]) -> ref(reference) var=__work_1[12]:&text
  69[40]: GetRefText(r: ref(reference)) -> text["self"]
  70[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_identifier(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  [263] result(0):&text = OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
  [264] if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, result(0))) {#if(2):&text["result"]
    OpConvTextFromNull();
  }#if(2):&text["result"] else {#block(3):&text["result"]
    [267] _tp_Lexer_scan(self(0));
    [268] result(0);
  }#block(3):&text["result"];
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_identifier(self: ref(Lexer)[0], result: &text[12]) -> text["result"]
   0[24]: return-address
   0[28]: [263] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[44]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   9[56]: GetInt(v1: ref(reference), fld=24) -> integer
  12[48]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  15[60]: GetInt(v1: ref(reference), fld=12) -> integer
  18[52]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[44]: AppendRefText(var[12], v1: text)
  22[28]: [264] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  25[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
  28[40]: VarRef(var[12]) -> ref(reference) var=result[12]:&text
  31[52]: GetRefText(r: ref(reference)) -> text["self"]
  32[56]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
  36[40]: ConvBoolFromRef(val: ref(reference)) -> boolean
  37[29]: GotoFalseWord(jump=48, if_false: boolean)
  40[28]: ConvTextFromNull() -> text
  41[44]: FreeStack(value=12, discard=16)
  45[40]: GotoWord(jump=66)
  48[28]: [267] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  51[40]: Call(size=0, fn=_tp_Lexer_scan)
  58[28]: [268] VarRef(var[12]) -> ref(reference) var=result[12]:&text
  61[40]: GetRefText(r: ref(reference)) -> text["self"]
  62[44]: FreeStack(value=12, discard=16)
  66[40]: Return(ret=24, value=16, discard=40) type=text[4]:Base[5]

fn _tp_Lexer_int(self:Lexer) -> integer {#block(1):integer
  [274] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(2u8(17))) {#block(2):void
    [275] return OpConvIntFromNull();
  }#block(2):void else null;
  [277] result(1):integer = OpCastIntFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [278] if OpConvBoolFromInt(result(1)) {#block(3):integer
    [279] _tp_Lexer_scan(self(0));
    [280] result(1);
  }#block(3):integer else {#block(4):integer
    [282] OpConvIntFromNull();
  }#block(4):integer;
}#block(1):integer

byte-code for lib/lexer.lav:_tp_Lexer_int(self: ref(Lexer)[0]) -> integer
   0[12]: return-address
   0[16]: [274] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [275] ConvIntFromNull() -> integer
  15[20]: Return(ret=12, value=4, discard=20)
  21[20]: ConvIntFromNull() -> integer
  22[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]
  28[24]: FreeStack(value=0, discard=8)
  32[16]: [277] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastIntFromText(v1: text) -> integer
  52[20]: [278] VarInt(var[16]) -> integer var=result[16]:integer
  55[24]: ConvBoolFromInt(v1: integer) -> boolean
  56[21]: GotoFalseWord(jump=75, if_false: boolean)
  59[20]: [279] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  62[32]: Call(size=0, fn=_tp_Lexer_scan)
  69[20]: [280] VarInt(var[16]) -> integer var=result[16]:integer
  72[24]: GotoWord(jump=76)
  75[20]: [282] ConvIntFromNull() -> integer
  76[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]

fn _tp_Lexer_long_int(self:Lexer) -> long {#block(1):long
  [288] if if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(5u8(17))) OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(2u8(17))) else false {#block(2):void
    [289] return OpConvLongFromNull();
  }#block(2):void else null;
  [291] to(1):integer = OpGetInt(self(0), 12i32);
  [292] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpMinInt(to(1), 1i32))), OpConvIntFromCharacter(108i32)) {#block(3):void
    [293] to(1):integer = OpMinInt(to(1), 1i32);
  }#block(3):void else null;
  [295] result(1):long = OpCastLongFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), to(1)));
  [296] if OpConvBoolFromLong(result(1)) {#block(4):long
    [297] _tp_Lexer_scan(self(0));
    [298] result(1);
  }#block(4):long else {#block(5):long
    [300] OpConvLongFromNull();
  }#block(5):long;
}#block(1):long

byte-code for lib/lexer.lav:_tp_Lexer_long_int(self: ref(Lexer)[0]) -> long
   0[12]: return-address
   0[16]: [288] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=5) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=28, if_false: boolean)
  14[16]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  17[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
  20[17]: ConvIntFromEnum(v1: boolean) -> integer
  21[20]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
  23[21]: ConvIntFromEnum(v1: boolean) -> integer
  24[24]: NeInt(v1: integer, v2: integer) -> boolean
  25[17]: GotoWord(jump=29)
  28[16]: ConstFalse() -> boolean
  29[17]: GotoFalseWord(jump=50, if_false: boolean)
  32[16]: [289] ConvLongFromNull() -> long
  33[24]: Return(ret=12, value=8, discard=24)
  39[24]: ConvLongFromNull() -> long
  40[32]: Return(ret=12, value=8, discard=32) type=long[8]:Base[1]
  46[32]: FreeStack(value=0, discard=16)
  50[16]: [291] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  53[28]: GetInt(v1: ref(reference), fld=12) -> integer
  56[20]: [292] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  59[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
  62[36]: VarInt(var[16]) -> integer var=to[16]:integer
  65[40]: ConstInt(val=1) -> integer
  70[44]: MinInt(v1: integer, v2: integer) -> integer
  71[40]: TextCharacter(v1: text, v2: integer) -> character
  72[24]: ConvIntFromCharacter(v1: character) -> integer
  73[24]: ConstInt(val=108) -> integer
  78[28]: ConvIntFromCharacter(v1: character) -> integer
  79[28]: EqInt(v1: integer, v2: integer) -> boolean
  80[21]: GotoFalseWord(jump=95, if_false: boolean)
  83[20]: [293] VarInt(var[16]) -> integer var=to[16]:integer
  86[24]: ConstInt(val=1) -> integer
  91[28]: MinInt(v1: integer, v2: integer) -> integer
  92[24]: PutInt(var[16], value: integer)
  95[20]: [295] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  98[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
 101[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 104[48]: GetInt(v1: ref(reference), fld=24) -> integer
 107[40]: VarInt(var[16]) -> integer var=to[16]:integer
 110[44]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 111[36]: CastLongFromText(v1: text) -> long
 112[28]: [296] VarLong(var[20]) -> long var=result[20]:long
 115[36]: ConvBoolFromLong(v1: long) -> boolean
 116[29]: GotoFalseWord(jump=135, if_false: boolean)
 119[28]: [297] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 122[40]: Call(size=0, fn=_tp_Lexer_scan)
 129[28]: [298] VarLong(var[20]) -> long var=result[20]:long
 132[36]: GotoWord(jump=136)
 135[28]: [300] ConvLongFromNull() -> long
 136[36]: Return(ret=12, value=8, discard=36) type=long[8]:Base[1]

fn _tp_Lexer_long_float(self:Lexer) -> float {#block(1):float
  [306] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(3u8(17))) {#block(2):void
    [307] return OpConvFloatFromNull();
  }#block(2):void else null;
  [309] result(1):float = OpCastFloatFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [310] if OpConvBoolFromFloat(result(1)) {#block(3):float
    [311] _tp_Lexer_scan(self(0));
    [312] result(1);
  }#block(3):float else {#block(4):float
    [314] OpConvFloatFromNull();
  }#block(4):float;
}#block(1):float

byte-code for lib/lexer.lav:_tp_Lexer_long_float(self: ref(Lexer)[0]) -> float
   0[12]: return-address
   0[16]: [306] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [307] ConvFloatFromNull() -> float
  15[24]: Return(ret=12, value=8, discard=24)
  21[24]: ConvFloatFromNull() -> float
  22[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]
  28[32]: FreeStack(value=0, discard=16)
  32[16]: [309] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastFloatFromText(v1: text) -> float
  52[24]: [310] VarFloat(var[16]) -> float var=result[16]:float
  55[32]: ConvBoolFromFloat(v1: float) -> boolean
  56[25]: GotoFalseWord(jump=75, if_false: boolean)
  59[24]: [311] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  62[36]: Call(size=0, fn=_tp_Lexer_scan)
  69[24]: [312] VarFloat(var[16]) -> float var=result[16]:float
  72[32]: GotoWord(jump=76)
  75[24]: [314] ConvFloatFromNull() -> float
  76[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]

fn _tp_Lexer_single_float(self:Lexer) -> single {#block(1):single
  [320] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(3u8(17))) {#block(2):void
    [321] return OpConvSingleFromNull();
  }#block(2):void else null;
  [323] result(1):single = OpCastSingleFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [324] if OpConvBoolFromSingle(result(1)) {#block(3):single
    [325] _tp_Lexer_scan(self(0));
    [326] result(1);
  }#block(3):single else {#block(4):single
    [328] OpConvSingleFromNull();
  }#block(4):single;
}#block(1):single

byte-code for lib/lexer.lav:_tp_Lexer_single_float(self: ref(Lexer)[0]) -> single
   0[12]: return-address
   0[16]: [320] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [321] ConvSingleFromNull() -> single
  15[20]: Return(ret=12, value=4, discard=20)
  21[20]: ConvSingleFromNull() -> single
  22[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]
  28[24]: FreeStack(value=0, discard=8)
  32[16]: [323] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastSingleFromText(v1: text) -> single
  52[20]: [324] VarSingle(var[16]) -> single var=result[16]:single
  55[24]: ConvBoolFromSingle(v1: single) -> boolean
  56[21]: GotoFalseWord(jump=75, if_false: boolean)
  59[20]: [325] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  62[32]: Call(size=0, fn=_tp_Lexer_scan)
  69[20]: [326] VarSingle(var[16]) -> single var=result[16]:single
  72[24]: GotoWord(jump=76)
  75[20]: [328] ConvSingleFromNull() -> single
  76[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]

fn _tp_Lexer_is_finished(self:Lexer) -> boolean {#block(1):boolean
  [333] OpEqInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(12u8(17)));
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_is_finished(self: ref(Lexer)[0]) -> boolean
   0[12]: return-address
   0[16]: [333] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=12) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: EqInt(v1: integer, v2: integer) -> boolean
  11[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_escaped(self:Lexer, i:integer) -> character {#block(1):character
  [337] c(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32));
  [338] if if if if if if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(39i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(92i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(10i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(123i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(125i32)) {#block(2):character
    [339] c(1);
  }#block(2):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(116i32)) {#block(3):character
    [341] 9i32;
  }#block(3):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(114i32)) {#block(4):character
    [343] 13i32;
  }#block(4):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(110i32)) {#block(5):character
    [345] 10i32;
  }#block(5):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(120i32)) {#block(6):character
    [347] total(6):text["total"] = "";
    OpAppendText(total(6), "0");
    OpAppendText(total(6), OpGetTextSub(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32), OpAddInt(i(0), 4i32)));
    [348] nr(6):integer = OpCastIntFromText(total(6));
    [349] OpCastCharacterFromInt(nr(6));
    OpFreeText(total(6));
  }#block(6):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(117i32)) {#block(7):character
    [351] OpCastCharacterFromInt(0i32);
  }#block(7):character else {#block(8):character
    [353] OpCastCharacterFromInt(0i32);
  }#block(8):character;
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_escaped(self: ref(Lexer)[0], i: integer[12]) -> character
   0[16]: return-address
   0[20]: [337] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[36]: VarInt(var[12]) -> integer var=i[12]:integer
   9[40]: ConstInt(val=1) -> integer
  14[44]: AddInt(v1: integer, v2: integer) -> integer
  15[40]: TextCharacter(v1: text, v2: integer) -> character
  16[24]: [338] VarCharacter(var[20]) -> character var=c[20]:character
  19[28]: ConvIntFromCharacter(v1: character) -> integer
  20[28]: ConstInt(val=34) -> integer
  25[32]: ConvIntFromCharacter(v1: character) -> integer
  26[32]: EqInt(v1: integer, v2: integer) -> boolean
  27[25]: GotoFalseWord(jump=34, if_false: boolean)
  30[24]: ConstTrue() -> boolean
  31[25]: GotoWord(jump=45)
  34[24]: VarCharacter(var[20]) -> character var=c[20]:character
  37[28]: ConvIntFromCharacter(v1: character) -> integer
  38[28]: ConstInt(val=39) -> integer
  43[32]: ConvIntFromCharacter(v1: character) -> integer
  44[32]: EqInt(v1: integer, v2: integer) -> boolean
  45[25]: GotoFalseWord(jump=52, if_false: boolean)
  48[24]: ConstTrue() -> boolean
  49[25]: GotoWord(jump=63)
  52[24]: VarCharacter(var[20]) -> character var=c[20]:character
  55[28]: ConvIntFromCharacter(v1: character) -> integer
  56[28]: ConstInt(val=92) -> integer
  61[32]: ConvIntFromCharacter(v1: character) -> integer
  62[32]: EqInt(v1: integer, v2: integer) -> boolean
  63[25]: GotoFalseWord(jump=70, if_false: boolean)
  66[24]: ConstTrue() -> boolean
  67[25]: GotoWord(jump=81)
  70[24]: VarCharacter(var[20]) -> character var=c[20]:character
  73[28]: ConvIntFromCharacter(v1: character) -> integer
  74[28]: ConstInt(val=10) -> integer
  79[32]: ConvIntFromCharacter(v1: character) -> integer
  80[32]: EqInt(v1: integer, v2: integer) -> boolean
  81[25]: GotoFalseWord(jump=88, if_false: boolean)
  84[24]: ConstTrue() -> boolean
  85[25]: GotoWord(jump=99)
  88[24]: VarCharacter(var[20]) -> character var=c[20]:character
  91[28]: ConvIntFromCharacter(v1: character) -> integer
  92[28]: ConstInt(val=123) -> integer
  97[32]: ConvIntFromCharacter(v1: character) -> integer
  98[32]: EqInt(v1: integer, v2: integer) -> boolean
  99[25]: GotoFalseWord(jump=106, if_false: boolean)
 102[24]: ConstTrue() -> boolean
 103[25]: GotoWord(jump=117)
 106[24]: VarCharacter(var[20]) -> character var=c[20]:character
 109[28]: ConvIntFromCharacter(v1: character) -> integer
 110[28]: ConstInt(val=125) -> integer
 115[32]: ConvIntFromCharacter(v1: character) -> integer
 116[32]: EqInt(v1: integer, v2: integer) -> boolean
 117[25]: GotoFalseWord(jump=126, if_false: boolean)
 120[24]: [339] VarCharacter(var[20]) -> character var=c[20]:character
 123[28]: GotoWord(jump=288)
 126[24]: VarCharacter(var[20]) -> character var=c[20]:character
 129[28]: ConvIntFromCharacter(v1: character) -> integer
 130[28]: ConstInt(val=116) -> integer
 135[32]: ConvIntFromCharacter(v1: character) -> integer
 136[32]: EqInt(v1: integer, v2: integer) -> boolean
 137[25]: GotoFalseWord(jump=148, if_false: boolean)
 140[24]: [341] ConstInt(val=9) -> integer
 145[28]: GotoWord(jump=288)
 148[24]: VarCharacter(var[20]) -> character var=c[20]:character
 151[28]: ConvIntFromCharacter(v1: character) -> integer
 152[28]: ConstInt(val=114) -> integer
 157[32]: ConvIntFromCharacter(v1: character) -> integer
 158[32]: EqInt(v1: integer, v2: integer) -> boolean
 159[25]: GotoFalseWord(jump=170, if_false: boolean)
 162[24]: [343] ConstInt(val=13) -> integer
 167[28]: GotoWord(jump=288)
 170[24]: VarCharacter(var[20]) -> character var=c[20]:character
 173[28]: ConvIntFromCharacter(v1: character) -> integer
 174[28]: ConstInt(val=110) -> integer
 179[32]: ConvIntFromCharacter(v1: character) -> integer
 180[32]: EqInt(v1: integer, v2: integer) -> boolean
 181[25]: GotoFalseWord(jump=192, if_false: boolean)
 184[24]: [345] ConstInt(val=10) -> integer
 189[28]: GotoWord(jump=288)
 192[24]: VarCharacter(var[20]) -> character var=c[20]:character
 195[28]: ConvIntFromCharacter(v1: character) -> integer
 196[28]: ConstInt(val=120) -> integer
 201[32]: ConvIntFromCharacter(v1: character) -> integer
 202[32]: EqInt(v1: integer, v2: integer) -> boolean
 203[25]: GotoFalseWord(jump=259, if_false: boolean)
 206[24]: [347] Text() var=total[24]:text["total"]
 207[48]: ConstText(_value="0") -> text
 210[64]: AppendText(var[24], v1: text)
 213[48]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 216[60]: GetText(v1: ref(reference), fld=8) -> text["self"]
 219[64]: VarInt(var[12]) -> integer var=i[12]:integer
 222[68]: ConstInt(val=1) -> integer
 227[72]: AddInt(v1: integer, v2: integer) -> integer
 228[68]: VarInt(var[12]) -> integer var=i[12]:integer
 231[72]: ConstInt(val=4) -> integer
 236[76]: AddInt(v1: integer, v2: integer) -> integer
 237[72]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 238[64]: AppendText(var[24], v1: text)
 241[48]: [348] VarText(var[24]) -> text var=total[24]:text["total"]
 244[64]: CastIntFromText(v1: text) -> integer
 245[52]: [349] VarInt(var[48]) -> integer var=nr[48]:integer
 248[56]: CastCharacterFromInt(v1: integer) -> character
 249[56]: FreeText(var[24])
 252[56]: FreeStack(value=4, discard=32)
 256[28]: GotoWord(jump=288)
 259[24]: VarCharacter(var[20]) -> character var=c[20]:character
 262[28]: ConvIntFromCharacter(v1: character) -> integer
 263[28]: ConstInt(val=117) -> integer
 268[32]: ConvIntFromCharacter(v1: character) -> integer
 269[32]: EqInt(v1: integer, v2: integer) -> boolean
 270[25]: GotoFalseWord(jump=282, if_false: boolean)
 273[24]: [351] ConstInt(val=0) -> integer
 278[28]: CastCharacterFromInt(v1: integer) -> character
 279[28]: GotoWord(jump=288)
 282[24]: [353] ConstInt(val=0) -> integer
 287[28]: CastCharacterFromInt(v1: integer) -> character
 288[28]: Return(ret=16, value=4, discard=28) type=character[4]:Base[6]

fn _tp_Lexer_constant_text(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  [359] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(6u8(17))) {#block(2):void
    [360] return OpConvTextFromNull();
  }#block(2):void else null;
  [362] result(0):&text = "";
  [363] {#For block(3):void
    i#index(3):integer = OpConvIntFromNull();
    loop {#For loop_4
      i(4):integer = {#Iter range(5):integer
        i#index(3):integer = if OpNot(OpConvBoolFromInt(i#index(3))) OpAddInt(OpGetInt(self(0), 24i32), 1i32) else OpAddInt(i#index(3), 1i32);
        if OpGeInt(i#index(3), OpMinInt(OpGetInt(self(0), 12i32), 1i32)) break(0) else null;
        i#index(3);
      }#Iter range(5):integer;
      {#block(6):void
        [364] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), i(4))), OpConvIntFromCharacter(92i32)) {#block(7):void
          [365] OpAppendRefCharacter(result(0), _tp_Lexer_escaped(self(0), i(4)));
        }#block(7):void else {#block(8):void
          [367] OpAppendRefCharacter(result(0), OpTextCharacter(OpGetText(self(0), 8i32), i(4)));
        }#block(8):void;
      }#block(6):void;
    }#For loop_4;
  }#For block(3):void;
  [370] _tp_Lexer_scan(self(0));
  [371] result(0);
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_constant_text(self: ref(Lexer)[0], result: &text[12]) -> text["result"]
   0[24]: return-address
   0[28]: [359] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[29]: ConvIntFromEnum(v1: boolean) -> integer
   7[32]: ConstEnum(val=6) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[33]: ConvIntFromEnum(v1: boolean) -> integer
  10[36]: NeInt(v1: integer, v2: integer) -> boolean
  11[29]: GotoFalseWord(jump=32, if_false: boolean)
  14[28]: [360] ConvTextFromNull() -> text
  15[44]: Return(ret=24, value=16, discard=44)
  21[44]: ConvTextFromNull() -> text
  22[60]: Return(ret=24, value=16, discard=60) type=text[4]:Base[5]
  28[60]: FreeStack(value=0, discard=32)
  32[28]: [363] ConvIntFromNull() -> integer var=i#index[28]:integer
  33[32]: VarInt(var[28]) -> integer var=i#index[28]:integer
  36[36]: ConvBoolFromInt(v1: integer) -> boolean
  37[33]: Not(v1: boolean) -> boolean
  38[33]: GotoFalseWord(jump=56, if_false: boolean)
  41[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  44[44]: GetInt(v1: ref(reference), fld=24) -> integer
  47[36]: ConstInt(val=1) -> integer
  52[40]: AddInt(v1: integer, v2: integer) -> integer
  53[36]: GotoWord(jump=65)
  56[32]: VarInt(var[28]) -> integer var=i#index[28]:integer
  59[36]: ConstInt(val=1) -> integer
  64[40]: AddInt(v1: integer, v2: integer) -> integer
  65[36]: PutInt(var[28], value: integer)
  68[32]: VarInt(var[28]) -> integer var=i#index[28]:integer
  71[36]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  74[48]: GetInt(v1: ref(reference), fld=12) -> integer
  77[40]: ConstInt(val=1) -> integer
  82[44]: MinInt(v1: integer, v2: integer) -> integer
  83[40]: GeInt(v1: integer, v2: integer) -> boolean
  84[33]: GotoFalseWord(jump=90, if_false: boolean)
  87[32]: GotoWord(jump=153)
  90[32]: VarInt(var[28]) -> integer var=i#index[28]:integer
  93[36]: [364] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  96[48]: GetText(v1: ref(reference), fld=8) -> text["self"]
  99[52]: VarInt(var[32]) -> integer var=i[32]:integer
 102[56]: TextCharacter(v1: text, v2: integer) -> character
 103[40]: ConvIntFromCharacter(v1: character) -> integer
 104[40]: ConstInt(val=92) -> integer
 109[44]: ConvIntFromCharacter(v1: character) -> integer
 110[44]: EqInt(v1: integer, v2: integer) -> boolean
 111[37]: GotoFalseWord(jump=133, if_false: boolean)
 114[36]: [365] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 117[48]: VarInt(var[32]) -> integer var=i[32]:integer
 120[52]: Call(size=0, fn=_tp_Lexer_escaped)
 127[40]: AppendRefCharacter(var[12], v1: character)
 130[36]: GotoWord(jump=146)
 133[36]: [367] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 136[48]: GetText(v1: ref(reference), fld=8) -> text["self"]
 139[52]: VarInt(var[32]) -> integer var=i[32]:integer
 142[56]: TextCharacter(v1: text, v2: integer) -> character
 143[40]: AppendRefCharacter(var[12], v1: character)
 146[36]: FreeStack(value=0, discard=4)
 150[32]: GotoWord(jump=33)
 153[32]: FreeStack(value=0, discard=4)
 157[28]: [370] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 160[40]: Call(size=0, fn=_tp_Lexer_scan)
 167[28]: [371] VarRef(var[12]) -> ref(reference) var=result[12]:&text
 170[40]: GetRefText(r: ref(reference)) -> text["self"]
 171[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_constant_character(self:Lexer) -> character {#block(1):character
  [376] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(8u8(17))) {#block(2):void
    [377] return OpCastCharacterFromInt(0i32);
  }#block(2):void else null;
  [379] result(1):character = if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 24i32), 1i32))), OpConvIntFromCharacter(92i32)) {#block(3):character
    [380] _tp_Lexer_escaped(self(0), OpAddInt(OpGetInt(self(0), 24i32), 2i32));
  }#block(3):character else {#block(4):character
    [382] OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 24i32), 1i32));
  }#block(4):character;
  [384] _tp_Lexer_scan(self(0));
  [385] result(1);
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_constant_character(self: ref(Lexer)[0]) -> character
   0[12]: return-address
   0[16]: [376] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=8) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=42, if_false: boolean)
  14[16]: [377] ConstInt(val=0) -> integer
  19[20]: CastCharacterFromInt(v1: integer) -> character
  20[20]: Return(ret=12, value=4, discard=20)
  26[20]: ConstInt(val=0) -> integer
  31[24]: CastCharacterFromInt(v1: integer) -> character
  32[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]
  38[24]: FreeStack(value=0, discard=8)
  42[16]: [379] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  45[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  48[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  51[44]: GetInt(v1: ref(reference), fld=24) -> integer
  54[36]: ConstInt(val=1) -> integer
  59[40]: AddInt(v1: integer, v2: integer) -> integer
  60[36]: TextCharacter(v1: text, v2: integer) -> character
  61[20]: ConvIntFromCharacter(v1: character) -> integer
  62[20]: ConstInt(val=92) -> integer
  67[24]: ConvIntFromCharacter(v1: character) -> integer
  68[24]: EqInt(v1: integer, v2: integer) -> boolean
  69[17]: GotoFalseWord(jump=97, if_false: boolean)
  72[16]: [380] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  75[28]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  78[40]: GetInt(v1: ref(reference), fld=24) -> integer
  81[32]: ConstInt(val=2) -> integer
  86[36]: AddInt(v1: integer, v2: integer) -> integer
  87[32]: Call(size=0, fn=_tp_Lexer_escaped)
  94[20]: GotoWord(jump=116)
  97[16]: [382] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 100[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
 103[32]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 106[44]: GetInt(v1: ref(reference), fld=24) -> integer
 109[36]: ConstInt(val=1) -> integer
 114[40]: AddInt(v1: integer, v2: integer) -> integer
 115[36]: TextCharacter(v1: text, v2: integer) -> character
 116[20]: [384] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
 119[32]: Call(size=0, fn=_tp_Lexer_scan)
 126[20]: [385] VarCharacter(var[16]) -> character var=result[16]:character
 129[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]

fn _tp_Lexer_string_finished(self:Lexer) -> boolean {#block(1):boolean
  [390] OpEqInt(OpGetByte(self(0), 42i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_string_finished(self: ref(Lexer)[0]) -> boolean
   0[12]: return-address
   0[16]: [390] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=42, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_last_comment(self:Lexer) -> text["self"] {#block(1):text["self"]
  [395] OpGetText(self(0), 36i32);
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_last_comment(self: ref(Lexer)[0]) -> text["self"]
   0[12]: return-address
   0[16]: [395] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=36) -> text["self"]
   6[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_comment_behind(self:Lexer) -> boolean {#block(1):boolean
  [400] OpEqInt(OpGetByte(self(0), 43i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_comment_behind(self: ref(Lexer)[0]) -> boolean
   0[12]: return-address
   0[16]: [400] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=43, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_anchor(self:Lexer) -> Anchor {#block(1):ref(Anchor)
  __ref_1(1):ref(Anchor) = null;
  [404] {#Object(2):ref(Anchor)["__ref_1"]
    OpDatabase(__ref_1(1), 25i32);
    OpSetInt(__ref_1(1), 4i32, OpGetInt(self(0), 12i32));
    OpSetInt(__ref_1(1), 8i32, OpGetInt(self(0), 16i32));
    OpSetInt(__ref_1(1), 12i32, OpGetInt(self(0), 20i32));
    __ref_1(1);
  }#Object(2):ref(Anchor)["__ref_1"];
}#block(1):ref(Anchor)

byte-code for lib/lexer.lav:_tp_Lexer_anchor(self: ref(Lexer)[0]) -> ref(Anchor)
   0[12]: return-address
   0[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[16]:ref(Anchor)
   1[28]: [404] Database(var[16], db_tp=25) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]
   6[28]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[16]:ref(Anchor)
   9[40]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  12[52]: GetInt(v1: ref(reference), fld=12) -> integer
  15[44]: SetInt(v1: ref(reference), fld=4, val: integer)
  18[28]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[16]:ref(Anchor)
  21[40]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  24[52]: GetInt(v1: ref(reference), fld=16) -> integer
  27[44]: SetInt(v1: ref(reference), fld=8, val: integer)
  30[28]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[16]:ref(Anchor)
  33[40]: VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  36[52]: GetInt(v1: ref(reference), fld=20) -> integer
  39[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[28]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[16]:ref(Anchor)
  45[40]: Return(ret=12, value=12, discard=40) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]

fn _tp_Lexer_revert(self:Lexer, to:Anchor) {#block(1):void
  [408] OpSetInt(self(0), 12i32, OpGetInt(to(0), 4i32));
  [409] OpSetInt(self(0), 16i32, OpGetInt(to(0), 8i32));
  [410] OpSetInt(self(0), 20i32, OpGetInt(to(0), 12i32));
  [411] _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_revert(self: ref(Lexer)[0], to: ref(Anchor)[12])
   0[24]: return-address
   0[28]: [408] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
   3[40]: VarRef(var[12]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[12]:ref(Anchor)
   6[52]: GetInt(v1: ref(reference), fld=4) -> integer
   9[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  12[28]: [409] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  15[40]: VarRef(var[12]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[12]:ref(Anchor)
  18[52]: GetInt(v1: ref(reference), fld=8) -> integer
  21[44]: SetInt(v1: ref(reference), fld=16, val: integer)
  24[28]: [410] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  27[40]: VarRef(var[12]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[12]:ref(Anchor)
  30[52]: GetInt(v1: ref(reference), fld=12) -> integer
  33[44]: SetInt(v1: ref(reference), fld=20, val: integer)
  36[28]: [411] VarRef(var[0]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[0]:ref(Lexer)
  39[40]: Call(size=0, fn=_tp_Lexer_scan)
  46[28]: Return(ret=24, value=0, discard=28)

fn main() {#block(1):void
  __ref_2(1):ref(main_vector<text>) = null;
  __ref_1(1):ref(main_vector<text>) = null;
  __work_7(1):text = "";
  __work_6(1):text = "";
  __work_5(1):text = "";
  __work_4(1):text = "";
  __work_3(1):text = "";
  __work_2(1):text = "";
  __work_1(1):text = "";
  [4] l(1):ref(Lexer) = null;
  OpDatabase(l(1), 22i32);
  OpSetText(l(1), 4i32, "");
  OpSetText(l(1), 8i32, "");
  OpSetInt(l(1), 12i32, 0i32);
  OpSetInt(l(1), 16i32, 0i32);
  OpSetInt(l(1), 20i32, 0i32);
  OpSetInt(l(1), 24i32, 0i32);
  OpSetEnum(l(1), 40i32, 0u8(17));
  OpSetByte(l(1), 41i32, 0i32, if false 1i32 else 0i32);
  OpSetByte(l(1), 42i32, 0i32, if false 1i32 else 0i32);
  OpSetInt(l(1), 28i32, 0i32);
  OpSetInt(l(1), 32i32, 0i32);
  OpSetByte(l(1), 43i32, 0i32, if false 1i32 else 0i32);
  OpSetText(l(1), 36i32, "");
  [5] _tp_Lexer_set_tokens(l(1), {#Vector(2):vector<text>
    OpDatabase(__ref_1(1), 14i32);
    _vec_1(2):vector<text>["__ref_1"] = OpGetField(__ref_1(1), 4i32, 7i32);
    OpSetInt(__ref_1(1), 4i32, 0i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "+=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "*=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "-=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "!=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "==");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<<");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "->");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "=>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "&&");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "||");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _vec_1(2);
  }#Vector(2):vector<text>);
  [6] _tp_Lexer_set_keywords(l(1), {#Vector(3):vector<text>
    OpDatabase(__ref_2(1), 14i32);
    _vec_3(3):vector<text>["__ref_2"] = OpGetField(__ref_2(1), 4i32, 7i32);
    OpSetInt(__ref_2(1), 4i32, 0i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "for");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "in");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "if");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "else");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "fn");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "pub");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "use");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "struct");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "enum");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "match");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "and");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "or");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _vec_3(3);
  }#Vector(3):vector<text>);
  [7] _tp_Lexer_parse_string(l(1), "Tokens", "12 += -2 * 3l >> 4");
  [8] if OpEqInt(_tp_Lexer_int(l(1)), 12i32) null else OpPanic("Integer");
  [9] if OpNot(_tp_Lexer_matches(l(1), "+")) null else OpPanic("Incorrect plus");
  [10] if OpNeText(_tp_Lexer_peek(l(1)), "+") null else OpPanic("Incorrect plus");
  [11] if _tp_Lexer_matches(l(1), "+=") null else OpPanic("Incorrect plus_is");
  [12] if OpEqInt(_tp_Lexer_int(l(1)), OpMinSingleInt(2i32)) null else OpPanic("Second integer");
  [13] if _tp_Lexer_matches(l(1), "*") null else OpPanic("Incorrect multiply");
  [14] if OpNeInt(_tp_Lexer_int(l(1)), 3i32) null else OpPanic("Third number");
  [15] if OpEqLong(_tp_Lexer_long_int(l(1)), OpConvLongFromInt(3i32)) null else OpPanic("Incorrect long");
  [16] if OpEqText(_tp_Lexer_position(l(1), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]), "Tokens:1:15") null else OpPanic({#Formatted string(5):text["__work_2"]
    __work_2(1):text = "Incorrect position ";
    OpFormatText(__work_2(1), _tp_Lexer_position(l(1), {#default ref(6):ref(reference)["__work_3"]
      OpCreateRef(__work_3(1));
    }#default ref(6):ref(reference)["__work_3"]), 0i32, -1i32, 32i32);
    __work_2(1);
  }#Formatted string(5):text["__work_2"]);
  [17] if OpNot(_tp_Lexer_matches(l(1), ">")) null else OpPanic("Incorrect higher");
  [18] if _tp_Lexer_matches(l(1), ">>") null else OpPanic("Incorrect logical shift");
  [19] if OpEqText(_tp_Lexer_position(l(1), {#default ref(7):ref(reference)["__work_4"]
    OpCreateRef(__work_4(1));
  }#default ref(7):ref(reference)["__work_4"]), "Tokens:1:18") null else OpPanic({#Formatted string(8):text["__work_5"]
    __work_5(1):text = "Incorrect position ";
    OpFormatText(__work_5(1), _tp_Lexer_position(l(1), {#default ref(9):ref(reference)["__work_6"]
      OpCreateRef(__work_6(1));
    }#default ref(9):ref(reference)["__work_6"]), 0i32, -1i32, 32i32);
    __work_5(1);
  }#Formatted string(8):text["__work_5"]);
  [21] _tp_Lexer_parse_string(l(1), "Texts", ""123" + '4'");
  [22] if OpEqText(_tp_Lexer_constant_text(l(1), {#default ref(10):ref(reference)["__work_7"]
    OpCreateRef(__work_7(1));
  }#default ref(10):ref(reference)["__work_7"]), "123") null else OpPanic("Incorrect text literal");
  [23] if _tp_Lexer_matches(l(1), "+") null else OpPanic("Incorrect add");
  [24] if OpEqBool(OpConvBoolFromCharacter(_tp_Lexer_constant_character(l(1))), OpConvBoolFromText("123")) null else OpPanic("Incorrect text literal");
  [26] _tp_Lexer_parse_string(l(1), "Comments", "// starting comments
123 // same line comment
// extra comment
4");
  [27] if OpNot(_tp_Lexer_comment_behind(l(1))) null else OpPanic("Initial comment not behind");
  [28] if OpEqText(_tp_Lexer_last_comment(l(1)), "starting comments") null else OpPanic("Initial comment");
  [29] if OpEqInt(_tp_Lexer_int(l(1)), 123i32) null else OpPanic("Content integer");
  [30] if _tp_Lexer_comment_behind(l(1)) null else OpPanic("Second comment is behind");
  [31] if OpEqText(_tp_Lexer_last_comment(l(1)), "same line comment
extra comment") null else OpPanic("Second comment");
  [32] if OpNot(_tp_Lexer_is_finished(l(1))) null else OpPanic("Not Ready");
  [33] if OpEqInt(_tp_Lexer_int(l(1)), 4i32) null else OpPanic("Second integer");
  [34] if OpEqText(_tp_Lexer_last_comment(l(1)), "") null else OpPanic("No remaining comment");
  [35] if _tp_Lexer_is_finished(l(1)) null else OpPanic("Ready");
  OpFreeRef(l(1));
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
  OpFreeText(__work_3(1));
  OpFreeText(__work_4(1));
  OpFreeText(__work_5(1));
  OpFreeText(__work_6(1));
  OpFreeText(__work_7(1));
  OpFreeRef(__ref_1(1));
  OpFreeRef(__ref_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:main()
   0[0]: return-address
   0[4]: ConvRefFromNull() -> ref(reference) var=__ref_2[4]:ref(main_vector<text>)
   1[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[16]:ref(main_vector<text>)
   2[28]: Text() var=__work_7[28]:text
   3[52]: Text() var=__work_6[52]:text
   4[76]: Text() var=__work_5[76]:text
   5[100]: Text() var=__work_4[100]:text
   6[124]: Text() var=__work_3[124]:text
   7[148]: Text() var=__work_2[148]:text
   8[172]: Text() var=__work_1[172]:text
   9[196]: [4] ConvRefFromNull() -> ref(reference) var=l[196]:ref(Lexer)
  10[208]: Database(var[196], db_tp=22) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22]
  15[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  18[220]: ConstText(_value="") -> text
  20[236]: SetText(v1: ref(reference), fld=4, val: text)
  23[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  26[220]: ConstText(_value="") -> text
  28[236]: SetText(v1: ref(reference), fld=8, val: text)
  31[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  34[220]: ConstInt(val=0) -> integer
  39[224]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  45[220]: ConstInt(val=0) -> integer
  50[224]: SetInt(v1: ref(reference), fld=16, val: integer)
  53[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  56[220]: ConstInt(val=0) -> integer
  61[224]: SetInt(v1: ref(reference), fld=20, val: integer)
  64[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  67[220]: ConstInt(val=0) -> integer
  72[224]: SetInt(v1: ref(reference), fld=24, val: integer)
  75[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  78[220]: ConstEnum(val=0) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword", "Finished"])[17]
  80[221]: SetEnum(v1: ref(reference), fld=40, val: boolean)
  83[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
  86[220]: ConstFalse() -> boolean
  87[221]: GotoFalseWord(jump=98, if_false: boolean)
  90[220]: ConstInt(val=1) -> integer
  95[224]: GotoWord(jump=103)
  98[220]: ConstInt(val=0) -> integer
 103[224]: SetByte(v1: ref(reference), fld=41, min=0, val: integer)
 108[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 111[220]: ConstFalse() -> boolean
 112[221]: GotoFalseWord(jump=123, if_false: boolean)
 115[220]: ConstInt(val=1) -> integer
 120[224]: GotoWord(jump=128)
 123[220]: ConstInt(val=0) -> integer
 128[224]: SetByte(v1: ref(reference), fld=42, min=0, val: integer)
 133[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 136[220]: ConstInt(val=0) -> integer
 141[224]: SetInt(v1: ref(reference), fld=28, val: integer)
 144[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 147[220]: ConstInt(val=0) -> integer
 152[224]: SetInt(v1: ref(reference), fld=32, val: integer)
 155[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 158[220]: ConstFalse() -> boolean
 159[221]: GotoFalseWord(jump=170, if_false: boolean)
 162[220]: ConstInt(val=1) -> integer
 167[224]: GotoWord(jump=175)
 170[220]: ConstInt(val=0) -> integer
 175[224]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
 180[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 183[220]: ConstText(_value="") -> text
 185[236]: SetText(v1: ref(reference), fld=36, val: text)
 188[208]: [5] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 191[220]: Database(var[16], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 196[220]: VarRef(var[16]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[16]:ref(main_vector<text>)
 199[232]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 202[232]: VarRef(var[16]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[16]:ref(main_vector<text>)
 205[244]: ConstInt(val=0) -> integer
 210[248]: SetInt(v1: ref(reference), fld=4, val: integer)
 213[232]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 216[244]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 221[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 224[256]: ConstText(_value="+=") -> text
 228[272]: SetText(v1: ref(reference), fld=0, val: text)
 231[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 234[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 237[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 242[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 245[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 250[256]: PutRef(var[232], value: ref(reference))
 253[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 256[256]: ConstText(_value="*=") -> text
 260[272]: SetText(v1: ref(reference), fld=0, val: text)
 263[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 266[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 269[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 274[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 277[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 282[256]: PutRef(var[232], value: ref(reference))
 285[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 288[256]: ConstText(_value="-=") -> text
 292[272]: SetText(v1: ref(reference), fld=0, val: text)
 295[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 298[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 301[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 306[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 309[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 314[256]: PutRef(var[232], value: ref(reference))
 317[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 320[256]: ConstText(_value="<=") -> text
 324[272]: SetText(v1: ref(reference), fld=0, val: text)
 327[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 330[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 333[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 338[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 341[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 346[256]: PutRef(var[232], value: ref(reference))
 349[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 352[256]: ConstText(_value=">=") -> text
 356[272]: SetText(v1: ref(reference), fld=0, val: text)
 359[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 362[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 365[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 370[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 373[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 378[256]: PutRef(var[232], value: ref(reference))
 381[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 384[256]: ConstText(_value="!=") -> text
 388[272]: SetText(v1: ref(reference), fld=0, val: text)
 391[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 394[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 397[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 402[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 405[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 410[256]: PutRef(var[232], value: ref(reference))
 413[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 416[256]: ConstText(_value="==") -> text
 420[272]: SetText(v1: ref(reference), fld=0, val: text)
 423[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 426[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 429[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 434[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 437[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 442[256]: PutRef(var[232], value: ref(reference))
 445[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 448[256]: ConstText(_value=">>") -> text
 452[272]: SetText(v1: ref(reference), fld=0, val: text)
 455[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 458[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 461[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 466[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 469[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 474[256]: PutRef(var[232], value: ref(reference))
 477[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 480[256]: ConstText(_value="<<") -> text
 484[272]: SetText(v1: ref(reference), fld=0, val: text)
 487[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 490[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 493[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 498[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 501[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 506[256]: PutRef(var[232], value: ref(reference))
 509[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 512[256]: ConstText(_value="->") -> text
 516[272]: SetText(v1: ref(reference), fld=0, val: text)
 519[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 522[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 525[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 530[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 533[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 538[256]: PutRef(var[232], value: ref(reference))
 541[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 544[256]: ConstText(_value="=>") -> text
 548[272]: SetText(v1: ref(reference), fld=0, val: text)
 551[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 554[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 557[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 562[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 565[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 570[256]: PutRef(var[232], value: ref(reference))
 573[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 576[256]: ConstText(_value=">>>") -> text
 581[272]: SetText(v1: ref(reference), fld=0, val: text)
 584[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 587[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 590[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 595[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 598[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 603[256]: PutRef(var[232], value: ref(reference))
 606[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 609[256]: ConstText(_value="..") -> text
 613[272]: SetText(v1: ref(reference), fld=0, val: text)
 616[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 619[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 622[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 627[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 630[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 635[256]: PutRef(var[232], value: ref(reference))
 638[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 641[256]: ConstText(_value="..=") -> text
 646[272]: SetText(v1: ref(reference), fld=0, val: text)
 649[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 652[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 655[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 660[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 663[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 668[256]: PutRef(var[232], value: ref(reference))
 671[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 674[256]: ConstText(_value="&&") -> text
 678[272]: SetText(v1: ref(reference), fld=0, val: text)
 681[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 684[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 687[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 692[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 695[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 700[256]: PutRef(var[232], value: ref(reference))
 703[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 706[256]: ConstText(_value="||") -> text
 710[272]: SetText(v1: ref(reference), fld=0, val: text)
 713[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 716[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[232]:ref(boolean)["_vec_1"]
 719[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 724[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[220]:vector<text>["__ref_1"]
 727[256]: FreeStack(value=12, discard=36)
 731[232]: Call(size=0, fn=_tp_Lexer_set_tokens)
 738[208]: [6] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
 741[220]: Database(var[4], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 746[220]: VarRef(var[4]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[4]:ref(main_vector<text>)
 749[232]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 752[232]: VarRef(var[4]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[4]:ref(main_vector<text>)
 755[244]: ConstInt(val=0) -> integer
 760[248]: SetInt(v1: ref(reference), fld=4, val: integer)
 763[232]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 766[244]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 771[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 774[256]: ConstText(_value="for") -> text
 779[272]: SetText(v1: ref(reference), fld=0, val: text)
 782[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 785[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 788[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 793[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 796[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 801[256]: PutRef(var[232], value: ref(reference))
 804[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 807[256]: ConstText(_value="in") -> text
 811[272]: SetText(v1: ref(reference), fld=0, val: text)
 814[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 817[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 820[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 825[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 828[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 833[256]: PutRef(var[232], value: ref(reference))
 836[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 839[256]: ConstText(_value="if") -> text
 843[272]: SetText(v1: ref(reference), fld=0, val: text)
 846[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 849[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 852[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 857[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 860[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 865[256]: PutRef(var[232], value: ref(reference))
 868[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 871[256]: ConstText(_value="else") -> text
 877[272]: SetText(v1: ref(reference), fld=0, val: text)
 880[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 883[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 886[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 891[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 894[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 899[256]: PutRef(var[232], value: ref(reference))
 902[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 905[256]: ConstText(_value="fn") -> text
 909[272]: SetText(v1: ref(reference), fld=0, val: text)
 912[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 915[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 918[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 923[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 926[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 931[256]: PutRef(var[232], value: ref(reference))
 934[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 937[256]: ConstText(_value="pub") -> text
 942[272]: SetText(v1: ref(reference), fld=0, val: text)
 945[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 948[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 951[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 956[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 959[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 964[256]: PutRef(var[232], value: ref(reference))
 967[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 970[256]: ConstText(_value="use") -> text
 975[272]: SetText(v1: ref(reference), fld=0, val: text)
 978[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 981[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
 984[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 989[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
 992[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 997[256]: PutRef(var[232], value: ref(reference))
1000[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1003[256]: ConstText(_value="struct") -> text
1011[272]: SetText(v1: ref(reference), fld=0, val: text)
1014[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1017[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1020[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1025[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1028[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1033[256]: PutRef(var[232], value: ref(reference))
1036[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1039[256]: ConstText(_value="enum") -> text
1045[272]: SetText(v1: ref(reference), fld=0, val: text)
1048[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1051[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1054[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1059[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1062[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1067[256]: PutRef(var[232], value: ref(reference))
1070[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1073[256]: ConstText(_value="match") -> text
1080[272]: SetText(v1: ref(reference), fld=0, val: text)
1083[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1086[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1089[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1094[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1097[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1102[256]: PutRef(var[232], value: ref(reference))
1105[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1108[256]: ConstText(_value="and") -> text
1113[272]: SetText(v1: ref(reference), fld=0, val: text)
1116[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1119[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1122[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1127[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1130[256]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1135[256]: PutRef(var[232], value: ref(reference))
1138[244]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1141[256]: ConstText(_value="or") -> text
1145[272]: SetText(v1: ref(reference), fld=0, val: text)
1148[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1151[256]: VarRef(var[232]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[232]:ref(boolean)["_vec_3"]
1154[268]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1159[244]: VarVector(var[220]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[220]:vector<text>["__ref_2"]
1162[256]: FreeStack(value=12, discard=36)
1166[232]: Call(size=0, fn=_tp_Lexer_set_keywords)
1173[208]: [7] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1176[220]: ConstText(_value="Tokens") -> text
1184[236]: ConstText(_value="12 += -2 * 3l >> 4") -> text
1204[252]: Call(size=0, fn=_tp_Lexer_parse_string)
1211[208]: [8] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1214[220]: Call(size=0, fn=_tp_Lexer_int)
1221[212]: ConstInt(val=12) -> integer
1226[216]: EqInt(v1: integer, v2: integer) -> boolean
1227[209]: GotoFalseWord(jump=1233, if_false: boolean)
1230[208]: GotoWord(jump=1243)
1233[208]: ConstText(_value="Integer") -> text
1242[224]: Panic(message: text)
1243[208]: [9] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1246[220]: ConstText(_value="+") -> text
1249[236]: Call(size=0, fn=_tp_Lexer_matches)
1256[209]: Not(v1: boolean) -> boolean
1257[209]: GotoFalseWord(jump=1263, if_false: boolean)
1260[208]: GotoWord(jump=1280)
1263[208]: ConstText(_value="Incorrect plus") -> text
1279[224]: Panic(message: text)
1280[208]: [10] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1283[220]: Call(size=0, fn=_tp_Lexer_peek)
1290[224]: ConstText(_value="+") -> text
1293[240]: NeText(v1: text, v2: text) -> boolean
1294[209]: GotoFalseWord(jump=1300, if_false: boolean)
1297[208]: GotoWord(jump=1317)
1300[208]: ConstText(_value="Incorrect plus") -> text
1316[224]: Panic(message: text)
1317[208]: [11] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1320[220]: ConstText(_value="+=") -> text
1324[236]: Call(size=0, fn=_tp_Lexer_matches)
1331[209]: GotoFalseWord(jump=1337, if_false: boolean)
1334[208]: GotoWord(jump=1357)
1337[208]: ConstText(_value="Incorrect plus_is") -> text
1356[224]: Panic(message: text)
1357[208]: [12] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1360[220]: Call(size=0, fn=_tp_Lexer_int)
1367[212]: ConstInt(val=2) -> integer
1372[216]: MinSingleInt(v1: integer) -> integer
1373[216]: EqInt(v1: integer, v2: integer) -> boolean
1374[209]: GotoFalseWord(jump=1380, if_false: boolean)
1377[208]: GotoWord(jump=1397)
1380[208]: ConstText(_value="Second integer") -> text
1396[224]: Panic(message: text)
1397[208]: [13] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1400[220]: ConstText(_value="*") -> text
1403[236]: Call(size=0, fn=_tp_Lexer_matches)
1410[209]: GotoFalseWord(jump=1416, if_false: boolean)
1413[208]: GotoWord(jump=1437)
1416[208]: ConstText(_value="Incorrect multiply") -> text
1436[224]: Panic(message: text)
1437[208]: [14] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1440[220]: Call(size=0, fn=_tp_Lexer_int)
1447[212]: ConstInt(val=3) -> integer
1452[216]: NeInt(v1: integer, v2: integer) -> boolean
1453[209]: GotoFalseWord(jump=1459, if_false: boolean)
1456[208]: GotoWord(jump=1474)
1459[208]: ConstText(_value="Third number") -> text
1473[224]: Panic(message: text)
1474[208]: [15] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1477[220]: Call(size=0, fn=_tp_Lexer_long_int)
1484[216]: ConstInt(val=3) -> integer
1489[220]: ConvLongFromInt(v1: integer) -> long
1490[224]: EqLong(v1: long, v2: long) -> boolean
1491[209]: GotoFalseWord(jump=1497, if_false: boolean)
1494[208]: GotoWord(jump=1514)
1497[208]: ConstText(_value="Incorrect long") -> text
1513[224]: Panic(message: text)
1514[208]: [16] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1517[220]: CreateRef(var[172]) -> ref(reference)
1520[232]: Call(size=0, fn=_tp_Lexer_position)
1527[224]: ConstText(_value="Tokens:1:15") -> text
1540[240]: EqText(v1: text, v2: text) -> boolean
1541[209]: GotoFalseWord(jump=1547, if_false: boolean)
1544[208]: GotoWord(jump=1601)
1547[208]: ClearText(var[148]) var=__work_2[148]:text
1550[208]: ConstText(_value="Incorrect position ") -> text
1571[224]: AppendText(var[148], v1: text)
1574[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1577[220]: CreateRef(var[124]) -> ref(reference)
1580[232]: Call(size=0, fn=_tp_Lexer_position)
1587[224]: ConstInt(val=0) -> integer
1592[228]: FormatText(var[148], val: text, width: integer, dir=-1, token=32)
1597[208]: VarText(var[148]) -> text var=__work_2[148]:text
1600[224]: Panic(message: text)
1601[208]: [17] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1604[220]: ConstText(_value=">") -> text
1607[236]: Call(size=0, fn=_tp_Lexer_matches)
1614[209]: Not(v1: boolean) -> boolean
1615[209]: GotoFalseWord(jump=1621, if_false: boolean)
1618[208]: GotoWord(jump=1640)
1621[208]: ConstText(_value="Incorrect higher") -> text
1639[224]: Panic(message: text)
1640[208]: [18] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1643[220]: ConstText(_value=">>") -> text
1647[236]: Call(size=0, fn=_tp_Lexer_matches)
1654[209]: GotoFalseWord(jump=1660, if_false: boolean)
1657[208]: GotoWord(jump=1686)
1660[208]: ConstText(_value="Incorrect logical shift") -> text
1685[224]: Panic(message: text)
1686[208]: [19] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1689[220]: CreateRef(var[100]) -> ref(reference)
1692[232]: Call(size=0, fn=_tp_Lexer_position)
1699[224]: ConstText(_value="Tokens:1:18") -> text
1712[240]: EqText(v1: text, v2: text) -> boolean
1713[209]: GotoFalseWord(jump=1719, if_false: boolean)
1716[208]: GotoWord(jump=1773)
1719[208]: ClearText(var[76]) var=__work_5[76]:text
1722[208]: ConstText(_value="Incorrect position ") -> text
1743[224]: AppendText(var[76], v1: text)
1746[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1749[220]: CreateRef(var[52]) -> ref(reference)
1752[232]: Call(size=0, fn=_tp_Lexer_position)
1759[224]: ConstInt(val=0) -> integer
1764[228]: FormatText(var[76], val: text, width: integer, dir=-1, token=32)
1769[208]: VarText(var[76]) -> text var=__work_5[76]:text
1772[224]: Panic(message: text)
1773[208]: [21] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1776[220]: ConstText(_value="Texts") -> text
1783[236]: ConstText(_value=""123" + '4'") -> text
1796[252]: Call(size=0, fn=_tp_Lexer_parse_string)
1803[208]: [22] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1806[220]: CreateRef(var[28]) -> ref(reference)
1809[232]: Call(size=0, fn=_tp_Lexer_constant_text)
1816[224]: ConstText(_value="123") -> text
1821[240]: EqText(v1: text, v2: text) -> boolean
1822[209]: GotoFalseWord(jump=1828, if_false: boolean)
1825[208]: GotoWord(jump=1853)
1828[208]: ConstText(_value="Incorrect text literal") -> text
1852[224]: Panic(message: text)
1853[208]: [23] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1856[220]: ConstText(_value="+") -> text
1859[236]: Call(size=0, fn=_tp_Lexer_matches)
1866[209]: GotoFalseWord(jump=1872, if_false: boolean)
1869[208]: GotoWord(jump=1888)
1872[208]: ConstText(_value="Incorrect add") -> text
1887[224]: Panic(message: text)
1888[208]: [24] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1891[220]: Call(size=0, fn=_tp_Lexer_constant_character)
1898[212]: ConvBoolFromCharacter(v1: character) -> boolean
1899[209]: ConstText(_value="123") -> text
1904[225]: ConvBoolFromText(v1: text) -> boolean
1905[210]: EqBool(v1: boolean, v2: boolean) -> boolean
1906[209]: GotoFalseWord(jump=1912, if_false: boolean)
1909[208]: GotoWord(jump=1937)
1912[208]: ConstText(_value="Incorrect text literal") -> text
1936[224]: Panic(message: text)
1937[208]: [26] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
1940[220]: ConstText(_value="Comments") -> text
1950[236]: ConstText(_value="// starting comments
123 // same line comment
// extra comment
4") -> text
2016[252]: Call(size=0, fn=_tp_Lexer_parse_string)
2023[208]: [27] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2026[220]: Call(size=0, fn=_tp_Lexer_comment_behind)
2033[209]: Not(v1: boolean) -> boolean
2034[209]: GotoFalseWord(jump=2040, if_false: boolean)
2037[208]: GotoWord(jump=2069)
2040[208]: ConstText(_value="Initial comment not behind") -> text
2068[224]: Panic(message: text)
2069[208]: [28] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2072[220]: Call(size=0, fn=_tp_Lexer_last_comment)
2079[224]: ConstText(_value="starting comments") -> text
2098[240]: EqText(v1: text, v2: text) -> boolean
2099[209]: GotoFalseWord(jump=2105, if_false: boolean)
2102[208]: GotoWord(jump=2123)
2105[208]: ConstText(_value="Initial comment") -> text
2122[224]: Panic(message: text)
2123[208]: [29] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2126[220]: Call(size=0, fn=_tp_Lexer_int)
2133[212]: ConstInt(val=123) -> integer
2138[216]: EqInt(v1: integer, v2: integer) -> boolean
2139[209]: GotoFalseWord(jump=2145, if_false: boolean)
2142[208]: GotoWord(jump=2163)
2145[208]: ConstText(_value="Content integer") -> text
2162[224]: Panic(message: text)
2163[208]: [30] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2166[220]: Call(size=0, fn=_tp_Lexer_comment_behind)
2173[209]: GotoFalseWord(jump=2179, if_false: boolean)
2176[208]: GotoWord(jump=2206)
2179[208]: ConstText(_value="Second comment is behind") -> text
2205[224]: Panic(message: text)
2206[208]: [31] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2209[220]: Call(size=0, fn=_tp_Lexer_last_comment)
2216[224]: ConstText(_value="same line comment
extra comment") -> text
2249[240]: EqText(v1: text, v2: text) -> boolean
2250[209]: GotoFalseWord(jump=2256, if_false: boolean)
2253[208]: GotoWord(jump=2273)
2256[208]: ConstText(_value="Second comment") -> text
2272[224]: Panic(message: text)
2273[208]: [32] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2276[220]: Call(size=0, fn=_tp_Lexer_is_finished)
2283[209]: Not(v1: boolean) -> boolean
2284[209]: GotoFalseWord(jump=2290, if_false: boolean)
2287[208]: GotoWord(jump=2302)
2290[208]: ConstText(_value="Not Ready") -> text
2301[224]: Panic(message: text)
2302[208]: [33] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2305[220]: Call(size=0, fn=_tp_Lexer_int)
2312[212]: ConstInt(val=4) -> integer
2317[216]: EqInt(v1: integer, v2: integer) -> boolean
2318[209]: GotoFalseWord(jump=2324, if_false: boolean)
2321[208]: GotoWord(jump=2341)
2324[208]: ConstText(_value="Second integer") -> text
2340[224]: Panic(message: text)
2341[208]: [34] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2344[220]: Call(size=0, fn=_tp_Lexer_last_comment)
2351[224]: ConstText(_value="") -> text
2353[240]: EqText(v1: text, v2: text) -> boolean
2354[209]: GotoFalseWord(jump=2360, if_false: boolean)
2357[208]: GotoWord(jump=2383)
2360[208]: ConstText(_value="No remaining comment") -> text
2382[224]: Panic(message: text)
2383[208]: [35] VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2386[220]: Call(size=0, fn=_tp_Lexer_is_finished)
2393[209]: GotoFalseWord(jump=2399, if_false: boolean)
2396[208]: GotoWord(jump=2407)
2399[208]: ConstText(_value="Ready") -> text
2406[224]: Panic(message: text)
2407[208]: VarRef(var[196]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[196]:ref(Lexer)
2410[220]: FreeRef(v1: ref(reference))
2411[208]: FreeText(var[172])
2414[208]: FreeText(var[148])
2417[208]: FreeText(var[124])
2420[208]: FreeText(var[100])
2423[208]: FreeText(var[76])
2426[208]: FreeText(var[52])
2429[208]: FreeText(var[28])
2432[208]: VarRef(var[16]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[16]:ref(main_vector<text>)
2435[220]: FreeRef(v1: ref(reference))
2436[208]: VarRef(var[4]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[4]:ref(main_vector<text>)
2439[220]: FreeRef(v1: ref(reference))
2440[208]: Return(ret=0, value=0, discard=208)

