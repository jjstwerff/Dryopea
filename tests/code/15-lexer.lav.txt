fn _tp_Lexer_set_keywords(self:Lexer, keywords:vector<text>) {#block(1):void
  OpGetField(self(0), 24i32, 22i32);
  {#For block(2):void
    _vector_1(2):vector<text>["keywords"] = keywords(0);
    k#index(2):integer = -1i32;
    loop {#For loop_3
      k(3):text["_vector_1"] = {#iter next(4):text
        k#index(2):integer = OpAddInt(k#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, k#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(k(3))) {#break(5):void
        OpFreeText(k(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        _elm_2(6):ref(Keyword)["self"] = OpNewRecord(self(0), 21i32, 7i32);
        OpSetText(_elm_2(6), 4i32, k(3));
        OpFinishRecord(self(0), _elm_2(6), 21i32, 7i32);
      }#block(6):void;
      OpFreeText(k(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_keywords(self: ref(Lexer)[4], keywords: vector<text>[16]) [1110]
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[44]: GetField(v1: ref(reference), fld=24) -> ref(reference) type=hash<Keyword[name]>[4]:Hash(17, [0]) keys [tp:6 desc:false field:4, ][22]
   6[44]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=keywords[16]:vector<text>
   9[56]: ConstInt(val=-1) -> integer var=k#index[56]:integer
  14[60]: Text() var=k[60]:text["_vector_1"]
  15[84]: VarInt(var[56]) -> integer var=k#index[56]:integer
  18[88]: ConstInt(val=1) -> integer
  23[92]: AddInt(v1: integer, v2: integer) -> integer
  24[88]: PutInt(var[56], value: integer)
  27[84]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["keywords"]
  30[96]: VarInt(var[56]) -> integer var=k#index[56]:integer
  33[100]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[96]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[100]: AppendText(var[60], v1: text)
  42[84]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  45[100]: ConvBoolFromText(v1: text) -> boolean
  46[85]: Not(v1: boolean) -> boolean
  47[85]: GotoFalseWord(jump=60, if_false: boolean)
  50[84]: FreeText(var[60])
  53[84]: FreeStack(value=0, discard=24)
  57[60]: GotoWord(jump=102)
  60[84]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  63[96]: NewRecord(data: ref(reference), parent_tp=21, fld=7) -> ref(reference)
  68[96]: VarRef(var[84]) -> ref(reference) type=Keyword[8]:{name:text[4]}[17] var=_elm_2[84]:ref(Keyword)["self"]
  71[108]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  74[124]: SetText(v1: ref(reference), fld=4, val: text)
  77[96]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  80[108]: VarRef(var[84]) -> ref(reference) type=Keyword[8]:{name:text[4]}[17] var=_elm_2[84]:ref(Keyword)["self"]
  83[120]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=21, fld=7)
  88[96]: FreeStack(value=0, discard=12)
  92[84]: FreeText(var[60])
  95[84]: FreeStack(value=0, discard=24)
  99[60]: GotoWord(jump=14)
 102[60]: FreeStack(value=0, discard=16)
 106[44]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_set_tokens(self:Lexer, tokens:vector<text>) {#block(1):void
  OpGetField(self(0), 28i32, 23i32);
  {#For block(2):void
    _vector_1(2):vector<text>["tokens"] = tokens(0);
    t#index(2):integer = -1i32;
    loop {#For loop_3
      t(3):text["_vector_1"] = {#iter next(4):text
        t#index(2):integer = OpAddInt(t#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, t#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(t(3))) {#break(5):void
        OpFreeText(t(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        f(6):character = OpGetCharacter(t(3), 0i32);
        if OpNot(OpConvBoolFromCharacter(f(6))) {#block(7):void
          OpFreeText(t(3));
          continue(0);
        }#block(7):void else null;
        if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, OpConvIntFromCharacter(f(6)))) {#block(8):void
          _elm_2(8):ref(Possible)["self"] = OpNewRecord(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, OpConvIntFromCharacter(f(6))), 19i32, 1i32);
          OpSetInt(_elm_2(8), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_2(8), 4i32, t(3));
          OpFinishRecord(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, OpConvIntFromCharacter(f(6))), _elm_2(8), 19i32, 1i32);
        }#block(8):void else {#block(9):void
          _elm_3(9):ref(Token)["self"] = OpNewRecord(self(0), 21i32, 8i32);
          OpSetInt(_elm_3(9), 4i32, OpConvIntFromCharacter(f(6)));
          OpSetInt(_elm_3(9), 8i32, 0i32);
          _elm_4(9):ref(Possible)["_elm_3"] = OpNewRecord(_elm_3(9), 19i32, 1i32);
          OpSetInt(_elm_4(9), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_4(9), 4i32, t(3));
          OpFinishRecord(_elm_3(9), _elm_4(9), 19i32, 1i32);
          OpFinishRecord(self(0), _elm_3(9), 21i32, 8i32);
        }#block(9):void;
      }#block(6):void;
      OpFreeText(t(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_tokens(self: ref(Lexer)[4], tokens: vector<text>[16]) [1222]
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[44]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<Token[start]>[4]:Hash(19, [0]) keys [tp:1 desc:false field:4, ][23]
   6[44]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=tokens[16]:vector<text>
   9[56]: ConstInt(val=-1) -> integer var=t#index[56]:integer
  14[60]: Text() var=t[60]:text["_vector_1"]
  15[84]: VarInt(var[56]) -> integer var=t#index[56]:integer
  18[88]: ConstInt(val=1) -> integer
  23[92]: AddInt(v1: integer, v2: integer) -> integer
  24[88]: PutInt(var[56], value: integer)
  27[84]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["tokens"]
  30[96]: VarInt(var[56]) -> integer var=t#index[56]:integer
  33[100]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[96]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[100]: AppendText(var[60], v1: text)
  42[84]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  45[100]: ConvBoolFromText(v1: text) -> boolean
  46[85]: Not(v1: boolean) -> boolean
  47[85]: GotoFalseWord(jump=60, if_false: boolean)
  50[84]: FreeText(var[60])
  53[84]: FreeStack(value=0, discard=24)
  57[60]: GotoWord(jump=280)
  60[84]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  63[100]: ConstInt(val=0) -> integer
  68[104]: GetCharacter(v1: text, v2: integer) -> character
  69[88]: VarInt(var[84]) -> integer var=f[84]:character
  72[92]: ConvBoolFromCharacter(v1: character) -> boolean
  73[89]: Not(v1: boolean) -> boolean
  74[89]: GotoFalseWord(jump=87, if_false: boolean)
  77[88]: FreeText(var[60])
  80[88]: FreeStack(value=0, discard=28)
  84[60]: GotoWord(jump=14)
  87[88]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  90[100]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<Token[start]>[4]:Hash(19, [0]) keys [tp:1 desc:false field:4, ][23]
  93[100]: VarInt(var[84]) -> integer var=f[84]:character
  96[104]: ConvIntFromCharacter(v1: character) -> integer
  97[104]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
 101[100]: ConvBoolFromRef(val: ref(reference)) -> boolean
 102[89]: GotoFalseWord(jump=178, if_false: boolean)
 105[88]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
 108[100]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<Token[start]>[4]:Hash(19, [0]) keys [tp:1 desc:false field:4, ][23]
 111[100]: VarInt(var[84]) -> integer var=f[84]:character
 114[104]: ConvIntFromCharacter(v1: character) -> integer
 115[104]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
 119[100]: NewRecord(data: ref(reference), parent_tp=19, fld=1) -> ref(reference)
 124[100]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_2[88]:ref(Possible)["self"]
 127[112]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 130[128]: Call(size=0, to=318)
 137[116]: SetInt(v1: ref(reference), fld=0, val: integer)
 140[100]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_2[88]:ref(Possible)["self"]
 143[112]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 146[128]: SetText(v1: ref(reference), fld=4, val: text)
 149[100]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
 152[112]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<Token[start]>[4]:Hash(19, [0]) keys [tp:1 desc:false field:4, ][23]
 155[112]: VarInt(var[84]) -> integer var=f[84]:character
 158[116]: ConvIntFromCharacter(v1: character) -> integer
 159[116]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
 163[112]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_2[88]:ref(Possible)["self"]
 166[124]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=19, fld=1)
 171[100]: FreeStack(value=0, discard=12)
 175[88]: GotoWord(jump=266)
 178[88]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
 181[100]: NewRecord(data: ref(reference), parent_tp=21, fld=8) -> ref(reference)
 186[100]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[19] var=_elm_3[88]:ref(Token)["self"]
 189[112]: VarInt(var[84]) -> integer var=f[84]:character
 192[116]: ConvIntFromCharacter(v1: character) -> integer
 193[116]: SetInt(v1: ref(reference), fld=4, val: integer)
 196[100]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[19] var=_elm_3[88]:ref(Token)["self"]
 199[112]: ConstInt(val=0) -> integer
 204[116]: SetInt(v1: ref(reference), fld=8, val: integer)
 207[100]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[19] var=_elm_3[88]:ref(Token)["self"]
 210[112]: NewRecord(data: ref(reference), parent_tp=19, fld=1) -> ref(reference)
 215[112]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_4[100]:ref(Possible)["_elm_3"]
 218[124]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 221[140]: Call(size=0, to=318)
 228[128]: SetInt(v1: ref(reference), fld=0, val: integer)
 231[112]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_4[100]:ref(Possible)["_elm_3"]
 234[124]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 237[140]: SetText(v1: ref(reference), fld=4, val: text)
 240[112]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[19] var=_elm_3[88]:ref(Token)["self"]
 243[124]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[18] var=_elm_4[100]:ref(Possible)["_elm_3"]
 246[136]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=19, fld=1)
 251[112]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
 254[124]: VarRef(var[88]) -> ref(reference) type=Token[12]:{start:integer[4], possible:sorted<Possible[-length,token]>[8]}[19] var=_elm_3[88]:ref(Token)["self"]
 257[136]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=21, fld=8)
 262[112]: FreeStack(value=0, discard=24)
 266[88]: FreeStack(value=0, discard=4)
 270[84]: FreeText(var[60])
 273[84]: FreeStack(value=0, discard=24)
 277[60]: GotoWord(jump=14)
 280[60]: FreeStack(value=0, discard=16)
 284[44]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_parse(self:Lexer, filename:text) {#block(1):void
  __ref_1(1):ref(File) = null;
  __work_1(1):text = "";
  v(1):integer = _tp_text_rfind(filename(0), "/");
  OpSetText(self(0), 4i32, if OpConvBoolFromInt(v(1)) {#block(2):text["filename"]
    OpGetTextSub(filename(0), OpAddInt(v(1), 1i32), 2147483647i32);
  }#block(2):text["filename"] else {#block(3):text["filename"]
    filename(0);
  }#block(3):text["filename"]);
  OpSetText(self(0), 8i32, _tp_File_content(file(filename(0), __ref_1(1)), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]));
  OpSetInt(self(0), 12i32, OpMinSingleInt(1i32));
  OpSetInt(self(0), 16i32, OpMinSingleInt(1i32));
  OpSetInt(self(0), 20i32, OpMinSingleInt(1i32));
  OpFreeRef(__ref_1(1));
  OpFreeText(__work_1(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse(self: ref(Lexer)[4], filename: text[16]) [1512]
   0[32]: return-address
   0[36]: ConvRefFromNull() -> ref(reference) var=__ref_1[36]:ref(File)
   1[48]: Text() var=__work_1[48]:text
   2[72]: ArgText(var[16]) -> text var=filename[16]:text
   5[88]: ConstText(_value="/") -> text
   8[104]: StaticCall(_tp_text_rfind)
  11[76]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  14[88]: VarInt(var[72]) -> integer var=v[72]:integer
  17[92]: ConvBoolFromInt(v1: integer) -> boolean
  18[89]: GotoFalseWord(jump=42, if_false: boolean)
  21[88]: ArgText(var[16]) -> text var=filename[16]:text
  24[104]: VarInt(var[72]) -> integer var=v[72]:integer
  27[108]: ConstInt(val=1) -> integer
  32[112]: AddInt(v1: integer, v2: integer) -> integer
  33[108]: ConstInt(val=2147483647) -> integer
  38[112]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  39[104]: GotoWord(jump=45)
  42[88]: ArgText(var[16]) -> text var=filename[16]:text
  45[104]: SetText(v1: ref(reference), fld=4, val: text)
  48[76]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  51[88]: ArgText(var[16]) -> text var=filename[16]:text
  54[104]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
  57[116]: Call(size=0, to=723)
  64[100]: CreateRef(var[48]) -> ref(reference)
  67[112]: Call(size=0, to=414)
  74[104]: SetText(v1: ref(reference), fld=8, val: text)
  77[76]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  80[88]: ConstInt(val=1) -> integer
  85[92]: MinSingleInt(v1: integer) -> integer
  86[92]: SetInt(v1: ref(reference), fld=12, val: integer)
  89[76]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  92[88]: ConstInt(val=1) -> integer
  97[92]: MinSingleInt(v1: integer) -> integer
  98[92]: SetInt(v1: ref(reference), fld=16, val: integer)
 101[76]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
 104[88]: ConstInt(val=1) -> integer
 109[92]: MinSingleInt(v1: integer) -> integer
 110[92]: SetInt(v1: ref(reference), fld=20, val: integer)
 113[76]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
 116[88]: FreeRef(v1: ref(reference))
 117[76]: FreeText(var[48])
 120[76]: Return(ret=28, value=0, discard=72)

fn _tp_Lexer_parse_string(self:Lexer, name:text, content:text) {#block(1):void
  OpSetText(self(0), 4i32, name(0));
  OpSetText(self(0), 8i32, content(0));
  OpSetInt(self(0), 12i32, OpMinSingleInt(1i32));
  OpSetInt(self(0), 16i32, OpMinSingleInt(1i32));
  OpSetInt(self(0), 20i32, OpMinSingleInt(1i32));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse_string(self: ref(Lexer)[4], name: text[16], content: text[32]) [1638]
   0[48]: return-address
   0[52]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[64]: ArgText(var[16]) -> text var=name[16]:text
   6[80]: SetText(v1: ref(reference), fld=4, val: text)
   9[52]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  12[64]: ArgText(var[32]) -> text var=content[32]:text
  15[80]: SetText(v1: ref(reference), fld=8, val: text)
  18[52]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  21[64]: ConstInt(val=1) -> integer
  26[68]: MinSingleInt(v1: integer) -> integer
  27[68]: SetInt(v1: ref(reference), fld=12, val: integer)
  30[52]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  33[64]: ConstInt(val=1) -> integer
  38[68]: MinSingleInt(v1: integer) -> integer
  39[68]: SetInt(v1: ref(reference), fld=16, val: integer)
  42[52]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  45[64]: ConstInt(val=1) -> integer
  50[68]: MinSingleInt(v1: integer) -> integer
  51[68]: SetInt(v1: ref(reference), fld=20, val: integer)
  54[52]: Return(ret=44, value=0, discard=48)

fn _tp_Lexer_skip_whitespace(self:Lexer) 

byte-code for lib/lexer.lav:_tp_Lexer_skip_whitespace(self: ref(Lexer)[4]) [1698]
   0[16]: return-address

fn _tp_Lexer_test(self:Lexer, with:text) -> boolean {#block(1):boolean
  _tp_Lexer_skip_whitespace(self(0));
  false;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_test(self: ref(Lexer)[4], with: text[16]) [1698] -> boolean
   0[32]: return-address
   0[36]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[48]: Call(size=0, to=1698)
  10[36]: ConstFalse() -> boolean
  11[37]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_match(self:Lexer, with:text) -> boolean {#block(1):boolean
  if _tp_Lexer_test(self(0), with(0)) {#block(2):boolean
    OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), _tp_text_len(with(0))));
    OpSetByte(self(0), 38i32, 0i32, if false 1i32 else 0i32);
    OpSetText(self(0), 32i32, "");
    true;
  }#block(2):boolean else {#block(3):boolean
    false;
  }#block(3):boolean;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_match(self: ref(Lexer)[4], with: text[16]) [1715] -> boolean
   0[32]: return-address
   0[36]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[48]: ArgText(var[16]) -> text var=with[16]:text
   6[64]: Call(size=0, to=1698)
  13[37]: GotoFalseWord(jump=76, if_false: boolean)
  16[36]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  19[48]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  22[60]: GetInt(v1: ref(reference), fld=20) -> integer
  25[52]: ArgText(var[16]) -> text var=with[16]:text
  28[68]: Call(size=0, to=318)
  35[56]: AddInt(v1: integer, v2: integer) -> integer
  36[52]: SetInt(v1: ref(reference), fld=20, val: integer)
  39[36]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  42[48]: ConstFalse() -> boolean
  43[49]: GotoFalseWord(jump=54, if_false: boolean)
  46[48]: ConstInt(val=1) -> integer
  51[52]: GotoWord(jump=59)
  54[48]: ConstInt(val=0) -> integer
  59[52]: SetByte(v1: ref(reference), fld=38, min=0, val: integer)
  64[36]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  67[48]: ConstText(_value="") -> text
  69[64]: SetText(v1: ref(reference), fld=32, val: text)
  72[36]: ConstTrue() -> boolean
  73[37]: GotoWord(jump=77)
  76[36]: ConstFalse() -> boolean
  77[37]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_peek(self:Lexer) -> text {#block(1):text
  "";
}#block(1):text

byte-code for lib/lexer.lav:_tp_Lexer_peek(self: ref(Lexer)[4]) [1798] -> text
   0[16]: return-address
   0[20]: ConstText(_value="") -> text
   2[36]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_position(self:Lexer) -> text {#block(1):text
  __work_1(1):text = "";
  {#Formatted string(2):text
    __work_1(1):text = "";
    OpFormatText(__work_1(1), OpGetText(self(0), 4i32), 0i32, -1i32, 32i32);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 16i32), 10i32, 0i32, 32i32, false, false);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 20i32), 10i32, 0i32, 32i32, false, false);
    __work_1(1);
  }#Formatted string(2):text;
}#block(1):text

byte-code for lib/lexer.lav:_tp_Lexer_position(self: ref(Lexer)[4]) [1806] -> text
   0[16]: return-address
   0[20]: Text() var=__work_1[20]:text
   1[44]: ClearText(var[20]) var=__work_1[20]:text
   4[44]: ConstText(_value="") -> text
   6[60]: AppendText(var[20], v1: text)
   9[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  12[56]: GetText(v1: ref(reference), fld=4) -> text["self"]
  15[60]: ConstInt(val=0) -> integer
  20[64]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
  25[44]: ConstText(_value=":") -> text
  28[60]: AppendText(var[20], v1: text)
  31[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  34[56]: GetInt(v1: ref(reference), fld=16) -> integer
  37[48]: ConstInt(val=0) -> integer
  42[52]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  49[44]: ConstText(_value=":") -> text
  52[60]: AppendText(var[20], v1: text)
  55[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  58[56]: GetInt(v1: ref(reference), fld=20) -> integer
  61[48]: ConstInt(val=0) -> integer
  66[52]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  73[44]: VarText(var[20]) -> text var=__work_1[20]:text
  76[60]: Return(ret=12, value=16, discard=56) type=text[4]:Base[5]

fn _tp_Lexer_identifier(self:Lexer) -> text 

byte-code for lib/lexer.lav:_tp_Lexer_identifier(self: ref(Lexer)[4]) [1888] -> text
   0[16]: return-address

fn _tp_Lexer_int(self:Lexer) -> integer {#block(1):integer
  0i32;
}#block(1):integer

byte-code for lib/lexer.lav:_tp_Lexer_int(self: ref(Lexer)[4]) [1888] -> integer
   0[16]: return-address
   0[20]: ConstInt(val=0) -> integer
   5[24]: Return(ret=12, value=4, discard=20) type=integer[4]:Base[0]

fn _tp_Lexer_long_int(self:Lexer) -> long 

byte-code for lib/lexer.lav:_tp_Lexer_long_int(self: ref(Lexer)[4]) [1899] -> long
   0[16]: return-address

fn _tp_Lexer_long_float(self:Lexer) -> float 

byte-code for lib/lexer.lav:_tp_Lexer_long_float(self: ref(Lexer)[4]) [1899] -> float
   0[16]: return-address

fn _tp_Lexer_single_float(self:Lexer) -> single 

byte-code for lib/lexer.lav:_tp_Lexer_single_float(self: ref(Lexer)[4]) [1899] -> single
   0[16]: return-address

fn _tp_Lexer_constant_string(self:Lexer) -> text 

byte-code for lib/lexer.lav:_tp_Lexer_constant_string(self: ref(Lexer)[4]) [1899] -> text
   0[16]: return-address

fn _tp_Lexer_string_finished(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 37i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_string_finished(self: ref(Lexer)[4]) [1899] -> boolean
   0[16]: return-address
   0[20]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[32]: GetByte(v1: ref(reference), fld=37, min=0) -> integer
   8[24]: ConstInt(val=1) -> integer
  13[28]: EqInt(v1: integer, v2: integer) -> boolean
  14[21]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_last_comment(self:Lexer) -> text["self"] {#block(1):text["self"]
  OpGetText(self(0), 32i32);
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_last_comment(self: ref(Lexer)[4]) [1919] -> text["self"]
   0[16]: return-address
   0[20]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[32]: GetText(v1: ref(reference), fld=32) -> text["self"]
   6[36]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_comment_behind(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 38i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_comment_behind(self: ref(Lexer)[4]) [1931] -> boolean
   0[16]: return-address
   0[20]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[32]: GetByte(v1: ref(reference), fld=38, min=0) -> integer
   8[24]: ConstInt(val=1) -> integer
  13[28]: EqInt(v1: integer, v2: integer) -> boolean
  14[21]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_anchor(self:Lexer) -> Anchor {#block(1):ref(Anchor)
  __ref_1(1):ref(Anchor) = null;
  {#Object(2):ref(Anchor)["__ref_1"]
    OpDatabase(__ref_1(1), 24i32);
    OpSetInt(__ref_1(1), 4i32, OpGetInt(self(0), 12i32));
    OpSetInt(__ref_1(1), 8i32, OpGetInt(self(0), 16i32));
    OpSetInt(__ref_1(1), 12i32, OpGetInt(self(0), 20i32));
    __ref_1(1);
  }#Object(2):ref(Anchor)["__ref_1"];
}#block(1):ref(Anchor)

byte-code for lib/lexer.lav:_tp_Lexer_anchor(self: ref(Lexer)[4]) [1951] -> ref(Anchor)
   0[16]: return-address
   0[20]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(Anchor)
   1[32]: Database(var[20], db_tp=24) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24]
   6[32]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=__ref_1[20]:ref(Anchor)
   9[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  12[56]: GetInt(v1: ref(reference), fld=12) -> integer
  15[48]: SetInt(v1: ref(reference), fld=4, val: integer)
  18[32]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=__ref_1[20]:ref(Anchor)
  21[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  24[56]: GetInt(v1: ref(reference), fld=16) -> integer
  27[48]: SetInt(v1: ref(reference), fld=8, val: integer)
  30[32]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=__ref_1[20]:ref(Anchor)
  33[44]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  36[56]: GetInt(v1: ref(reference), fld=20) -> integer
  39[48]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[32]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=__ref_1[20]:ref(Anchor)
  45[44]: Return(ret=12, value=12, discard=40) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24]

fn _tp_Lexer_revert(self:Lexer, to:Anchor) {#block(1):void
  OpSetInt(self(0), 12i32, OpGetInt(to(0), 4i32));
  OpSetInt(self(0), 16i32, OpGetInt(to(0), 8i32));
  OpSetInt(self(0), 20i32, OpGetInt(to(0), 12i32));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_revert(self: ref(Lexer)[4], to: ref(Anchor)[16]) [2002]
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
   3[44]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=to[16]:ref(Anchor)
   6[56]: GetInt(v1: ref(reference), fld=4) -> integer
   9[48]: SetInt(v1: ref(reference), fld=12, val: integer)
  12[32]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  15[44]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=to[16]:ref(Anchor)
  18[56]: GetInt(v1: ref(reference), fld=8) -> integer
  21[48]: SetInt(v1: ref(reference), fld=16, val: integer)
  24[32]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=self[4]:ref(Lexer)
  27[44]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[24] var=to[16]:ref(Anchor)
  30[56]: GetInt(v1: ref(reference), fld=12) -> integer
  33[48]: SetInt(v1: ref(reference), fld=20, val: integer)
  36[32]: Return(ret=24, value=0, discard=28)

fn testing(l:Lexer) {#block(1):void
  __work_2(1):text = "";
  __work_1(1):text = "";
  if OpEqInt(_tp_Lexer_int(l(0)), 12i32) null else OpPanic("Integer");
  if OpNot(_tp_Lexer_match(l(0), "+")) null else OpPanic("Incorrect plus");
  if OpNeText(_tp_Lexer_peek(l(0)), "+") null else OpPanic("Incorrect plus");
  if _tp_Lexer_match(l(0), "+=") null else OpPanic("Incorrect plus_is");
  if OpEqInt(_tp_Lexer_int(l(0)), OpMinSingleInt(2i32)) null else OpPanic("Integer");
  if _tp_Lexer_match(l(0), "*") null else OpPanic("Incorrect multi");
  if OpNeInt(_tp_Lexer_int(l(0)), 3i32) null else OpPanic("Incorrect integer");
  if OpEqLong(_tp_Lexer_long_int(l(0)), OpConvLongFromInt(3i32)) null else OpPanic("Incorrect long");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:14") null else OpPanic({#Formatted string(2):text
    __work_1(1):text = "Incorrect position ";
    OpFormatText(__work_1(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_1(1);
  }#Formatted string(2):text);
  if OpNot(_tp_Lexer_match(l(0), ">")) null else OpPanic("Incorrect higher");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:15") null else OpPanic({#Formatted string(3):text
    __work_2(1):text = "Incorrect position ";
    OpFormatText(__work_2(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_2(1);
  }#Formatted string(3):text);
  if _tp_Lexer_match(l(0), ">>") null else OpPanic("Incorrect logical shift");
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:testing(l: ref(Lexer)[4]) [2044]
   0[16]: return-address
   0[20]: Text() var=__work_2[20]:text
   1[44]: Text() var=__work_1[44]:text
   2[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
   5[80]: Call(size=0, to=1888)
  12[72]: ConstInt(val=12) -> integer
  17[76]: EqInt(v1: integer, v2: integer) -> boolean
  18[69]: GotoFalseWord(jump=24, if_false: boolean)
  21[68]: GotoWord(jump=34)
  24[68]: ConstText(_value="Integer") -> text
  33[84]: Panic(message: text)
  34[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
  37[80]: ConstText(_value="+") -> text
  40[96]: Call(size=0, to=1715)
  47[69]: Not(v1: boolean) -> boolean
  48[69]: GotoFalseWord(jump=54, if_false: boolean)
  51[68]: GotoWord(jump=71)
  54[68]: ConstText(_value="Incorrect plus") -> text
  70[84]: Panic(message: text)
  71[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
  74[80]: Call(size=0, to=1798)
  81[84]: ConstText(_value="+") -> text
  84[100]: NeText(v1: text, v2: text) -> boolean
  85[69]: GotoFalseWord(jump=91, if_false: boolean)
  88[68]: GotoWord(jump=108)
  91[68]: ConstText(_value="Incorrect plus") -> text
 107[84]: Panic(message: text)
 108[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 111[80]: ConstText(_value="+=") -> text
 115[96]: Call(size=0, to=1715)
 122[69]: GotoFalseWord(jump=128, if_false: boolean)
 125[68]: GotoWord(jump=148)
 128[68]: ConstText(_value="Incorrect plus_is") -> text
 147[84]: Panic(message: text)
 148[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 151[80]: Call(size=0, to=1888)
 158[72]: ConstInt(val=2) -> integer
 163[76]: MinSingleInt(v1: integer) -> integer
 164[76]: EqInt(v1: integer, v2: integer) -> boolean
 165[69]: GotoFalseWord(jump=171, if_false: boolean)
 168[68]: GotoWord(jump=181)
 171[68]: ConstText(_value="Integer") -> text
 180[84]: Panic(message: text)
 181[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 184[80]: ConstText(_value="*") -> text
 187[96]: Call(size=0, to=1715)
 194[69]: GotoFalseWord(jump=200, if_false: boolean)
 197[68]: GotoWord(jump=218)
 200[68]: ConstText(_value="Incorrect multi") -> text
 217[84]: Panic(message: text)
 218[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 221[80]: Call(size=0, to=1888)
 228[72]: ConstInt(val=3) -> integer
 233[76]: NeInt(v1: integer, v2: integer) -> boolean
 234[69]: GotoFalseWord(jump=240, if_false: boolean)
 237[68]: GotoWord(jump=260)
 240[68]: ConstText(_value="Incorrect integer") -> text
 259[84]: Panic(message: text)
 260[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 263[80]: Call(size=0, to=1899)
 270[76]: ConstInt(val=3) -> integer
 275[80]: ConvLongFromInt(v1: integer) -> long
 276[84]: EqLong(v1: long, v2: long) -> boolean
 277[69]: GotoFalseWord(jump=283, if_false: boolean)
 280[68]: GotoWord(jump=300)
 283[68]: ConstText(_value="Incorrect long") -> text
 299[84]: Panic(message: text)
 300[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 303[80]: Call(size=0, to=1806)
 310[84]: ConstText(_value="Tokens:1:14") -> text
 323[100]: EqText(v1: text, v2: text) -> boolean
 324[69]: GotoFalseWord(jump=330, if_false: boolean)
 327[68]: GotoWord(jump=381)
 330[68]: ClearText(var[44]) var=__work_1[44]:text
 333[68]: ConstText(_value="Incorrect position ") -> text
 354[84]: AppendText(var[44], v1: text)
 357[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 360[80]: Call(size=0, to=1806)
 367[84]: ConstInt(val=0) -> integer
 372[88]: FormatText(var[44], val: text, width: integer, dir=-1, token=32)
 377[68]: VarText(var[44]) -> text var=__work_1[44]:text
 380[84]: Panic(message: text)
 381[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 384[80]: ConstText(_value=">") -> text
 387[96]: Call(size=0, to=1715)
 394[69]: Not(v1: boolean) -> boolean
 395[69]: GotoFalseWord(jump=401, if_false: boolean)
 398[68]: GotoWord(jump=420)
 401[68]: ConstText(_value="Incorrect higher") -> text
 419[84]: Panic(message: text)
 420[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 423[80]: Call(size=0, to=1806)
 430[84]: ConstText(_value="Tokens:1:15") -> text
 443[100]: EqText(v1: text, v2: text) -> boolean
 444[69]: GotoFalseWord(jump=450, if_false: boolean)
 447[68]: GotoWord(jump=501)
 450[68]: ClearText(var[20]) var=__work_2[20]:text
 453[68]: ConstText(_value="Incorrect position ") -> text
 474[84]: AppendText(var[20], v1: text)
 477[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 480[80]: Call(size=0, to=1806)
 487[84]: ConstInt(val=0) -> integer
 492[88]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
 497[68]: VarText(var[20]) -> text var=__work_2[20]:text
 500[84]: Panic(message: text)
 501[68]: VarRef(var[4]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[4]:ref(Lexer)
 504[80]: ConstText(_value=">>") -> text
 508[96]: Call(size=0, to=1715)
 515[69]: GotoFalseWord(jump=521, if_false: boolean)
 518[68]: GotoWord(jump=547)
 521[68]: ConstText(_value="Incorrect logical shift") -> text
 546[84]: Panic(message: text)
 547[68]: FreeText(var[44])
 550[68]: FreeText(var[20])
 553[68]: Return(ret=12, value=0, discard=64)

fn main() {#block(1):void
  __ref_1(1):ref(main_vector<text>) = null;
  l(1):ref(Lexer) = null;
  OpDatabase(l(1), 21i32);
  OpSetText(l(1), 4i32, "");
  OpSetText(l(1), 8i32, "");
  OpSetInt(l(1), 12i32, 0i32);
  OpSetInt(l(1), 16i32, 0i32);
  OpSetInt(l(1), 20i32, 0i32);
  OpSetByte(l(1), 36i32, 0i32, if false 1i32 else 0i32);
  OpSetByte(l(1), 37i32, 0i32, if false 1i32 else 0i32);
  OpSetInt(l(1), 24i32, 0i32);
  OpSetInt(l(1), 28i32, 0i32);
  OpSetByte(l(1), 38i32, 0i32, if false 1i32 else 0i32);
  OpSetText(l(1), 32i32, "");
  _tp_Lexer_set_tokens(l(1), {#Vector(2):vector<text>
    OpDatabase(__ref_1(1), 14i32);
    _vec_1(2):vector<text>["__ref_1"] = OpGetField(__ref_1(1), 4i32, 7i32);
    OpSetInt(__ref_1(1), 4i32, 0i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "+=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "*=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "-=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<<");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _vec_1(2);
  }#Vector(2):vector<text>);
  _tp_Lexer_parse_string(l(1), "Tokens", "12 += -2 * 3l >> 4");
  OpFreeRef(l(1));
  OpFreeRef(__ref_1(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:main() [2603]
   0[4]: return-address
   0[8]: ConvRefFromNull() -> ref(reference) var=__ref_1[8]:ref(main_vector<text>)
   1[20]: ConvRefFromNull() -> ref(reference) var=l[20]:ref(Lexer)
   2[32]: Database(var[20], db_tp=21) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21]
   7[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  10[44]: ConstText(_value="") -> text
  12[60]: SetText(v1: ref(reference), fld=4, val: text)
  15[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  18[44]: ConstText(_value="") -> text
  20[60]: SetText(v1: ref(reference), fld=8, val: text)
  23[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  26[44]: ConstInt(val=0) -> integer
  31[48]: SetInt(v1: ref(reference), fld=12, val: integer)
  34[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  37[44]: ConstInt(val=0) -> integer
  42[48]: SetInt(v1: ref(reference), fld=16, val: integer)
  45[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  48[44]: ConstInt(val=0) -> integer
  53[48]: SetInt(v1: ref(reference), fld=20, val: integer)
  56[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  59[44]: ConstFalse() -> boolean
  60[45]: GotoFalseWord(jump=71, if_false: boolean)
  63[44]: ConstInt(val=1) -> integer
  68[48]: GotoWord(jump=76)
  71[44]: ConstInt(val=0) -> integer
  76[48]: SetByte(v1: ref(reference), fld=36, min=0, val: integer)
  81[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
  84[44]: ConstFalse() -> boolean
  85[45]: GotoFalseWord(jump=96, if_false: boolean)
  88[44]: ConstInt(val=1) -> integer
  93[48]: GotoWord(jump=101)
  96[44]: ConstInt(val=0) -> integer
 101[48]: SetByte(v1: ref(reference), fld=37, min=0, val: integer)
 106[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 109[44]: ConstInt(val=0) -> integer
 114[48]: SetInt(v1: ref(reference), fld=24, val: integer)
 117[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 120[44]: ConstInt(val=0) -> integer
 125[48]: SetInt(v1: ref(reference), fld=28, val: integer)
 128[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 131[44]: ConstFalse() -> boolean
 132[45]: GotoFalseWord(jump=143, if_false: boolean)
 135[44]: ConstInt(val=1) -> integer
 140[48]: GotoWord(jump=148)
 143[44]: ConstInt(val=0) -> integer
 148[48]: SetByte(v1: ref(reference), fld=38, min=0, val: integer)
 153[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 156[44]: ConstText(_value="") -> text
 158[60]: SetText(v1: ref(reference), fld=32, val: text)
 161[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 164[44]: Database(var[8], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 169[44]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 172[56]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 175[56]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 178[68]: ConstInt(val=0) -> integer
 183[72]: SetInt(v1: ref(reference), fld=4, val: integer)
 186[56]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 189[68]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 194[68]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 197[80]: ConstText(_value="+=") -> text
 201[96]: SetText(v1: ref(reference), fld=0, val: text)
 204[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 207[80]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 210[92]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 215[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 218[80]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 223[80]: PutRef(var[56], value: ref(reference))
 226[68]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 229[80]: ConstText(_value="*=") -> text
 233[96]: SetText(v1: ref(reference), fld=0, val: text)
 236[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 239[80]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 242[92]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 247[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 250[80]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 255[80]: PutRef(var[56], value: ref(reference))
 258[68]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 261[80]: ConstText(_value="-=") -> text
 265[96]: SetText(v1: ref(reference), fld=0, val: text)
 268[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 271[80]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 274[92]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 279[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 282[80]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 287[80]: PutRef(var[56], value: ref(reference))
 290[68]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 293[80]: ConstText(_value=">>") -> text
 297[96]: SetText(v1: ref(reference), fld=0, val: text)
 300[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 303[80]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 306[92]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 311[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 314[80]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 319[80]: PutRef(var[56], value: ref(reference))
 322[68]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 325[80]: ConstText(_value="<<") -> text
 329[96]: SetText(v1: ref(reference), fld=0, val: text)
 332[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 335[80]: VarRef(var[56]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[56]:ref(boolean)["_vec_1"]
 338[92]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 343[68]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[44]:vector<text>["__ref_1"]
 346[80]: FreeStack(value=12, discard=36)
 350[56]: Call(size=0, to=1222)
 357[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 360[44]: ConstText(_value="Tokens") -> text
 368[60]: ConstText(_value="12 += -2 * 3l >> 4") -> text
 388[76]: Call(size=0, to=1638)
 395[32]: VarRef(var[20]) -> ref(reference) type=Lexer[39]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], string:boolean[36], finished:boolean[37], keywords:hash<Keyword[name]>[24], tokens:hash<Token[start]>[28], behind:boolean[38], comment:text[32]}[21] var=l[20]:ref(Lexer)
 398[44]: FreeRef(v1: ref(reference))
 399[32]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[8]:ref(main_vector<text>)
 402[44]: FreeRef(v1: ref(reference))
 403[32]: Return(ret=0, value=0, discard=28)

