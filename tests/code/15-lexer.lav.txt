Type 17:Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])

Type 18:SKeyword[8]:
    name:text[4]

Type 19:Possible[8]:
    length:integer[0]
    token:text[4]

Type 20:SToken[12]:
    start:character[4]
    possible:sorted<Possible[-length,token]>[8]

Type 21:sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ]

Type 22:Lexer[44]:
    file:text[4]
    data:text[8]
    index:integer[12]
    line:integer[16]
    pos:integer[20]
    start:integer[24]
    scanned:Scanned[40]
    string:boolean[41]
    finished:boolean[42]
    keywords:hash<SKeyword[name]>[28]
    tokens:hash<SToken[start]>[32]
    behind:boolean[43]
    comment:text[36]

Type 23:hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ]

Type 24:hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ]

Type 25:Anchor[16]:
    index:integer[4]
    line:integer[8]
    pos:integer[12]

Type 26:vector<SKeyword>[4]:Vector(18)

Type 27:vector<Possible>[4]:Vector(19)

Type 28:vector<SToken>[4]:Vector(20)

fn _tp_Lexer_set_keywords(self:Lexer, keywords:vector<text>) {#block(1):void
  [49] OpGetField(self(0), 28i32, 23i32);
  [50] {#For block(2):void
    _vector_1(2):vector<text>["keywords"] = keywords(0);
    k#index(2):integer = -1i32;
    loop {#For loop_3
      k(3):text["_vector_1"] = {#iter next(4):text
        k#index(2):integer = OpAddInt(k#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, k#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(k(3))) {#break(5):void
        OpFreeText(k(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        [51] _elm_2(6):ref(SKeyword)["self"] = OpNewRecord(self(0), 22i32, 9i32);
        OpSetText(_elm_2(6), 4i32, k(3));
        OpFinishRecord(self(0), _elm_2(6), 22i32, 9i32);
      }#block(6):void;
      OpFreeText(k(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_keywords(self: ref(Lexer)[0], keywords: vector<text>[12])
   0[24]: return-address
   0[28]: [49] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
   6[40]: [50] VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=keywords[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=k#index[56]:integer
  14[56]: Text() var=k[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=k#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["keywords"]
  30[92]: VarInt(var[56]) -> integer var=k#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=102)
  60[80]: [51] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  63[92]: NewRecord(data: ref(reference), parent_tp=22, fld=9) -> ref(reference)
  68[92]: VarRef(var[84]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(SKeyword)["self"]
  71[104]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  74[120]: SetText(v1: ref(reference), fld=4, val: text)
  77[92]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[104]: VarRef(var[84]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(SKeyword)["self"]
  83[116]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=9)
  88[92]: FreeStack(value=0, discard=12)
  92[80]: FreeText(var[60])
  95[80]: FreeStack(value=0, discard=24)
  99[56]: GotoWord(jump=14)
 102[56]: FreeStack(value=0, discard=16)
 106[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_set_tokens(self:Lexer, tokens:vector<text>) {#block(1):void
  [57] OpGetField(self(0), 32i32, 24i32);
  [58] {#For block(2):void
    _vector_1(2):vector<text>["tokens"] = tokens(0);
    t#index(2):integer = -1i32;
    loop {#For loop_3
      t(3):text["_vector_1"] = {#iter next(4):text
        t#index(2):integer = OpAddInt(t#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, t#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(t(3))) {#break(5):void
        OpFreeText(t(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        [59] f(6):character = OpTextCharacter(t(3), 0i32);
        [60] if OpNot(OpConvBoolFromCharacter(f(6))) {#block(7):void
          [61] OpFreeText(t(3));
          continue(0);
        }#block(7):void else null;
        [63] if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6))) {#block(8):void
          [64] _elm_2(8):ref(Possible)["self"] = OpNewRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), 20i32, 1i32);
          OpSetInt(_elm_2(8), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_2(8), 4i32, t(3));
          OpFinishRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), _elm_2(8), 20i32, 1i32);
        }#block(8):void else {#block(9):void
          [66] _elm_3(9):ref(SToken)["self"] = OpNewRecord(self(0), 22i32, 10i32);
          OpSetInt(_elm_3(9), 4i32, f(6));
          OpSetInt(_elm_3(9), 8i32, 0i32);
          _elm_4(9):ref(Possible)["_elm_3"] = OpNewRecord(_elm_3(9), 20i32, 1i32);
          OpSetInt(_elm_4(9), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_4(9), 4i32, t(3));
          OpFinishRecord(_elm_3(9), _elm_4(9), 20i32, 1i32);
          OpFinishRecord(self(0), _elm_3(9), 22i32, 10i32);
        }#block(9):void;
      }#block(6):void;
      OpFreeText(t(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_tokens(self: ref(Lexer)[0], tokens: vector<text>[12])
   0[24]: return-address
   0[28]: [57] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
   6[40]: [58] VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=tokens[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=t#index[56]:integer
  14[56]: Text() var=t[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=t#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["tokens"]
  30[92]: VarInt(var[56]) -> integer var=t#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=276)
  60[80]: [59] VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  63[96]: ConstInt(val=0) -> integer
  68[100]: TextCharacter(v1: text, v2: integer) -> character
  69[84]: [60] VarCharacter(var[84]) -> character var=f[84]:character
  72[88]: ConvBoolFromCharacter(v1: character) -> boolean
  73[85]: Not(v1: boolean) -> boolean
  74[85]: GotoFalseWord(jump=87, if_false: boolean)
  77[84]: [61] FreeText(var[60])
  80[84]: FreeStack(value=0, discard=28)
  84[56]: GotoWord(jump=14)
  87[84]: [63] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  90[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
  93[96]: VarCharacter(var[84]) -> character var=f[84]:character
  96[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 100[96]: ConvBoolFromRef(val: ref(reference)) -> boolean
 101[85]: GotoFalseWord(jump=175, if_false: boolean)
 104[84]: [64] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 107[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 110[96]: VarCharacter(var[84]) -> character var=f[84]:character
 113[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 117[96]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 122[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 125[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 128[124]: Call(size=0, call=_tp_text_len[318])
 135[112]: SetInt(v1: ref(reference), fld=0, val: integer)
 138[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 141[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 144[124]: SetText(v1: ref(reference), fld=4, val: text)
 147[96]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 150[108]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 153[108]: VarCharacter(var[84]) -> character var=f[84]:character
 156[112]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 160[108]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 163[120]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 168[96]: FreeStack(value=0, discard=12)
 172[84]: GotoWord(jump=262)
 175[84]: [66] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 178[96]: NewRecord(data: ref(reference), parent_tp=22, fld=10) -> ref(reference)
 183[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 186[108]: VarCharacter(var[84]) -> character var=f[84]:character
 189[112]: SetInt(v1: ref(reference), fld=4, val: integer)
 192[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 195[108]: ConstInt(val=0) -> integer
 200[112]: SetInt(v1: ref(reference), fld=8, val: integer)
 203[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 206[108]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 211[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 214[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 217[136]: Call(size=0, call=_tp_text_len[318])
 224[124]: SetInt(v1: ref(reference), fld=0, val: integer)
 227[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 230[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 233[136]: SetText(v1: ref(reference), fld=4, val: text)
 236[108]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 239[120]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 242[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 247[108]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 250[120]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 253[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=10)
 258[108]: FreeStack(value=0, discard=24)
 262[84]: FreeStack(value=0, discard=4)
 266[80]: FreeText(var[60])
 269[80]: FreeStack(value=0, discard=24)
 273[56]: GotoWord(jump=14)
 276[56]: FreeStack(value=0, discard=16)
 280[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_skip_whitespace(self:Lexer) {#block(1):void
  [73] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), OpMinInt(OpGetInt(self(0), 12i32), OpGetInt(self(0), 24i32))));
  [74] {#For block(2):void
    t#index(2):integer = OpConvIntFromNull();
    loop {#For loop_3
      t(3):integer = {#Iter range(4):integer
        t#index(2):integer = if OpNot(OpConvBoolFromInt(t#index(2))) 0i32 else OpAddInt(t#index(2), 1i32);
        if OpGeInt(t#index(2), 300i32) break(0) else null;
        t#index(2);
      }#Iter range(4):integer;
      {#block(5):void
        [75] if if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(32i32)) true else OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(9i32)) {#block(6):void
          [76] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          [77] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(6):void else if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(7):void
          [79] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          [80] OpSetInt(self(0), 16i32, OpAddInt(OpGetInt(self(0), 16i32), 1i32));
          [81] OpSetInt(self(0), 20i32, 1i32);
        }#block(7):void else if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), 2i32)), "//") {#block(8):void
          [83] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 2i32));
          [84] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
          [85] {#For block(9):void
            c#index(9):integer = OpConvIntFromNull();
            loop {#For loop_10
              c(10):integer = {#Iter range(11):integer
                c#index(9):integer = if OpNot(OpConvBoolFromInt(c#index(9))) 0i32 else OpAddInt(c#index(9), 1i32);
                if OpGeInt(c#index(9), 1000i32) break(0) else null;
                c#index(9);
              }#Iter range(11):integer;
              {#block(12):void
                [86] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(13):void
                  [87] break(0);
                }#block(13):void else null;
                [89] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
                [90] OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
              }#block(12):void;
            }#For loop_10;
          }#For block(9):void;
        }#block(8):void else {#block(14):void
          [93] break(0);
        }#block(14):void;
      }#block(5):void;
    }#For loop_3;
  }#For block(2):void;
  [96] OpSetInt(self(0), 24i32, OpGetInt(self(0), 12i32));
  [97] OpSetEnum(self(0), 40i32, 1u8(17));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_skip_whitespace(self: ref(Lexer)[0])
   0[12]: return-address
   0[16]: [73] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   6[40]: GetInt(v1: ref(reference), fld=20) -> integer
   9[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[44]: GetInt(v1: ref(reference), fld=12) -> integer
  15[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  18[48]: GetInt(v1: ref(reference), fld=24) -> integer
  21[40]: MinInt(v1: integer, v2: integer) -> integer
  22[36]: AddInt(v1: integer, v2: integer) -> integer
  23[32]: SetInt(v1: ref(reference), fld=20, val: integer)
  26[16]: [74] ConvIntFromNull() -> integer var=t#index[20]:integer
  27[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  30[24]: ConvBoolFromInt(v1: integer) -> boolean
  31[21]: Not(v1: boolean) -> boolean
  32[21]: GotoFalseWord(jump=43, if_false: boolean)
  35[20]: ConstInt(val=0) -> integer
  40[24]: GotoWord(jump=52)
  43[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  46[24]: ConstInt(val=1) -> integer
  51[28]: AddInt(v1: integer, v2: integer) -> integer
  52[24]: PutInt(var[20], value: integer)
  55[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  58[24]: ConstInt(val=300) -> integer
  63[28]: GeInt(v1: integer, v2: integer) -> boolean
  64[21]: GotoFalseWord(jump=70, if_false: boolean)
  67[20]: GotoWord(jump=449)
  70[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  73[24]: [75] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  76[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
  79[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  82[52]: GetInt(v1: ref(reference), fld=12) -> integer
  85[44]: TextCharacter(v1: text, v2: integer) -> character
  86[28]: ConvIntFromCharacter(v1: character) -> integer
  87[28]: ConstInt(val=32) -> integer
  92[32]: ConvIntFromCharacter(v1: character) -> integer
  93[32]: EqInt(v1: integer, v2: integer) -> boolean
  94[25]: GotoFalseWord(jump=101, if_false: boolean)
  97[24]: ConstTrue() -> boolean
  98[25]: GotoWord(jump=122)
 101[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 104[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
 107[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 110[52]: GetInt(v1: ref(reference), fld=12) -> integer
 113[44]: TextCharacter(v1: text, v2: integer) -> character
 114[28]: ConvIntFromCharacter(v1: character) -> integer
 115[28]: ConstInt(val=9) -> integer
 120[32]: ConvIntFromCharacter(v1: character) -> integer
 121[32]: EqInt(v1: integer, v2: integer) -> boolean
 122[25]: GotoFalseWord(jump=164, if_false: boolean)
 125[24]: [76] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 128[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 131[48]: GetInt(v1: ref(reference), fld=12) -> integer
 134[40]: ConstInt(val=1) -> integer
 139[44]: AddInt(v1: integer, v2: integer) -> integer
 140[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 143[24]: [77] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 146[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 149[48]: GetInt(v1: ref(reference), fld=20) -> integer
 152[40]: ConstInt(val=1) -> integer
 157[44]: AddInt(v1: integer, v2: integer) -> integer
 158[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 161[24]: GotoWord(jump=442)
 164[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 167[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
 170[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 173[52]: GetInt(v1: ref(reference), fld=12) -> integer
 176[44]: TextCharacter(v1: text, v2: integer) -> character
 177[28]: ConvIntFromCharacter(v1: character) -> integer
 178[28]: ConstInt(val=10) -> integer
 183[32]: ConvIntFromCharacter(v1: character) -> integer
 184[32]: EqInt(v1: integer, v2: integer) -> boolean
 185[25]: GotoFalseWord(jump=238, if_false: boolean)
 188[24]: [79] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 191[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 194[48]: GetInt(v1: ref(reference), fld=12) -> integer
 197[40]: ConstInt(val=1) -> integer
 202[44]: AddInt(v1: integer, v2: integer) -> integer
 203[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 206[24]: [80] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 209[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 212[48]: GetInt(v1: ref(reference), fld=16) -> integer
 215[40]: ConstInt(val=1) -> integer
 220[44]: AddInt(v1: integer, v2: integer) -> integer
 221[40]: SetInt(v1: ref(reference), fld=16, val: integer)
 224[24]: [81] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 227[36]: ConstInt(val=1) -> integer
 232[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 235[24]: GotoWord(jump=442)
 238[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 241[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
 244[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 247[52]: GetInt(v1: ref(reference), fld=12) -> integer
 250[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 253[56]: GetInt(v1: ref(reference), fld=12) -> integer
 256[48]: ConstInt(val=2) -> integer
 261[52]: AddInt(v1: integer, v2: integer) -> integer
 262[48]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 263[40]: ConstText(_value="//") -> text
 267[56]: EqText(v1: text, v2: text) -> boolean
 268[25]: GotoFalseWord(jump=435, if_false: boolean)
 271[24]: [83] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 274[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 277[48]: GetInt(v1: ref(reference), fld=12) -> integer
 280[40]: ConstInt(val=2) -> integer
 285[44]: AddInt(v1: integer, v2: integer) -> integer
 286[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 289[24]: [84] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 292[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 295[48]: GetInt(v1: ref(reference), fld=20) -> integer
 298[40]: ConstInt(val=1) -> integer
 303[44]: AddInt(v1: integer, v2: integer) -> integer
 304[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 307[24]: [85] ConvIntFromNull() -> integer var=c#index[28]:integer
 308[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 311[32]: ConvBoolFromInt(v1: integer) -> boolean
 312[29]: Not(v1: boolean) -> boolean
 313[29]: GotoFalseWord(jump=324, if_false: boolean)
 316[28]: ConstInt(val=0) -> integer
 321[32]: GotoWord(jump=333)
 324[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 327[32]: ConstInt(val=1) -> integer
 332[36]: AddInt(v1: integer, v2: integer) -> integer
 333[32]: PutInt(var[28], value: integer)
 336[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 339[32]: ConstInt(val=1000) -> integer
 344[36]: GeInt(v1: integer, v2: integer) -> boolean
 345[29]: GotoFalseWord(jump=351, if_false: boolean)
 348[28]: GotoWord(jump=428)
 351[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 354[32]: [86] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 357[44]: GetText(v1: ref(reference), fld=8) -> text["self"]
 360[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 363[60]: GetInt(v1: ref(reference), fld=12) -> integer
 366[52]: TextCharacter(v1: text, v2: integer) -> character
 367[36]: ConvIntFromCharacter(v1: character) -> integer
 368[36]: ConstInt(val=10) -> integer
 373[40]: ConvIntFromCharacter(v1: character) -> integer
 374[40]: EqInt(v1: integer, v2: integer) -> boolean
 375[33]: GotoFalseWord(jump=385, if_false: boolean)
 378[32]: [87] FreeStack(value=0, discard=4)
 382[28]: GotoWord(jump=428)
 385[32]: [89] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 388[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 391[56]: GetInt(v1: ref(reference), fld=12) -> integer
 394[48]: ConstInt(val=1) -> integer
 399[52]: AddInt(v1: integer, v2: integer) -> integer
 400[48]: SetInt(v1: ref(reference), fld=12, val: integer)
 403[32]: [90] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 406[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 409[56]: GetInt(v1: ref(reference), fld=20) -> integer
 412[48]: ConstInt(val=1) -> integer
 417[52]: AddInt(v1: integer, v2: integer) -> integer
 418[48]: SetInt(v1: ref(reference), fld=20, val: integer)
 421[32]: FreeStack(value=0, discard=4)
 425[28]: GotoWord(jump=308)
 428[28]: FreeStack(value=0, discard=4)
 432[24]: GotoWord(jump=442)
 435[24]: [93] FreeStack(value=0, discard=4)
 439[20]: GotoWord(jump=449)
 442[24]: FreeStack(value=0, discard=4)
 446[20]: GotoWord(jump=27)
 449[20]: FreeStack(value=0, discard=4)
 453[16]: [96] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 456[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 459[40]: GetInt(v1: ref(reference), fld=12) -> integer
 462[32]: SetInt(v1: ref(reference), fld=24, val: integer)
 465[16]: [97] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 468[28]: ConstEnum(val=1) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 470[29]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 473[16]: Return(ret=12, value=0, discard=16)

fn _tp_Lexer_scan(self:Lexer) {#block(1):void
  [103] _tp_Lexer_skip_whitespace(self(0));
  [104] negative(1):boolean = false;
  [105] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
  [106] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(2):void
    [107] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [108] OpSetEnum(self(0), 40i32, 8u8(17));
    [109] {#For block(3):void
      t#index(3):integer = OpConvIntFromNull();
      loop {#For loop_4
        t(4):integer = {#Iter range(5):integer
          t#index(3):integer = if OpNot(OpConvBoolFromInt(t#index(3))) 0i32 else OpAddInt(t#index(3), 1i32);
          if OpGeInt(t#index(3), 20i32) break(0) else null;
          t#index(3);
        }#Iter range(5):integer;
        {#block(6):void
          [110] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [111] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(7):void
            [112] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [113] return null;
          }#block(7):void else null;
          [115] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(8):void
            [116] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [117] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(39i32)) {#block(9):void
              [118] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(9):void else null;
          }#block(8):void else null;
        }#block(6):void;
      }#For loop_4;
    }#For block(3):void;
  }#block(2):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(10):void
    [123] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [124] OpSetEnum(self(0), 40i32, 6u8(17));
    [125] {#For block(11):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_12
        t(12):integer = {#Iter range(13):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 60000i32) break(0) else null;
          t#index(11);
        }#Iter range(13):integer;
        {#block(14):void
          [126] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [127] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(15):void
            [128] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [129] return null;
          }#block(15):void else null;
          [131] if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(16):void
            [132] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            [133] n(16):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
            [134] if if OpEqInt(OpConvIntFromCharacter(n(16)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(n(16)), OpConvIntFromCharacter(10i32)) {#block(17):void
              [135] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(17):void else null;
          }#block(16):void else null;
        }#block(14):void;
      }#For loop_12;
    }#For block(11):void;
  }#block(10):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(18):void
    [140] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    [141] negative(1):boolean = true;
  }#block(18):void else null;
  [143] if if OpGeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(48i32)) OpLeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(57i32)) else false {#block(19):void
    [144] OpSetEnum(self(0), 40i32, 2u8(17));
    [145] {#For block(20):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_21
        t(12):integer = {#Iter range(22):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 30i32) break(0) else null;
          t#index(11);
        }#Iter range(22):integer;
        {#block(23):void
          [146] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [147] if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(46i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(101i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(24):void
            [148] OpSetEnum(self(0), 40i32, 3u8(17));
          }#block(24):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(108i32)) {#block(25):void
            [150] OpSetEnum(self(0), 40i32, 5u8(17));
          }#block(25):void else if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(120i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(111i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(98i32))  else if if OpNeInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(95i32)) if OpLtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(48i32)) true else OpGtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(57i32)) else false {#block(27):void
            [153] break(0);
          }#block(27):void else null;
          [155] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(23):void;
      }#For loop_21;
    }#For block(20):void;
    [157] return null;
  }#block(19):void else if negative(1) {#block(28):void
    [159] OpSetInt(self(0), 12i32, OpMinInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(28):void else null;
  [161] if _tp_character_is_alphabetic(l(1)) {#block(29):void
    [162] OpSetEnum(self(0), 40i32, 9u8(17));
    [163] {#For block(30):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_31
        t(12):integer = {#Iter range(32):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 300i32) break(0) else null;
          t#index(11);
        }#Iter range(32):integer;
        {#block(33):void
          [164] l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          [165] if OpNot(_tp_character_is_alphanumeric(l(1))) {#block(34):void
            [166] break(0);
          }#block(34):void else null;
          [168] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(33):void;
      }#For loop_31;
    }#For block(30):void;
    [170] return null;
  }#block(29):void else null;
  [173] OpSetEnum(self(0), 40i32, 10u8(17));
  [174] {#For block(35):void
    pt#index(35):integer = OpIterate(OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32, &[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], 0i32, 0i32);
    loop {#For loop_36
      pt(36):ref(Possible)["self"] = OpStep(pt#index(35), OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32);
      if OpNot(OpConvBoolFromRef(pt(36))) {#break(37):void
        break(0);
      }#break(37):void else null;
      {#block(38):void
        [175] tok(38):text["pt"] = OpGetText(pt(36), 4i32);
        [176] if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(38)))), tok(38)) {#block(39):void
          [177] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(38))));
          [178] OpFreeText(tok(38));
          return null;
        }#block(39):void else null;
        OpFreeText(tok(38));
      }#block(38):void;
    }#For loop_36;
  }#For block(35):void;
  [181] OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_scan(self: ref(Lexer)[0])
   0[12]: return-address
   0[16]: [103] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: Call(size=0, call=_tp_Lexer_skip_whitespace[1513])
  10[16]: [104] ConstFalse() -> boolean var=negative[20]:boolean
  11[17]: [105] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
  17[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  20[45]: GetInt(v1: ref(reference), fld=12) -> integer
  23[37]: TextCharacter(v1: text, v2: integer) -> character
  24[21]: [106] VarCharacter(var[21]) -> character var=l[21]:character
  27[25]: ConvIntFromCharacter(v1: character) -> integer
  28[25]: ConstInt(val=39) -> integer
  33[29]: ConvIntFromCharacter(v1: character) -> integer
  34[29]: EqInt(v1: integer, v2: integer) -> boolean
  35[22]: GotoFalseWord(jump=259, if_false: boolean)
  38[21]: [107] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  41[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  44[45]: GetInt(v1: ref(reference), fld=12) -> integer
  47[37]: ConstInt(val=1) -> integer
  52[41]: AddInt(v1: integer, v2: integer) -> integer
  53[37]: SetInt(v1: ref(reference), fld=12, val: integer)
  56[21]: [108] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  59[33]: ConstEnum(val=8) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
  61[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
  64[21]: [109] ConvIntFromNull() -> integer var=t#index[25]:integer
  65[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  68[29]: ConvBoolFromInt(v1: integer) -> boolean
  69[26]: Not(v1: boolean) -> boolean
  70[26]: GotoFalseWord(jump=81, if_false: boolean)
  73[25]: ConstInt(val=0) -> integer
  78[29]: GotoWord(jump=90)
  81[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  84[29]: ConstInt(val=1) -> integer
  89[33]: AddInt(v1: integer, v2: integer) -> integer
  90[29]: PutInt(var[25], value: integer)
  93[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  96[29]: ConstInt(val=20) -> integer
 101[33]: GeInt(v1: integer, v2: integer) -> boolean
 102[26]: GotoFalseWord(jump=108, if_false: boolean)
 105[25]: GotoWord(jump=252)
 108[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 111[29]: [110] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 114[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 117[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 120[57]: GetInt(v1: ref(reference), fld=12) -> integer
 123[49]: TextCharacter(v1: text, v2: integer) -> character
 124[33]: PutCharacter(var[21], value: character)
 127[29]: [111] VarCharacter(var[21]) -> character var=l[21]:character
 130[33]: ConvIntFromCharacter(v1: character) -> integer
 131[33]: ConstInt(val=39) -> integer
 136[37]: ConvIntFromCharacter(v1: character) -> integer
 137[37]: EqInt(v1: integer, v2: integer) -> boolean
 138[30]: GotoFalseWord(jump=171, if_false: boolean)
 141[29]: [112] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 144[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 147[53]: GetInt(v1: ref(reference), fld=12) -> integer
 150[45]: ConstInt(val=1) -> integer
 155[49]: AddInt(v1: integer, v2: integer) -> integer
 156[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 159[29]: [113] Return(ret=12, value=0, discard=29)
 165[29]: Return(ret=12, value=0, discard=29)
 171[29]: [115] VarCharacter(var[21]) -> character var=l[21]:character
 174[33]: ConvIntFromCharacter(v1: character) -> integer
 175[33]: ConstInt(val=92) -> integer
 180[37]: ConvIntFromCharacter(v1: character) -> integer
 181[37]: EqInt(v1: integer, v2: integer) -> boolean
 182[30]: GotoFalseWord(jump=245, if_false: boolean)
 185[29]: [116] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 188[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 191[53]: GetInt(v1: ref(reference), fld=12) -> integer
 194[45]: ConstInt(val=1) -> integer
 199[49]: AddInt(v1: integer, v2: integer) -> integer
 200[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 203[29]: [117] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 206[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 209[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 212[57]: GetInt(v1: ref(reference), fld=12) -> integer
 215[49]: TextCharacter(v1: text, v2: integer) -> character
 216[33]: ConvIntFromCharacter(v1: character) -> integer
 217[33]: ConstInt(val=39) -> integer
 222[37]: ConvIntFromCharacter(v1: character) -> integer
 223[37]: EqInt(v1: integer, v2: integer) -> boolean
 224[30]: GotoFalseWord(jump=245, if_false: boolean)
 227[29]: [118] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 230[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 233[53]: GetInt(v1: ref(reference), fld=12) -> integer
 236[45]: ConstInt(val=1) -> integer
 241[49]: AddInt(v1: integer, v2: integer) -> integer
 242[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 245[29]: FreeStack(value=0, discard=4)
 249[25]: GotoWord(jump=65)
 252[25]: FreeStack(value=0, discard=4)
 256[21]: GotoWord(jump=555)
 259[21]: VarCharacter(var[21]) -> character var=l[21]:character
 262[25]: ConvIntFromCharacter(v1: character) -> integer
 263[25]: ConstInt(val=34) -> integer
 268[29]: ConvIntFromCharacter(v1: character) -> integer
 269[29]: EqInt(v1: integer, v2: integer) -> boolean
 270[22]: GotoFalseWord(jump=519, if_false: boolean)
 273[21]: [123] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 276[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 279[45]: GetInt(v1: ref(reference), fld=12) -> integer
 282[37]: ConstInt(val=1) -> integer
 287[41]: AddInt(v1: integer, v2: integer) -> integer
 288[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 291[21]: [124] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 294[33]: ConstEnum(val=6) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 296[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 299[21]: [125] ConvIntFromNull() -> integer var=t#index[25]:integer
 300[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 303[29]: ConvBoolFromInt(v1: integer) -> boolean
 304[26]: Not(v1: boolean) -> boolean
 305[26]: GotoFalseWord(jump=316, if_false: boolean)
 308[25]: ConstInt(val=0) -> integer
 313[29]: GotoWord(jump=325)
 316[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 319[29]: ConstInt(val=1) -> integer
 324[33]: AddInt(v1: integer, v2: integer) -> integer
 325[29]: PutInt(var[25], value: integer)
 328[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 331[29]: ConstInt(val=60000) -> integer
 336[33]: GeInt(v1: integer, v2: integer) -> boolean
 337[26]: GotoFalseWord(jump=343, if_false: boolean)
 340[25]: GotoWord(jump=512)
 343[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 346[29]: [126] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 349[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 352[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 355[57]: GetInt(v1: ref(reference), fld=12) -> integer
 358[49]: TextCharacter(v1: text, v2: integer) -> character
 359[33]: PutCharacter(var[21], value: character)
 362[29]: [127] VarCharacter(var[21]) -> character var=l[21]:character
 365[33]: ConvIntFromCharacter(v1: character) -> integer
 366[33]: ConstInt(val=34) -> integer
 371[37]: ConvIntFromCharacter(v1: character) -> integer
 372[37]: EqInt(v1: integer, v2: integer) -> boolean
 373[30]: GotoFalseWord(jump=406, if_false: boolean)
 376[29]: [128] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 379[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 382[53]: GetInt(v1: ref(reference), fld=12) -> integer
 385[45]: ConstInt(val=1) -> integer
 390[49]: AddInt(v1: integer, v2: integer) -> integer
 391[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 394[29]: [129] Return(ret=12, value=0, discard=29)
 400[29]: Return(ret=12, value=0, discard=29)
 406[29]: [131] VarCharacter(var[21]) -> character var=l[21]:character
 409[33]: ConvIntFromCharacter(v1: character) -> integer
 410[33]: ConstInt(val=92) -> integer
 415[37]: ConvIntFromCharacter(v1: character) -> integer
 416[37]: EqInt(v1: integer, v2: integer) -> boolean
 417[30]: GotoFalseWord(jump=505, if_false: boolean)
 420[29]: [132] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 423[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 426[53]: GetInt(v1: ref(reference), fld=12) -> integer
 429[45]: ConstInt(val=1) -> integer
 434[49]: AddInt(v1: integer, v2: integer) -> integer
 435[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 438[29]: [133] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 441[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 444[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 447[57]: GetInt(v1: ref(reference), fld=12) -> integer
 450[49]: TextCharacter(v1: text, v2: integer) -> character
 451[33]: [134] VarCharacter(var[33]) -> character var=n[33]:character
 454[37]: ConvIntFromCharacter(v1: character) -> integer
 455[37]: ConstInt(val=34) -> integer
 460[41]: ConvIntFromCharacter(v1: character) -> integer
 461[41]: EqInt(v1: integer, v2: integer) -> boolean
 462[34]: GotoFalseWord(jump=469, if_false: boolean)
 465[33]: ConstTrue() -> boolean
 466[34]: GotoWord(jump=480)
 469[33]: VarCharacter(var[33]) -> character var=n[33]:character
 472[37]: ConvIntFromCharacter(v1: character) -> integer
 473[37]: ConstInt(val=10) -> integer
 478[41]: ConvIntFromCharacter(v1: character) -> integer
 479[41]: EqInt(v1: integer, v2: integer) -> boolean
 480[34]: GotoFalseWord(jump=501, if_false: boolean)
 483[33]: [135] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 486[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 489[57]: GetInt(v1: ref(reference), fld=12) -> integer
 492[49]: ConstInt(val=1) -> integer
 497[53]: AddInt(v1: integer, v2: integer) -> integer
 498[49]: SetInt(v1: ref(reference), fld=12, val: integer)
 501[33]: FreeStack(value=0, discard=4)
 505[29]: FreeStack(value=0, discard=4)
 509[25]: GotoWord(jump=300)
 512[25]: FreeStack(value=0, discard=4)
 516[21]: GotoWord(jump=555)
 519[21]: VarCharacter(var[21]) -> character var=l[21]:character
 522[25]: ConvIntFromCharacter(v1: character) -> integer
 523[25]: ConstInt(val=45) -> integer
 528[29]: ConvIntFromCharacter(v1: character) -> integer
 529[29]: EqInt(v1: integer, v2: integer) -> boolean
 530[22]: GotoFalseWord(jump=555, if_false: boolean)
 533[21]: [140] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 536[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 539[45]: GetInt(v1: ref(reference), fld=12) -> integer
 542[37]: ConstInt(val=1) -> integer
 547[41]: AddInt(v1: integer, v2: integer) -> integer
 548[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 551[21]: [141] ConstTrue() -> boolean var=negative[20]:boolean
 552[22]: PutBool(var=6, value: boolean)
 555[21]: [143] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 558[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 561[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 564[49]: GetInt(v1: ref(reference), fld=12) -> integer
 567[41]: TextCharacter(v1: text, v2: integer) -> character
 568[25]: ConvIntFromCharacter(v1: character) -> integer
 569[25]: ConstInt(val=48) -> integer
 574[29]: ConvIntFromCharacter(v1: character) -> integer
 575[29]: GeInt(v1: integer, v2: integer) -> boolean
 576[22]: GotoFalseWord(jump=603, if_false: boolean)
 579[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 582[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 585[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 588[49]: GetInt(v1: ref(reference), fld=12) -> integer
 591[41]: TextCharacter(v1: text, v2: integer) -> character
 592[25]: ConvIntFromCharacter(v1: character) -> integer
 593[25]: ConstInt(val=57) -> integer
 598[29]: ConvIntFromCharacter(v1: character) -> integer
 599[29]: LeInt(v1: integer, v2: integer) -> boolean
 600[22]: GotoWord(jump=604)
 603[21]: ConstFalse() -> boolean
 604[22]: GotoFalseWord(jump=912, if_false: boolean)
 607[21]: [144] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 610[33]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 612[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 615[21]: [145] ConvIntFromNull() -> integer var=t#index[25]:integer
 616[25]: PutInt(var[25], value: integer)
 619[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 622[25]: ConvBoolFromInt(v1: integer) -> boolean
 623[22]: Not(v1: boolean) -> boolean
 624[22]: GotoFalseWord(jump=635, if_false: boolean)
 627[21]: ConstInt(val=0) -> integer
 632[25]: GotoWord(jump=644)
 635[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 638[25]: ConstInt(val=1) -> integer
 643[29]: AddInt(v1: integer, v2: integer) -> integer
 644[25]: PutInt(var[25], value: integer)
 647[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 650[25]: ConstInt(val=30) -> integer
 655[29]: GeInt(v1: integer, v2: integer) -> boolean
 656[22]: GotoFalseWord(jump=662, if_false: boolean)
 659[21]: GotoWord(jump=897)
 662[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 665[25]: PutInt(var[29], value: integer)
 668[21]: [146] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 671[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 674[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 677[49]: GetInt(v1: ref(reference), fld=12) -> integer
 680[41]: TextCharacter(v1: text, v2: integer) -> character
 681[25]: PutCharacter(var[21], value: character)
 684[21]: [147] VarCharacter(var[21]) -> character var=l[21]:character
 687[25]: ConvIntFromCharacter(v1: character) -> integer
 688[25]: ConstInt(val=46) -> integer
 693[29]: ConvIntFromCharacter(v1: character) -> integer
 694[29]: EqInt(v1: integer, v2: integer) -> boolean
 695[22]: GotoFalseWord(jump=702, if_false: boolean)
 698[21]: ConstTrue() -> boolean
 699[22]: GotoWord(jump=713)
 702[21]: VarCharacter(var[21]) -> character var=l[21]:character
 705[25]: ConvIntFromCharacter(v1: character) -> integer
 706[25]: ConstInt(val=101) -> integer
 711[29]: ConvIntFromCharacter(v1: character) -> integer
 712[29]: EqInt(v1: integer, v2: integer) -> boolean
 713[22]: GotoFalseWord(jump=720, if_false: boolean)
 716[21]: ConstTrue() -> boolean
 717[22]: GotoWord(jump=731)
 720[21]: VarCharacter(var[21]) -> character var=l[21]:character
 723[25]: ConvIntFromCharacter(v1: character) -> integer
 724[25]: ConstInt(val=45) -> integer
 729[29]: ConvIntFromCharacter(v1: character) -> integer
 730[29]: EqInt(v1: integer, v2: integer) -> boolean
 731[22]: GotoFalseWord(jump=745, if_false: boolean)
 734[21]: [148] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 737[33]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 739[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 742[21]: GotoWord(jump=876)
 745[21]: VarCharacter(var[21]) -> character var=l[21]:character
 748[25]: ConvIntFromCharacter(v1: character) -> integer
 749[25]: ConstInt(val=108) -> integer
 754[29]: ConvIntFromCharacter(v1: character) -> integer
 755[29]: EqInt(v1: integer, v2: integer) -> boolean
 756[22]: GotoFalseWord(jump=770, if_false: boolean)
 759[21]: [150] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 762[33]: ConstEnum(val=5) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 764[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 767[21]: GotoWord(jump=876)
 770[21]: VarCharacter(var[21]) -> character var=l[21]:character
 773[25]: ConvIntFromCharacter(v1: character) -> integer
 774[25]: ConstInt(val=120) -> integer
 779[29]: ConvIntFromCharacter(v1: character) -> integer
 780[29]: EqInt(v1: integer, v2: integer) -> boolean
 781[22]: GotoFalseWord(jump=788, if_false: boolean)
 784[21]: ConstTrue() -> boolean
 785[22]: GotoWord(jump=799)
 788[21]: VarCharacter(var[21]) -> character var=l[21]:character
 791[25]: ConvIntFromCharacter(v1: character) -> integer
 792[25]: ConstInt(val=111) -> integer
 797[29]: ConvIntFromCharacter(v1: character) -> integer
 798[29]: EqInt(v1: integer, v2: integer) -> boolean
 799[22]: GotoFalseWord(jump=806, if_false: boolean)
 802[21]: ConstTrue() -> boolean
 803[22]: GotoWord(jump=817)
 806[21]: VarCharacter(var[21]) -> character var=l[21]:character
 809[25]: ConvIntFromCharacter(v1: character) -> integer
 810[25]: ConstInt(val=98) -> integer
 815[29]: ConvIntFromCharacter(v1: character) -> integer
 816[29]: EqInt(v1: integer, v2: integer) -> boolean
 817[22]: GotoFalseWord(jump=823, if_false: boolean)
 820[21]: GotoWord(jump=876)
 823[21]: VarCharacter(var[21]) -> character var=l[21]:character
 826[25]: ConvIntFromCharacter(v1: character) -> integer
 827[25]: ConstInt(val=95) -> integer
 832[29]: ConvIntFromCharacter(v1: character) -> integer
 833[29]: NeInt(v1: integer, v2: integer) -> boolean
 834[22]: GotoFalseWord(jump=869, if_false: boolean)
 837[21]: VarCharacter(var[21]) -> character var=l[21]:character
 840[25]: ConvIntFromCharacter(v1: character) -> integer
 841[25]: ConstInt(val=48) -> integer
 846[29]: ConvIntFromCharacter(v1: character) -> integer
 847[29]: LtInt(v1: integer, v2: integer) -> boolean
 848[22]: GotoFalseWord(jump=855, if_false: boolean)
 851[21]: ConstTrue() -> boolean
 852[22]: GotoWord(jump=866)
 855[21]: VarCharacter(var[21]) -> character var=l[21]:character
 858[25]: ConvIntFromCharacter(v1: character) -> integer
 859[25]: ConstInt(val=57) -> integer
 864[29]: ConvIntFromCharacter(v1: character) -> integer
 865[29]: GtInt(v1: integer, v2: integer) -> boolean
 866[22]: GotoWord(jump=870)
 869[21]: ConstFalse() -> boolean
 870[22]: GotoFalseWord(jump=876, if_false: boolean)
 873[21]: [153] GotoWord(jump=897)
 876[21]: [155] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 879[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 882[45]: GetInt(v1: ref(reference), fld=12) -> integer
 885[37]: ConstInt(val=1) -> integer
 890[41]: AddInt(v1: integer, v2: integer) -> integer
 891[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 894[21]: GotoWord(jump=619)
 897[21]: [157] Return(ret=12, value=0, discard=21)
 903[21]: Return(ret=12, value=0, discard=21)
 909[21]: GotoWord(jump=936)
 912[21]: VarBool(var[20]) -> boolean var=negative[20]:boolean
 915[22]: GotoFalseWord(jump=936, if_false: boolean)
 918[21]: [159] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 921[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 924[45]: GetInt(v1: ref(reference), fld=12) -> integer
 927[37]: ConstInt(val=1) -> integer
 932[41]: MinInt(v1: integer, v2: integer) -> integer
 933[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 936[21]: [161] VarCharacter(var[21]) -> character var=l[21]:character
 939[25]: StaticCall(_tp_character_is_alphabetic)
 942[22]: GotoFalseWord(jump=1068, if_false: boolean)
 945[21]: [162] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 948[33]: ConstEnum(val=9) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 950[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
 953[21]: [163] ConvIntFromNull() -> integer var=t#index[25]:integer
 954[25]: PutInt(var[25], value: integer)
 957[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 960[25]: ConvBoolFromInt(v1: integer) -> boolean
 961[22]: Not(v1: boolean) -> boolean
 962[22]: GotoFalseWord(jump=973, if_false: boolean)
 965[21]: ConstInt(val=0) -> integer
 970[25]: GotoWord(jump=982)
 973[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 976[25]: ConstInt(val=1) -> integer
 981[29]: AddInt(v1: integer, v2: integer) -> integer
 982[25]: PutInt(var[25], value: integer)
 985[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 988[25]: ConstInt(val=300) -> integer
 993[29]: GeInt(v1: integer, v2: integer) -> boolean
 994[22]: GotoFalseWord(jump=1000, if_false: boolean)
 997[21]: GotoWord(jump=1056)
1000[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
1003[25]: PutInt(var[29], value: integer)
1006[21]: [164] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1009[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
1012[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1015[49]: GetInt(v1: ref(reference), fld=12) -> integer
1018[41]: TextCharacter(v1: text, v2: integer) -> character
1019[25]: PutCharacter(var[21], value: character)
1022[21]: [165] VarCharacter(var[21]) -> character var=l[21]:character
1025[25]: StaticCall(_tp_character_is_alphanumeric)
1028[22]: Not(v1: boolean) -> boolean
1029[22]: GotoFalseWord(jump=1035, if_false: boolean)
1032[21]: [166] GotoWord(jump=1056)
1035[21]: [168] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1038[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1041[45]: GetInt(v1: ref(reference), fld=12) -> integer
1044[37]: ConstInt(val=1) -> integer
1049[41]: AddInt(v1: integer, v2: integer) -> integer
1050[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1053[21]: GotoWord(jump=957)
1056[21]: [170] Return(ret=12, value=0, discard=21)
1062[21]: Return(ret=12, value=0, discard=21)
1068[21]: [173] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1071[33]: ConstEnum(val=10) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
1073[34]: SetEnum(v1: ref(reference), fld=40, val: boolean)
1076[21]: [174] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1079[33]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1082[33]: VarCharacter(var[21]) -> character var=l[21]:character
1085[37]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1089[33]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1092[33]: Iterate(data: ref(reference), on=130, arg=8, keys=[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], from_key=0, till_key=0) -> long
1105[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1108[41]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1111[41]: VarCharacter(var[21]) -> character var=l[21]:character
1114[45]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1118[41]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1121[41]: Step(state_var=20, data: ref(reference), on=130, arg=8) -> ref(reference)
1127[41]: VarRef(var[33]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[33]:ref(Possible)["self"]
1130[53]: ConvBoolFromRef(val: ref(reference)) -> boolean
1131[42]: Not(v1: boolean) -> boolean
1132[42]: GotoFalseWord(jump=1142, if_false: boolean)
1135[41]: FreeStack(value=0, discard=12)
1139[29]: GotoWord(jump=1241)
1142[41]: [175] Text() var=tok[45]:text["pt"]
1143[65]: VarRef(var[33]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[33]:ref(Possible)["self"]
1146[77]: GetText(v1: ref(reference), fld=4) -> text["self"]
1149[81]: AppendText(var[45], v1: text)
1152[65]: [176] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1155[77]: GetText(v1: ref(reference), fld=8) -> text["self"]
1158[81]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1161[93]: GetInt(v1: ref(reference), fld=12) -> integer
1164[85]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1167[97]: GetInt(v1: ref(reference), fld=12) -> integer
1170[89]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1173[105]: Call(size=0, call=_tp_text_len[318])
1180[93]: AddInt(v1: integer, v2: integer) -> integer
1181[89]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
1182[81]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1185[97]: EqText(v1: text, v2: text) -> boolean
1186[66]: GotoFalseWord(jump=1227, if_false: boolean)
1189[65]: [177] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1192[77]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1195[89]: GetInt(v1: ref(reference), fld=12) -> integer
1198[81]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1201[97]: Call(size=0, call=_tp_text_len[318])
1208[85]: AddInt(v1: integer, v2: integer) -> integer
1209[81]: SetInt(v1: ref(reference), fld=12, val: integer)
1212[65]: [178] FreeText(var[45])
1215[65]: Return(ret=12, value=0, discard=65)
1221[65]: Return(ret=12, value=0, discard=65)
1227[65]: FreeText(var[45])
1230[65]: FreeStack(value=0, discard=24)
1234[41]: FreeStack(value=0, discard=12)
1238[29]: GotoWord(jump=1105)
1241[29]: FreeStack(value=0, discard=8)
1245[21]: [181] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1248[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1251[45]: GetInt(v1: ref(reference), fld=12) -> integer
1254[37]: ConstInt(val=1) -> integer
1259[41]: AddInt(v1: integer, v2: integer) -> integer
1260[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1263[21]: Return(ret=12, value=0, discard=21)

fn _tp_Lexer_parse(self:Lexer, filename:text) {#block(1):void
  __ref_1(1):ref(File) = null;
  __work_1(1):text = "";
  [186] v(1):integer = _tp_text_rfind(filename(0), "/");
  [187] OpSetText(self(0), 4i32, if OpConvBoolFromInt(v(1)) {#block(2):text["filename"]
    [188] OpGetTextSub(filename(0), OpAddInt(v(1), 1i32), 2147483647i32);
  }#block(2):text["filename"] else {#block(3):text["filename"]
    [190] filename(0);
  }#block(3):text["filename"]);
  [192] OpSetText(self(0), 8i32, _tp_File_content(file(filename(0), __ref_1(1)), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]));
  [193] OpSetInt(self(0), 12i32, 0i32);
  [194] OpSetInt(self(0), 16i32, 1i32);
  [195] OpSetInt(self(0), 20i32, 1i32);
  [196] _tp_Lexer_scan(self(0));
  OpFreeRef(__ref_1(1));
  OpFreeText(__work_1(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse(self: ref(Lexer)[0], filename: text[12])
   0[28]: return-address
   0[32]: ConvRefFromNull() -> ref(reference) var=__ref_1[36]:ref(File)
   1[44]: Text() var=__work_1[48]:text
   2[68]: [186] ArgText(var[16]) -> text var=filename[16]:text
   5[84]: ConstText(_value="/") -> text
   8[100]: StaticCall(_tp_text_rfind)
  11[72]: [187] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[84]: VarInt(var[72]) -> integer var=v[72]:integer
  17[88]: ConvBoolFromInt(v1: integer) -> boolean
  18[85]: GotoFalseWord(jump=42, if_false: boolean)
  21[84]: [188] ArgText(var[16]) -> text var=filename[16]:text
  24[100]: VarInt(var[72]) -> integer var=v[72]:integer
  27[104]: ConstInt(val=1) -> integer
  32[108]: AddInt(v1: integer, v2: integer) -> integer
  33[104]: ConstInt(val=2147483647) -> integer
  38[108]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  39[100]: GotoWord(jump=45)
  42[84]: [190] ArgText(var[16]) -> text var=filename[16]:text
  45[100]: SetText(v1: ref(reference), fld=4, val: text)
  48[72]: [192] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  51[84]: ArgText(var[16]) -> text var=filename[16]:text
  54[100]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
  57[112]: Call(size=0, call=file[736])
  64[96]: CreateRef(var[48]) -> ref(reference)
  67[108]: Call(size=0, call=_tp_File_content[455])
  74[100]: SetText(v1: ref(reference), fld=8, val: text)
  77[72]: [193] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[84]: ConstInt(val=0) -> integer
  85[88]: SetInt(v1: ref(reference), fld=12, val: integer)
  88[72]: [194] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  91[84]: ConstInt(val=1) -> integer
  96[88]: SetInt(v1: ref(reference), fld=16, val: integer)
  99[72]: [195] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 102[84]: ConstInt(val=1) -> integer
 107[88]: SetInt(v1: ref(reference), fld=20, val: integer)
 110[72]: [196] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 113[84]: Call(size=0, call=_tp_Lexer_scan[1992])
 120[72]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
 123[84]: FreeRef(v1: ref(reference))
 124[72]: FreeText(var[48])
 127[72]: Return(ret=28, value=0, discard=72)

fn _tp_Lexer_parse_string(self:Lexer, name:text, content:text) {#block(1):void
  [201] OpSetText(self(0), 4i32, name(0));
  [202] OpSetText(self(0), 8i32, content(0));
  [203] OpSetInt(self(0), 12i32, 0i32);
  [204] OpSetInt(self(0), 16i32, 1i32);
  [205] OpSetInt(self(0), 20i32, 1i32);
  [206] _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse_string(self: ref(Lexer)[0], name: text[12], content: text[28])
   0[44]: return-address
   0[48]: [201] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[60]: ArgText(var[16]) -> text var=name[16]:text
   6[76]: SetText(v1: ref(reference), fld=4, val: text)
   9[48]: [202] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[60]: ArgText(var[32]) -> text var=content[32]:text
  15[76]: SetText(v1: ref(reference), fld=8, val: text)
  18[48]: [203] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  21[60]: ConstInt(val=0) -> integer
  26[64]: SetInt(v1: ref(reference), fld=12, val: integer)
  29[48]: [204] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  32[60]: ConstInt(val=1) -> integer
  37[64]: SetInt(v1: ref(reference), fld=16, val: integer)
  40[48]: [205] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  43[60]: ConstInt(val=1) -> integer
  48[64]: SetInt(v1: ref(reference), fld=20, val: integer)
  51[48]: [206] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  54[60]: Call(size=0, call=_tp_Lexer_scan[1992])
  61[48]: Return(ret=44, value=0, discard=48)

fn _tp_Lexer_test(self:Lexer, with:text) -> boolean {#block(1):boolean
  [211] OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)), with(0));
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_test(self: ref(Lexer)[0], with: text[12]) -> boolean
   0[28]: return-address
   0[32]: [211] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   9[60]: GetInt(v1: ref(reference), fld=24) -> integer
  12[52]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[64]: GetInt(v1: ref(reference), fld=12) -> integer
  18[56]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[48]: ArgText(var[16]) -> text var=with[16]:text
  22[64]: EqText(v1: text, v2: text) -> boolean
  23[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_matches(self:Lexer, with:text) -> boolean {#block(1):boolean
  [216] if _tp_Lexer_test(self(0), with(0)) {#block(2):boolean
    [217] _tp_Lexer_scan(self(0));
    [218] true;
  }#block(2):boolean else {#block(3):boolean
    [220] false;
  }#block(3):boolean;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_matches(self: ref(Lexer)[0], with: text[12]) -> boolean
   0[28]: return-address
   0[32]: [216] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: ArgText(var[16]) -> text var=with[16]:text
   6[60]: Call(size=0, call=_tp_Lexer_test[3461])
  13[33]: GotoFalseWord(jump=30, if_false: boolean)
  16[32]: [217] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  19[44]: Call(size=0, call=_tp_Lexer_scan[1992])
  26[32]: [218] ConstTrue() -> boolean
  27[33]: GotoWord(jump=31)
  30[32]: [220] ConstFalse() -> boolean
  31[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_peek(self:Lexer) -> text["self"] {#block(1):text["self"]
  [227] OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_peek(self: ref(Lexer)[0]) -> text["self"]
   0[12]: return-address
   0[16]: [227] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   9[44]: GetInt(v1: ref(reference), fld=24) -> integer
  12[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[48]: GetInt(v1: ref(reference), fld=12) -> integer
  18[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_position(self:Lexer, a:&text) -> text["a"] {#block(1):text["a"]
  __work_1(1):text = "";
  [232] a(0):&text = {#Formatted string(2):text
    __work_1(1):text = "";
    OpFormatText(__work_1(1), OpGetText(self(0), 4i32), 0i32, -1i32, 32i32);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 16i32), 10i32, 0i32, 32i32, false, false);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 20i32), 10i32, 0i32, 32i32, false, false);
    __work_1(1);
  }#Formatted string(2):text;
  [233] OpFreeText(__work_1(1));
  a(0);
}#block(1):text["a"]

byte-code for lib/lexer.lav:_tp_Lexer_position(self: ref(Lexer)[0], a: &text[12]) -> text["a"]
   0[24]: return-address
   0[28]: Text() var=__work_1[32]:text
   1[52]: [232] VarRef(var[16]) -> ref(reference) var=a[16]:&text
   4[64]: ClearText(var[32]) var=__work_1[32]:text
   7[64]: ConstText(_value="") -> text
   9[80]: AppendText(var[32], v1: text)
  12[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[76]: GetText(v1: ref(reference), fld=4) -> text["self"]
  18[80]: ConstInt(val=0) -> integer
  23[84]: FormatText(var[32], val: text, width: integer, dir=-1, token=32)
  28[64]: ConstText(_value=":") -> text
  31[80]: AppendText(var[32], v1: text)
  34[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  37[76]: GetInt(v1: ref(reference), fld=16) -> integer
  40[68]: ConstInt(val=0) -> integer
  45[72]: FormatInt(var[32], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  52[64]: ConstText(_value=":") -> text
  55[80]: AppendText(var[32], v1: text)
  58[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  61[76]: GetInt(v1: ref(reference), fld=20) -> integer
  64[68]: ConstInt(val=0) -> integer
  69[72]: FormatInt(var[32], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  76[64]: VarText(var[32]) -> text var=__work_1[32]:text
  79[80]: AppendRefText(r: ref(reference), fld=0, v1: text)
  82[52]: [233] FreeText(var[32])
  85[52]: VarRef(var[16]) -> ref(reference) var=a[16]:&text
  88[64]: GetRefText(r: ref(reference), fld=0) -> text["self"]
  91[68]: Return(ret=24, value=16, discard=68) type=text[4]:Base[5]

fn _tp_Lexer_identifier(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  [238] result(0):&text = OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
  [239] if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, result(0))) {#block(2):text
    [240] OpConvTextFromNull();
  }#block(2):text else {#block(3):text
    [242] _tp_Lexer_scan(self(0));
    [243] result(0);
  }#block(3):text;
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_identifier(self: ref(Lexer)[0], result: &text[12]) -> text["result"]
   0[24]: return-address
   0[28]: [238] VarRef(var[16]) -> ref(reference) var=result[16]:&text
   3[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   6[52]: GetText(v1: ref(reference), fld=8) -> text["self"]
   9[56]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[68]: GetInt(v1: ref(reference), fld=24) -> integer
  15[60]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  18[72]: GetInt(v1: ref(reference), fld=12) -> integer
  21[64]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  22[56]: AppendRefText(r: ref(reference), fld=0, v1: text)
  25[28]: [239] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  28[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
  31[40]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
  34[52]: GetRefText(r: ref(reference), fld=0) -> text["self"]
  37[56]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
  41[40]: ConvBoolFromRef(val: ref(reference)) -> boolean
  42[29]: GotoFalseWord(jump=49, if_false: boolean)
  45[28]: [240] ConvTextFromNull() -> text
  46[44]: GotoWord(jump=65)
  49[28]: [242] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  52[40]: Call(size=0, call=_tp_Lexer_scan[1992])
  59[28]: [243] VarRef(var[16]) -> ref(reference) var=result[16]:&text
  62[40]: GetRefText(r: ref(reference), fld=0) -> text["self"]
  65[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_int(self:Lexer) -> integer {#block(1):integer
  [249] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(2u8(17))) {#block(2):void
    [250] return OpConvIntFromNull();
  }#block(2):void else null;
  [252] result(1):integer = OpCastIntFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [253] if OpConvBoolFromInt(result(1)) {#block(3):integer
    [254] _tp_Lexer_scan(self(0));
    [255] result(1);
  }#block(3):integer else {#block(4):integer
    [257] OpConvIntFromNull();
  }#block(4):integer;
}#block(1):integer

byte-code for lib/lexer.lav:_tp_Lexer_int(self: ref(Lexer)[0]) -> integer
   0[12]: return-address
   0[16]: [249] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [250] ConvIntFromNull() -> integer
  15[20]: Return(ret=12, value=4, discard=20)
  21[20]: ConvIntFromNull() -> integer
  22[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]
  28[24]: FreeStack(value=0, discard=8)
  32[16]: [252] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastIntFromText(v1: text) -> integer
  52[20]: [253] VarInt(var[20]) -> integer var=result[20]:integer
  55[24]: ConvBoolFromInt(v1: integer) -> boolean
  56[21]: GotoFalseWord(jump=75, if_false: boolean)
  59[20]: [254] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  62[32]: Call(size=0, call=_tp_Lexer_scan[1992])
  69[20]: [255] VarInt(var[20]) -> integer var=result[20]:integer
  72[24]: GotoWord(jump=76)
  75[20]: [257] ConvIntFromNull() -> integer
  76[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]

fn _tp_Lexer_long_int(self:Lexer) -> long {#block(1):long
  [263] if if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(5u8(17))) OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(2u8(17))) else false {#block(2):void
    [264] return OpConvLongFromNull();
  }#block(2):void else null;
  [266] to(1):integer = OpGetInt(self(0), 12i32);
  [267] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpMinInt(to(1), 1i32))), OpConvIntFromCharacter(108i32)) {#block(3):void
    [268] to(1):integer = OpMinInt(to(1), 1i32);
  }#block(3):void else null;
  [270] result(1):long = OpCastLongFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), to(1)));
  [271] if OpConvBoolFromLong(result(1)) {#block(4):long
    [272] _tp_Lexer_scan(self(0));
    [273] result(1);
  }#block(4):long else {#block(5):long
    [275] OpConvLongFromNull();
  }#block(5):long;
}#block(1):long

byte-code for lib/lexer.lav:_tp_Lexer_long_int(self: ref(Lexer)[0]) -> long
   0[12]: return-address
   0[16]: [263] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=5) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=28, if_false: boolean)
  14[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  17[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
  20[17]: ConvIntFromEnum(v1: boolean) -> integer
  21[20]: ConstEnum(val=2) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
  23[21]: ConvIntFromEnum(v1: boolean) -> integer
  24[24]: NeInt(v1: integer, v2: integer) -> boolean
  25[17]: GotoWord(jump=29)
  28[16]: ConstFalse() -> boolean
  29[17]: GotoFalseWord(jump=50, if_false: boolean)
  32[16]: [264] ConvLongFromNull() -> long
  33[24]: Return(ret=12, value=8, discard=24)
  39[24]: ConvLongFromNull() -> long
  40[32]: Return(ret=12, value=8, discard=32) type=long[8]:Base[1]
  46[32]: FreeStack(value=0, discard=16)
  50[16]: [266] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  53[28]: GetInt(v1: ref(reference), fld=12) -> integer
  56[20]: [267] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  59[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
  62[36]: VarInt(var[20]) -> integer var=to[20]:integer
  65[40]: ConstInt(val=1) -> integer
  70[44]: MinInt(v1: integer, v2: integer) -> integer
  71[40]: TextCharacter(v1: text, v2: integer) -> character
  72[24]: ConvIntFromCharacter(v1: character) -> integer
  73[24]: ConstInt(val=108) -> integer
  78[28]: ConvIntFromCharacter(v1: character) -> integer
  79[28]: EqInt(v1: integer, v2: integer) -> boolean
  80[21]: GotoFalseWord(jump=95, if_false: boolean)
  83[20]: [268] VarInt(var[20]) -> integer var=to[20]:integer
  86[24]: ConstInt(val=1) -> integer
  91[28]: MinInt(v1: integer, v2: integer) -> integer
  92[24]: PutInt(var[20], value: integer)
  95[20]: [270] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  98[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
 101[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 104[48]: GetInt(v1: ref(reference), fld=24) -> integer
 107[40]: VarInt(var[20]) -> integer var=to[20]:integer
 110[44]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 111[36]: CastLongFromText(v1: text) -> long
 112[28]: [271] VarLong(var[24]) -> long var=result[24]:long
 115[36]: ConvBoolFromLong(v1: long) -> boolean
 116[29]: GotoFalseWord(jump=135, if_false: boolean)
 119[28]: [272] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 122[40]: Call(size=0, call=_tp_Lexer_scan[1992])
 129[28]: [273] VarLong(var[24]) -> long var=result[24]:long
 132[36]: GotoWord(jump=136)
 135[28]: [275] ConvLongFromNull() -> long
 136[36]: Return(ret=12, value=8, discard=36) type=long[8]:Base[1]

fn _tp_Lexer_long_float(self:Lexer) -> float {#block(1):float
  [281] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(3u8(17))) {#block(2):void
    [282] return OpConvFloatFromNull();
  }#block(2):void else null;
  [284] result(1):float = OpCastFloatFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [285] if OpConvBoolFromFloat(result(1)) {#block(3):float
    [286] _tp_Lexer_scan(self(0));
    [287] result(1);
  }#block(3):float else {#block(4):float
    [289] OpConvFloatFromNull();
  }#block(4):float;
}#block(1):float

byte-code for lib/lexer.lav:_tp_Lexer_long_float(self: ref(Lexer)[0]) -> float
   0[12]: return-address
   0[16]: [281] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [282] ConvFloatFromNull() -> float
  15[24]: Return(ret=12, value=8, discard=24)
  21[24]: ConvFloatFromNull() -> float
  22[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]
  28[32]: FreeStack(value=0, discard=16)
  32[16]: [284] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastFloatFromText(v1: text) -> float
  52[24]: [285] VarFloat(var[20]) -> float var=result[20]:float
  55[32]: ConvBoolFromFloat(v1: float) -> boolean
  56[25]: GotoFalseWord(jump=75, if_false: boolean)
  59[24]: [286] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  62[36]: Call(size=0, call=_tp_Lexer_scan[1992])
  69[24]: [287] VarFloat(var[20]) -> float var=result[20]:float
  72[32]: GotoWord(jump=76)
  75[24]: [289] ConvFloatFromNull() -> float
  76[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]

fn _tp_Lexer_single_float(self:Lexer) -> single {#block(1):single
  [295] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(3u8(17))) {#block(2):void
    [296] return OpConvSingleFromNull();
  }#block(2):void else null;
  [298] result(1):single = OpCastSingleFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  [299] if OpConvBoolFromSingle(result(1)) {#block(3):single
    [300] _tp_Lexer_scan(self(0));
    [301] result(1);
  }#block(3):single else {#block(4):single
    [303] OpConvSingleFromNull();
  }#block(4):single;
}#block(1):single

byte-code for lib/lexer.lav:_tp_Lexer_single_float(self: ref(Lexer)[0]) -> single
   0[12]: return-address
   0[16]: [295] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=3) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=32, if_false: boolean)
  14[16]: [296] ConvSingleFromNull() -> single
  15[20]: Return(ret=12, value=4, discard=20)
  21[20]: ConvSingleFromNull() -> single
  22[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]
  28[24]: FreeStack(value=0, discard=8)
  32[16]: [298] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  35[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  38[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  41[44]: GetInt(v1: ref(reference), fld=24) -> integer
  44[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  47[48]: GetInt(v1: ref(reference), fld=12) -> integer
  50[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  51[32]: CastSingleFromText(v1: text) -> single
  52[20]: [299] VarSingle(var[20]) -> single var=result[20]:single
  55[24]: ConvBoolFromSingle(v1: single) -> boolean
  56[21]: GotoFalseWord(jump=75, if_false: boolean)
  59[20]: [300] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  62[32]: Call(size=0, call=_tp_Lexer_scan[1992])
  69[20]: [301] VarSingle(var[20]) -> single var=result[20]:single
  72[24]: GotoWord(jump=76)
  75[20]: [303] ConvSingleFromNull() -> single
  76[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]

fn _tp_Lexer_escaped(self:Lexer, i:integer) -> character {#block(1):character
  [308] c(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32));
  [309] if if if if if if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(39i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(92i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(10i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(123i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(125i32)) {#block(2):character
    [310] c(1);
  }#block(2):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(116i32)) {#block(3):character
    [312] 9i32;
  }#block(3):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(114i32)) {#block(4):character
    [314] 13i32;
  }#block(4):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(110i32)) {#block(5):character
    [316] 10i32;
  }#block(5):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(120i32)) {#block(6):character
    [318] total(6):text["total"] = "";
    OpAppendText(total(6), "0");
    OpAppendText(total(6), OpGetTextSub(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32), OpAddInt(i(0), 4i32)));
    [319] nr(6):integer = OpCastIntFromText(total(6));
    [320] OpCastCharacterFromInt(nr(6));
    OpFreeText(total(6));
  }#block(6):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(117i32)) {#block(7):character
    [322] OpCastCharacterFromInt(0i32);
  }#block(7):character else {#block(8):character
    [324] OpCastCharacterFromInt(0i32);
  }#block(8):character;
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_escaped(self: ref(Lexer)[0], i: integer[12]) -> character
   0[16]: return-address
   0[20]: [308] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[36]: VarInt(var[16]) -> integer var=i[16]:integer
   9[40]: ConstInt(val=1) -> integer
  14[44]: AddInt(v1: integer, v2: integer) -> integer
  15[40]: TextCharacter(v1: text, v2: integer) -> character
  16[24]: [309] VarCharacter(var[24]) -> character var=c[24]:character
  19[28]: ConvIntFromCharacter(v1: character) -> integer
  20[28]: ConstInt(val=34) -> integer
  25[32]: ConvIntFromCharacter(v1: character) -> integer
  26[32]: EqInt(v1: integer, v2: integer) -> boolean
  27[25]: GotoFalseWord(jump=34, if_false: boolean)
  30[24]: ConstTrue() -> boolean
  31[25]: GotoWord(jump=45)
  34[24]: VarCharacter(var[24]) -> character var=c[24]:character
  37[28]: ConvIntFromCharacter(v1: character) -> integer
  38[28]: ConstInt(val=39) -> integer
  43[32]: ConvIntFromCharacter(v1: character) -> integer
  44[32]: EqInt(v1: integer, v2: integer) -> boolean
  45[25]: GotoFalseWord(jump=52, if_false: boolean)
  48[24]: ConstTrue() -> boolean
  49[25]: GotoWord(jump=63)
  52[24]: VarCharacter(var[24]) -> character var=c[24]:character
  55[28]: ConvIntFromCharacter(v1: character) -> integer
  56[28]: ConstInt(val=92) -> integer
  61[32]: ConvIntFromCharacter(v1: character) -> integer
  62[32]: EqInt(v1: integer, v2: integer) -> boolean
  63[25]: GotoFalseWord(jump=70, if_false: boolean)
  66[24]: ConstTrue() -> boolean
  67[25]: GotoWord(jump=81)
  70[24]: VarCharacter(var[24]) -> character var=c[24]:character
  73[28]: ConvIntFromCharacter(v1: character) -> integer
  74[28]: ConstInt(val=10) -> integer
  79[32]: ConvIntFromCharacter(v1: character) -> integer
  80[32]: EqInt(v1: integer, v2: integer) -> boolean
  81[25]: GotoFalseWord(jump=88, if_false: boolean)
  84[24]: ConstTrue() -> boolean
  85[25]: GotoWord(jump=99)
  88[24]: VarCharacter(var[24]) -> character var=c[24]:character
  91[28]: ConvIntFromCharacter(v1: character) -> integer
  92[28]: ConstInt(val=123) -> integer
  97[32]: ConvIntFromCharacter(v1: character) -> integer
  98[32]: EqInt(v1: integer, v2: integer) -> boolean
  99[25]: GotoFalseWord(jump=106, if_false: boolean)
 102[24]: ConstTrue() -> boolean
 103[25]: GotoWord(jump=117)
 106[24]: VarCharacter(var[24]) -> character var=c[24]:character
 109[28]: ConvIntFromCharacter(v1: character) -> integer
 110[28]: ConstInt(val=125) -> integer
 115[32]: ConvIntFromCharacter(v1: character) -> integer
 116[32]: EqInt(v1: integer, v2: integer) -> boolean
 117[25]: GotoFalseWord(jump=126, if_false: boolean)
 120[24]: [310] VarCharacter(var[24]) -> character var=c[24]:character
 123[28]: GotoWord(jump=288)
 126[24]: VarCharacter(var[24]) -> character var=c[24]:character
 129[28]: ConvIntFromCharacter(v1: character) -> integer
 130[28]: ConstInt(val=116) -> integer
 135[32]: ConvIntFromCharacter(v1: character) -> integer
 136[32]: EqInt(v1: integer, v2: integer) -> boolean
 137[25]: GotoFalseWord(jump=148, if_false: boolean)
 140[24]: [312] ConstInt(val=9) -> integer
 145[28]: GotoWord(jump=288)
 148[24]: VarCharacter(var[24]) -> character var=c[24]:character
 151[28]: ConvIntFromCharacter(v1: character) -> integer
 152[28]: ConstInt(val=114) -> integer
 157[32]: ConvIntFromCharacter(v1: character) -> integer
 158[32]: EqInt(v1: integer, v2: integer) -> boolean
 159[25]: GotoFalseWord(jump=170, if_false: boolean)
 162[24]: [314] ConstInt(val=13) -> integer
 167[28]: GotoWord(jump=288)
 170[24]: VarCharacter(var[24]) -> character var=c[24]:character
 173[28]: ConvIntFromCharacter(v1: character) -> integer
 174[28]: ConstInt(val=110) -> integer
 179[32]: ConvIntFromCharacter(v1: character) -> integer
 180[32]: EqInt(v1: integer, v2: integer) -> boolean
 181[25]: GotoFalseWord(jump=192, if_false: boolean)
 184[24]: [316] ConstInt(val=10) -> integer
 189[28]: GotoWord(jump=288)
 192[24]: VarCharacter(var[24]) -> character var=c[24]:character
 195[28]: ConvIntFromCharacter(v1: character) -> integer
 196[28]: ConstInt(val=120) -> integer
 201[32]: ConvIntFromCharacter(v1: character) -> integer
 202[32]: EqInt(v1: integer, v2: integer) -> boolean
 203[25]: GotoFalseWord(jump=259, if_false: boolean)
 206[24]: [318] Text() var=total[28]:text["total"]
 207[48]: ConstText(_value="0") -> text
 210[64]: AppendText(var[28], v1: text)
 213[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 216[60]: GetText(v1: ref(reference), fld=8) -> text["self"]
 219[64]: VarInt(var[16]) -> integer var=i[16]:integer
 222[68]: ConstInt(val=1) -> integer
 227[72]: AddInt(v1: integer, v2: integer) -> integer
 228[68]: VarInt(var[16]) -> integer var=i[16]:integer
 231[72]: ConstInt(val=4) -> integer
 236[76]: AddInt(v1: integer, v2: integer) -> integer
 237[72]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 238[64]: AppendText(var[28], v1: text)
 241[48]: [319] VarText(var[28]) -> text var=total[28]:text["total"]
 244[64]: CastIntFromText(v1: text) -> integer
 245[52]: [320] VarInt(var[52]) -> integer var=nr[52]:integer
 248[56]: CastCharacterFromInt(v1: integer) -> character
 249[56]: FreeText(var[28])
 252[56]: FreeStack(value=4, discard=32)
 256[28]: GotoWord(jump=288)
 259[24]: VarCharacter(var[24]) -> character var=c[24]:character
 262[28]: ConvIntFromCharacter(v1: character) -> integer
 263[28]: ConstInt(val=117) -> integer
 268[32]: ConvIntFromCharacter(v1: character) -> integer
 269[32]: EqInt(v1: integer, v2: integer) -> boolean
 270[25]: GotoFalseWord(jump=282, if_false: boolean)
 273[24]: [322] ConstInt(val=0) -> integer
 278[28]: CastCharacterFromInt(v1: integer) -> character
 279[28]: GotoWord(jump=288)
 282[24]: [324] ConstInt(val=0) -> integer
 287[28]: CastCharacterFromInt(v1: integer) -> character
 288[28]: Return(ret=16, value=4, discard=28) type=character[4]:Base[6]

fn _tp_Lexer_constant_text(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  [330] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(6u8(17))) {#block(2):void
    [331] return OpConvTextFromNull();
  }#block(2):void else null;
  [333] result(0):&text = "";
  [334] {#For block(3):void
    i#index(3):integer = OpConvIntFromNull();
    loop {#For loop_4
      i(4):integer = {#Iter range(5):integer
        i#index(3):integer = if OpNot(OpConvBoolFromInt(i#index(3))) OpAddInt(OpGetInt(self(0), 24i32), 1i32) else OpAddInt(i#index(3), 1i32);
        if OpGeInt(i#index(3), OpMinInt(OpGetInt(self(0), 12i32), 1i32)) break(0) else null;
        i#index(3);
      }#Iter range(5):integer;
      {#block(6):void
        [335] if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), i(4))), OpConvIntFromCharacter(92i32)) {#block(7):void
          [336] OpAppendRefText(OpVarRef(result(0)), 0i32, "");
          OpAppendRefText(OpVarRef(result(0)), 0i32, _tp_Lexer_escaped(self(0), i(4)));
        }#block(7):void else {#block(8):void
          [338] OpAppendRefText(OpVarRef(result(0)), 0i32, "");
          OpAppendRefText(OpVarRef(result(0)), 0i32, OpTextCharacter(OpGetText(self(0), 8i32), i(4)));
        }#block(8):void;
      }#block(6):void;
    }#For loop_4;
  }#For block(3):void;
  [341] _tp_Lexer_scan(self(0));
  [342] result(0);
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_constant_text(self: ref(Lexer)[0], result: &text[12]) -> text["result"]
   0[24]: return-address
   0[28]: [330] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[29]: ConvIntFromEnum(v1: boolean) -> integer
   7[32]: ConstEnum(val=6) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[33]: ConvIntFromEnum(v1: boolean) -> integer
  10[36]: NeInt(v1: integer, v2: integer) -> boolean
  11[29]: GotoFalseWord(jump=32, if_false: boolean)
  14[28]: [331] ConvTextFromNull() -> text
  15[44]: Return(ret=24, value=16, discard=44)
  21[44]: ConvTextFromNull() -> text
  22[60]: Return(ret=24, value=16, discard=60) type=text[4]:Base[5]
  28[60]: FreeStack(value=0, discard=32)
  32[28]: [333] VarRef(var[16]) -> ref(reference) var=result[16]:&text
  35[40]: ConstText(_value="") -> text
  37[56]: AppendRefText(r: ref(reference), fld=0, v1: text)
  40[28]: [334] ConvIntFromNull() -> integer var=i#index[32]:integer
  41[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  44[36]: ConvBoolFromInt(v1: integer) -> boolean
  45[33]: Not(v1: boolean) -> boolean
  46[33]: GotoFalseWord(jump=64, if_false: boolean)
  49[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  52[44]: GetInt(v1: ref(reference), fld=24) -> integer
  55[36]: ConstInt(val=1) -> integer
  60[40]: AddInt(v1: integer, v2: integer) -> integer
  61[36]: GotoWord(jump=73)
  64[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  67[36]: ConstInt(val=1) -> integer
  72[40]: AddInt(v1: integer, v2: integer) -> integer
  73[36]: PutInt(var[32], value: integer)
  76[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  79[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  82[48]: GetInt(v1: ref(reference), fld=12) -> integer
  85[40]: ConstInt(val=1) -> integer
  90[44]: MinInt(v1: integer, v2: integer) -> integer
  91[40]: GeInt(v1: integer, v2: integer) -> boolean
  92[33]: GotoFalseWord(jump=98, if_false: boolean)
  95[32]: GotoWord(jump=183)
  98[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
 101[36]: [335] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 104[48]: GetText(v1: ref(reference), fld=8) -> text["self"]
 107[52]: VarInt(var[36]) -> integer var=i[36]:integer
 110[56]: TextCharacter(v1: text, v2: integer) -> character
 111[40]: ConvIntFromCharacter(v1: character) -> integer
 112[40]: ConstInt(val=92) -> integer
 117[44]: ConvIntFromCharacter(v1: character) -> integer
 118[44]: EqInt(v1: integer, v2: integer) -> boolean
 119[37]: GotoFalseWord(jump=152, if_false: boolean)
 122[36]: [336] VarRef(var[16]) -> ref(reference)
 125[48]: ConstText(_value="") -> text
 127[64]: AppendRefText(r: ref(reference), fld=0, v1: text)
 130[36]: VarRef(var[16]) -> ref(reference)
 133[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 136[60]: VarInt(var[36]) -> integer var=i[36]:integer
 139[64]: Call(size=0, call=_tp_Lexer_escaped[4108])
 146[52]: AppendRefText(r: ref(reference), fld=0, v1: text)
 149[36]: GotoWord(jump=176)
 152[36]: [338] VarRef(var[16]) -> ref(reference)
 155[48]: ConstText(_value="") -> text
 157[64]: AppendRefText(r: ref(reference), fld=0, v1: text)
 160[36]: VarRef(var[16]) -> ref(reference)
 163[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 166[60]: GetText(v1: ref(reference), fld=8) -> text["self"]
 169[64]: VarInt(var[36]) -> integer var=i[36]:integer
 172[68]: TextCharacter(v1: text, v2: integer) -> character
 173[52]: AppendRefText(r: ref(reference), fld=0, v1: text)
 176[36]: FreeStack(value=0, discard=4)
 180[32]: GotoWord(jump=41)
 183[32]: FreeStack(value=0, discard=4)
 187[28]: [341] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 190[40]: Call(size=0, call=_tp_Lexer_scan[1992])
 197[28]: [342] VarRef(var[16]) -> ref(reference) var=result[16]:&text
 200[40]: GetRefText(r: ref(reference), fld=0) -> text["self"]
 203[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_constant_character(self:Lexer) -> character {#block(1):character
  [347] if OpNeInt(OpConvIntFromEnum(OpGetEnum(self(0), 40i32)), OpConvIntFromEnum(8u8(17))) {#block(2):void
    [348] return OpCastCharacterFromInt(0i32);
  }#block(2):void else null;
  [350] result(1):character = if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 12i32), 1i32))), OpConvIntFromCharacter(92i32)) {#block(3):character
    [351] _tp_Lexer_escaped(self(0), OpAddInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(3):character else {#block(4):character
    [353] OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(4):character;
  [355] _tp_Lexer_scan(self(0));
  [356] result(1);
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_constant_character(self: ref(Lexer)[0]) -> character
   0[12]: return-address
   0[16]: [347] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> boolean
   6[17]: ConvIntFromEnum(v1: boolean) -> integer
   7[20]: ConstEnum(val=8) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   9[21]: ConvIntFromEnum(v1: boolean) -> integer
  10[24]: NeInt(v1: integer, v2: integer) -> boolean
  11[17]: GotoFalseWord(jump=42, if_false: boolean)
  14[16]: [348] ConstInt(val=0) -> integer
  19[20]: CastCharacterFromInt(v1: integer) -> character
  20[20]: Return(ret=12, value=4, discard=20)
  26[20]: ConstInt(val=0) -> integer
  31[24]: CastCharacterFromInt(v1: integer) -> character
  32[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]
  38[24]: FreeStack(value=0, discard=8)
  42[16]: [350] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  45[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  48[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  51[44]: GetInt(v1: ref(reference), fld=12) -> integer
  54[36]: ConstInt(val=1) -> integer
  59[40]: AddInt(v1: integer, v2: integer) -> integer
  60[36]: TextCharacter(v1: text, v2: integer) -> character
  61[20]: ConvIntFromCharacter(v1: character) -> integer
  62[20]: ConstInt(val=92) -> integer
  67[24]: ConvIntFromCharacter(v1: character) -> integer
  68[24]: EqInt(v1: integer, v2: integer) -> boolean
  69[17]: GotoFalseWord(jump=97, if_false: boolean)
  72[16]: [351] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  75[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  78[40]: GetInt(v1: ref(reference), fld=12) -> integer
  81[32]: ConstInt(val=1) -> integer
  86[36]: AddInt(v1: integer, v2: integer) -> integer
  87[32]: Call(size=0, call=_tp_Lexer_escaped[4108])
  94[20]: GotoWord(jump=116)
  97[16]: [353] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 100[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
 103[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 106[44]: GetInt(v1: ref(reference), fld=12) -> integer
 109[36]: ConstInt(val=1) -> integer
 114[40]: AddInt(v1: integer, v2: integer) -> integer
 115[36]: TextCharacter(v1: text, v2: integer) -> character
 116[20]: [355] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 119[32]: Call(size=0, call=_tp_Lexer_scan[1992])
 126[20]: [356] VarCharacter(var[20]) -> character var=result[20]:character
 129[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]

fn _tp_Lexer_string_finished(self:Lexer) -> boolean {#block(1):boolean
  [361] OpEqInt(OpGetByte(self(0), 42i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_string_finished(self: ref(Lexer)[0]) -> boolean
   0[12]: return-address
   0[16]: [361] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=42, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_last_comment(self:Lexer) -> text["self"] {#block(1):text["self"]
  [366] OpGetText(self(0), 36i32);
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_last_comment(self: ref(Lexer)[0]) -> text["self"]
   0[12]: return-address
   0[16]: [366] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=36) -> text["self"]
   6[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_comment_behind(self:Lexer) -> boolean {#block(1):boolean
  [371] OpEqInt(OpGetByte(self(0), 43i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_comment_behind(self: ref(Lexer)[0]) -> boolean
   0[12]: return-address
   0[16]: [371] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=43, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_anchor(self:Lexer) -> Anchor {#block(1):ref(Anchor)
  __ref_1(1):ref(Anchor) = null;
  [375] {#Object(2):ref(Anchor)["__ref_1"]
    OpDatabase(__ref_1(1), 25i32);
    OpSetInt(__ref_1(1), 4i32, OpGetInt(self(0), 12i32));
    OpSetInt(__ref_1(1), 8i32, OpGetInt(self(0), 16i32));
    OpSetInt(__ref_1(1), 12i32, OpGetInt(self(0), 20i32));
    __ref_1(1);
  }#Object(2):ref(Anchor)["__ref_1"];
}#block(1):ref(Anchor)

byte-code for lib/lexer.lav:_tp_Lexer_anchor(self: ref(Lexer)[0]) -> ref(Anchor)
   0[12]: return-address
   0[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(Anchor)
   1[28]: [375] Database(var[20], db_tp=25) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]
   6[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
   9[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[52]: GetInt(v1: ref(reference), fld=12) -> integer
  15[44]: SetInt(v1: ref(reference), fld=4, val: integer)
  18[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  21[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  24[52]: GetInt(v1: ref(reference), fld=16) -> integer
  27[44]: SetInt(v1: ref(reference), fld=8, val: integer)
  30[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  33[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  36[52]: GetInt(v1: ref(reference), fld=20) -> integer
  39[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  45[40]: Return(ret=12, value=12, discard=40) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]

fn _tp_Lexer_revert(self:Lexer, to:Anchor) {#block(1):void
  [379] OpSetInt(self(0), 12i32, OpGetInt(to(0), 4i32));
  [380] OpSetInt(self(0), 16i32, OpGetInt(to(0), 8i32));
  [381] OpSetInt(self(0), 20i32, OpGetInt(to(0), 12i32));
  [382] _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_revert(self: ref(Lexer)[0], to: ref(Anchor)[12])
   0[24]: return-address
   0[28]: [379] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
   6[52]: GetInt(v1: ref(reference), fld=4) -> integer
   9[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  12[28]: [380] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  18[52]: GetInt(v1: ref(reference), fld=8) -> integer
  21[44]: SetInt(v1: ref(reference), fld=16, val: integer)
  24[28]: [381] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  27[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  30[52]: GetInt(v1: ref(reference), fld=12) -> integer
  33[44]: SetInt(v1: ref(reference), fld=20, val: integer)
  36[28]: [382] VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  39[40]: Call(size=0, call=_tp_Lexer_scan[1992])
  46[28]: Return(ret=24, value=0, discard=28)

fn main() {#block(1):void
  __ref_2(1):ref(main_vector<text>) = null;
  __ref_1(1):ref(main_vector<text>) = null;
  __work_6(1):text = "";
  __work_5(1):text = "";
  __work_4(1):text = "";
  __work_3(1):text = "";
  __work_2(1):text = "";
  __work_1(1):text = "";
  [4] l(1):ref(Lexer) = null;
  OpDatabase(l(1), 22i32);
  OpSetText(l(1), 4i32, "");
  OpSetText(l(1), 8i32, "");
  OpSetInt(l(1), 12i32, 0i32);
  OpSetInt(l(1), 16i32, 0i32);
  OpSetInt(l(1), 20i32, 0i32);
  OpSetInt(l(1), 24i32, 0i32);
  OpSetEnum(l(1), 40i32, 0u8(17));
  OpSetByte(l(1), 41i32, 0i32, if false 1i32 else 0i32);
  OpSetByte(l(1), 42i32, 0i32, if false 1i32 else 0i32);
  OpSetInt(l(1), 28i32, 0i32);
  OpSetInt(l(1), 32i32, 0i32);
  OpSetByte(l(1), 43i32, 0i32, if false 1i32 else 0i32);
  OpSetText(l(1), 36i32, "");
  [5] _tp_Lexer_set_tokens(l(1), {#Vector(2):vector<text>
    OpDatabase(__ref_1(1), 14i32);
    _vec_1(2):vector<text>["__ref_1"] = OpGetField(__ref_1(1), 4i32, 7i32);
    OpSetInt(__ref_1(1), 4i32, 0i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "+=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "*=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "-=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "!=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "==");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<<");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "->");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "=>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "&&");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "||");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _vec_1(2);
  }#Vector(2):vector<text>);
  [6] _tp_Lexer_set_keywords(l(1), {#Vector(3):vector<text>
    OpDatabase(__ref_2(1), 14i32);
    _vec_3(3):vector<text>["__ref_2"] = OpGetField(__ref_2(1), 4i32, 7i32);
    OpSetInt(__ref_2(1), 4i32, 0i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "for");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "in");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "if");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "else");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "fn");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "pub");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "use");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "struct");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "enum");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "match");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "and");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "or");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _vec_3(3);
  }#Vector(3):vector<text>);
  [7] _tp_Lexer_parse_string(l(1), "Tokens", "12 += -2 * 3l >> 4");
  [8] if OpEqInt(_tp_Lexer_int(l(1)), 12i32) null else OpPanic("Integer");
  [9] if OpNot(_tp_Lexer_matches(l(1), "+")) null else OpPanic("Incorrect plus");
  [10] if OpNeText(_tp_Lexer_peek(l(1)), "+") null else OpPanic("Incorrect plus");
  [11] if _tp_Lexer_matches(l(1), "+=") null else OpPanic("Incorrect plus_is");
  [12] if OpEqInt(_tp_Lexer_int(l(1)), OpMinSingleInt(2i32)) null else OpPanic("Second integer");
  [13] if _tp_Lexer_matches(l(1), "*") null else OpPanic("Incorrect multiply");
  [14] if OpNeInt(_tp_Lexer_int(l(1)), 3i32) null else OpPanic("Third number");
  [15] if OpEqLong(_tp_Lexer_long_int(l(1)), OpConvLongFromInt(3i32)) null else OpPanic("Incorrect long");
  [16] if OpEqText(_tp_Lexer_position(l(1), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]), "Tokens:1:15") null else OpPanic({#Formatted string(5):text
    __work_2(1):text = "Incorrect position ";
    OpFormatText(__work_2(1), _tp_Lexer_position(l(1), {#default ref(6):ref(reference)["__work_3"]
      OpCreateRef(__work_3(1));
    }#default ref(6):ref(reference)["__work_3"]), 0i32, -1i32, 32i32);
    __work_2(1);
  }#Formatted string(5):text);
  [17] if OpNot(_tp_Lexer_matches(l(1), ">")) null else OpPanic("Incorrect higher");
  [18] if _tp_Lexer_matches(l(1), ">>") null else OpPanic("Incorrect logical shift");
  [19] if OpEqText(_tp_Lexer_position(l(1), {#default ref(7):ref(reference)["__work_4"]
    OpCreateRef(__work_4(1));
  }#default ref(7):ref(reference)["__work_4"]), "Tokens:1:18") null else OpPanic({#Formatted string(8):text
    __work_5(1):text = "Incorrect position ";
    OpFormatText(__work_5(1), _tp_Lexer_position(l(1), {#default ref(9):ref(reference)["__work_6"]
      OpCreateRef(__work_6(1));
    }#default ref(9):ref(reference)["__work_6"]), 0i32, -1i32, 32i32);
    __work_5(1);
  }#Formatted string(8):text);
  OpFreeRef(l(1));
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
  OpFreeText(__work_3(1));
  OpFreeText(__work_4(1));
  OpFreeText(__work_5(1));
  OpFreeText(__work_6(1));
  OpFreeRef(__ref_1(1));
  OpFreeRef(__ref_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:main()
   0[0]: return-address
   0[4]: ConvRefFromNull() -> ref(reference) var=__ref_2[8]:ref(main_vector<text>)
   1[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(main_vector<text>)
   2[28]: Text() var=__work_6[32]:text
   3[52]: Text() var=__work_5[56]:text
   4[76]: Text() var=__work_4[80]:text
   5[100]: Text() var=__work_3[104]:text
   6[124]: Text() var=__work_2[128]:text
   7[148]: Text() var=__work_1[152]:text
   8[172]: [4] ConvRefFromNull() -> ref(reference) var=l[176]:ref(Lexer)
   9[184]: Database(var[176], db_tp=22) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22]
  14[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  17[196]: ConstText(_value="") -> text
  19[212]: SetText(v1: ref(reference), fld=4, val: text)
  22[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  25[196]: ConstText(_value="") -> text
  27[212]: SetText(v1: ref(reference), fld=8, val: text)
  30[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  33[196]: ConstInt(val=0) -> integer
  38[200]: SetInt(v1: ref(reference), fld=12, val: integer)
  41[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  44[196]: ConstInt(val=0) -> integer
  49[200]: SetInt(v1: ref(reference), fld=16, val: integer)
  52[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  55[196]: ConstInt(val=0) -> integer
  60[200]: SetInt(v1: ref(reference), fld=20, val: integer)
  63[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  66[196]: ConstInt(val=0) -> integer
  71[200]: SetInt(v1: ref(reference), fld=24, val: integer)
  74[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  77[196]: ConstEnum(val=0) -> boolean type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
  79[197]: SetEnum(v1: ref(reference), fld=40, val: boolean)
  82[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
  85[196]: ConstFalse() -> boolean
  86[197]: GotoFalseWord(jump=97, if_false: boolean)
  89[196]: ConstInt(val=1) -> integer
  94[200]: GotoWord(jump=102)
  97[196]: ConstInt(val=0) -> integer
 102[200]: SetByte(v1: ref(reference), fld=41, min=0, val: integer)
 107[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 110[196]: ConstFalse() -> boolean
 111[197]: GotoFalseWord(jump=122, if_false: boolean)
 114[196]: ConstInt(val=1) -> integer
 119[200]: GotoWord(jump=127)
 122[196]: ConstInt(val=0) -> integer
 127[200]: SetByte(v1: ref(reference), fld=42, min=0, val: integer)
 132[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 135[196]: ConstInt(val=0) -> integer
 140[200]: SetInt(v1: ref(reference), fld=28, val: integer)
 143[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 146[196]: ConstInt(val=0) -> integer
 151[200]: SetInt(v1: ref(reference), fld=32, val: integer)
 154[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 157[196]: ConstFalse() -> boolean
 158[197]: GotoFalseWord(jump=169, if_false: boolean)
 161[196]: ConstInt(val=1) -> integer
 166[200]: GotoWord(jump=174)
 169[196]: ConstInt(val=0) -> integer
 174[200]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
 179[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 182[196]: ConstText(_value="") -> text
 184[212]: SetText(v1: ref(reference), fld=36, val: text)
 187[184]: [5] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 190[196]: Database(var[20], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 195[196]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
 198[208]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 201[208]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
 204[220]: ConstInt(val=0) -> integer
 209[224]: SetInt(v1: ref(reference), fld=4, val: integer)
 212[208]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 215[220]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 220[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 223[232]: ConstText(_value="+=") -> text
 227[248]: SetText(v1: ref(reference), fld=0, val: text)
 230[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 233[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 236[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 241[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 244[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 249[232]: PutRef(var[212], value: ref(reference))
 252[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 255[232]: ConstText(_value="*=") -> text
 259[248]: SetText(v1: ref(reference), fld=0, val: text)
 262[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 265[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 268[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 273[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 276[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 281[232]: PutRef(var[212], value: ref(reference))
 284[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 287[232]: ConstText(_value="-=") -> text
 291[248]: SetText(v1: ref(reference), fld=0, val: text)
 294[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 297[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 300[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 305[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 308[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 313[232]: PutRef(var[212], value: ref(reference))
 316[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 319[232]: ConstText(_value="<=") -> text
 323[248]: SetText(v1: ref(reference), fld=0, val: text)
 326[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 329[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 332[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 337[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 340[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 345[232]: PutRef(var[212], value: ref(reference))
 348[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 351[232]: ConstText(_value=">=") -> text
 355[248]: SetText(v1: ref(reference), fld=0, val: text)
 358[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 361[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 364[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 369[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 372[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 377[232]: PutRef(var[212], value: ref(reference))
 380[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 383[232]: ConstText(_value="!=") -> text
 387[248]: SetText(v1: ref(reference), fld=0, val: text)
 390[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 393[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 396[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 401[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 404[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 409[232]: PutRef(var[212], value: ref(reference))
 412[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 415[232]: ConstText(_value="==") -> text
 419[248]: SetText(v1: ref(reference), fld=0, val: text)
 422[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 425[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 428[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 433[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 436[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 441[232]: PutRef(var[212], value: ref(reference))
 444[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 447[232]: ConstText(_value=">>") -> text
 451[248]: SetText(v1: ref(reference), fld=0, val: text)
 454[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 457[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 460[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 465[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 468[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 473[232]: PutRef(var[212], value: ref(reference))
 476[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 479[232]: ConstText(_value="<<") -> text
 483[248]: SetText(v1: ref(reference), fld=0, val: text)
 486[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 489[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 492[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 497[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 500[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 505[232]: PutRef(var[212], value: ref(reference))
 508[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 511[232]: ConstText(_value="->") -> text
 515[248]: SetText(v1: ref(reference), fld=0, val: text)
 518[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 521[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 524[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 529[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 532[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 537[232]: PutRef(var[212], value: ref(reference))
 540[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 543[232]: ConstText(_value="=>") -> text
 547[248]: SetText(v1: ref(reference), fld=0, val: text)
 550[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 553[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 556[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 561[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 564[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 569[232]: PutRef(var[212], value: ref(reference))
 572[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 575[232]: ConstText(_value=">>>") -> text
 580[248]: SetText(v1: ref(reference), fld=0, val: text)
 583[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 586[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 589[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 594[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 597[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 602[232]: PutRef(var[212], value: ref(reference))
 605[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 608[232]: ConstText(_value="..") -> text
 612[248]: SetText(v1: ref(reference), fld=0, val: text)
 615[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 618[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 621[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 626[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 629[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 634[232]: PutRef(var[212], value: ref(reference))
 637[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 640[232]: ConstText(_value="..=") -> text
 645[248]: SetText(v1: ref(reference), fld=0, val: text)
 648[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 651[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 654[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 659[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 662[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 667[232]: PutRef(var[212], value: ref(reference))
 670[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 673[232]: ConstText(_value="&&") -> text
 677[248]: SetText(v1: ref(reference), fld=0, val: text)
 680[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 683[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 686[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 691[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 694[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 699[232]: PutRef(var[212], value: ref(reference))
 702[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 705[232]: ConstText(_value="||") -> text
 709[248]: SetText(v1: ref(reference), fld=0, val: text)
 712[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 715[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[212]:ref(boolean)["_vec_1"]
 718[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 723[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[200]:vector<text>["__ref_1"]
 726[232]: FreeStack(value=12, discard=36)
 730[208]: Call(size=0, call=_tp_Lexer_set_tokens[1227])
 737[184]: [6] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
 740[196]: Database(var[8], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 745[196]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
 748[208]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 751[208]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
 754[220]: ConstInt(val=0) -> integer
 759[224]: SetInt(v1: ref(reference), fld=4, val: integer)
 762[208]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 765[220]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 770[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 773[232]: ConstText(_value="for") -> text
 778[248]: SetText(v1: ref(reference), fld=0, val: text)
 781[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 784[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 787[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 792[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 795[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 800[232]: PutRef(var[212], value: ref(reference))
 803[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 806[232]: ConstText(_value="in") -> text
 810[248]: SetText(v1: ref(reference), fld=0, val: text)
 813[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 816[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 819[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 824[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 827[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 832[232]: PutRef(var[212], value: ref(reference))
 835[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 838[232]: ConstText(_value="if") -> text
 842[248]: SetText(v1: ref(reference), fld=0, val: text)
 845[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 848[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 851[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 856[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 859[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 864[232]: PutRef(var[212], value: ref(reference))
 867[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 870[232]: ConstText(_value="else") -> text
 876[248]: SetText(v1: ref(reference), fld=0, val: text)
 879[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 882[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 885[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 890[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 893[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 898[232]: PutRef(var[212], value: ref(reference))
 901[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 904[232]: ConstText(_value="fn") -> text
 908[248]: SetText(v1: ref(reference), fld=0, val: text)
 911[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 914[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 917[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 922[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 925[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 930[232]: PutRef(var[212], value: ref(reference))
 933[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 936[232]: ConstText(_value="pub") -> text
 941[248]: SetText(v1: ref(reference), fld=0, val: text)
 944[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 947[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 950[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 955[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 958[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 963[232]: PutRef(var[212], value: ref(reference))
 966[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 969[232]: ConstText(_value="use") -> text
 974[248]: SetText(v1: ref(reference), fld=0, val: text)
 977[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 980[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
 983[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 988[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
 991[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 996[232]: PutRef(var[212], value: ref(reference))
 999[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1002[232]: ConstText(_value="struct") -> text
1010[248]: SetText(v1: ref(reference), fld=0, val: text)
1013[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1016[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1019[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1024[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1027[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1032[232]: PutRef(var[212], value: ref(reference))
1035[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1038[232]: ConstText(_value="enum") -> text
1044[248]: SetText(v1: ref(reference), fld=0, val: text)
1047[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1050[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1053[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1058[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1061[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1066[232]: PutRef(var[212], value: ref(reference))
1069[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1072[232]: ConstText(_value="match") -> text
1079[248]: SetText(v1: ref(reference), fld=0, val: text)
1082[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1085[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1088[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1093[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1096[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1101[232]: PutRef(var[212], value: ref(reference))
1104[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1107[232]: ConstText(_value="and") -> text
1112[248]: SetText(v1: ref(reference), fld=0, val: text)
1115[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1118[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1121[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1126[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1129[232]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1134[232]: PutRef(var[212], value: ref(reference))
1137[220]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1140[232]: ConstText(_value="or") -> text
1144[248]: SetText(v1: ref(reference), fld=0, val: text)
1147[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1150[232]: VarRef(var[212]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[212]:ref(boolean)["_vec_3"]
1153[244]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1158[220]: VarVector(var[200]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[200]:vector<text>["__ref_2"]
1161[232]: FreeStack(value=12, discard=36)
1165[208]: Call(size=0, call=_tp_Lexer_set_keywords[1115])
1172[184]: [7] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1175[196]: ConstText(_value="Tokens") -> text
1183[212]: ConstText(_value="12 += -2 * 3l >> 4") -> text
1203[228]: Call(size=0, call=_tp_Lexer_parse_string[3394])
1210[184]: [8] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1213[196]: Call(size=0, call=_tp_Lexer_int[3720])
1220[188]: ConstInt(val=12) -> integer
1225[192]: EqInt(v1: integer, v2: integer) -> boolean
1226[185]: GotoFalseWord(jump=1232, if_false: boolean)
1229[184]: GotoWord(jump=1242)
1232[184]: ConstText(_value="Integer") -> text
1241[200]: Panic(message: text)
1242[184]: [9] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1245[196]: ConstText(_value="+") -> text
1248[212]: Call(size=0, call=_tp_Lexer_matches[3490])
1255[185]: Not(v1: boolean) -> boolean
1256[185]: GotoFalseWord(jump=1262, if_false: boolean)
1259[184]: GotoWord(jump=1279)
1262[184]: ConstText(_value="Incorrect plus") -> text
1278[200]: Panic(message: text)
1279[184]: [10] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1282[196]: Call(size=0, call=_tp_Lexer_peek[3527])
1289[200]: ConstText(_value="+") -> text
1292[216]: NeText(v1: text, v2: text) -> boolean
1293[185]: GotoFalseWord(jump=1299, if_false: boolean)
1296[184]: GotoWord(jump=1316)
1299[184]: ConstText(_value="Incorrect plus") -> text
1315[200]: Panic(message: text)
1316[184]: [11] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1319[196]: ConstText(_value="+=") -> text
1323[212]: Call(size=0, call=_tp_Lexer_matches[3490])
1330[185]: GotoFalseWord(jump=1336, if_false: boolean)
1333[184]: GotoWord(jump=1356)
1336[184]: ConstText(_value="Incorrect plus_is") -> text
1355[200]: Panic(message: text)
1356[184]: [12] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1359[196]: Call(size=0, call=_tp_Lexer_int[3720])
1366[188]: ConstInt(val=2) -> integer
1371[192]: MinSingleInt(v1: integer) -> integer
1372[192]: EqInt(v1: integer, v2: integer) -> boolean
1373[185]: GotoFalseWord(jump=1379, if_false: boolean)
1376[184]: GotoWord(jump=1396)
1379[184]: ConstText(_value="Second integer") -> text
1395[200]: Panic(message: text)
1396[184]: [13] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1399[196]: ConstText(_value="*") -> text
1402[212]: Call(size=0, call=_tp_Lexer_matches[3490])
1409[185]: GotoFalseWord(jump=1415, if_false: boolean)
1412[184]: GotoWord(jump=1436)
1415[184]: ConstText(_value="Incorrect multiply") -> text
1435[200]: Panic(message: text)
1436[184]: [14] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1439[196]: Call(size=0, call=_tp_Lexer_int[3720])
1446[188]: ConstInt(val=3) -> integer
1451[192]: NeInt(v1: integer, v2: integer) -> boolean
1452[185]: GotoFalseWord(jump=1458, if_false: boolean)
1455[184]: GotoWord(jump=1473)
1458[184]: ConstText(_value="Third number") -> text
1472[200]: Panic(message: text)
1473[184]: [15] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1476[196]: Call(size=0, call=_tp_Lexer_long_int[3802])
1483[192]: ConstInt(val=3) -> integer
1488[196]: ConvLongFromInt(v1: integer) -> long
1489[200]: EqLong(v1: long, v2: long) -> boolean
1490[185]: GotoFalseWord(jump=1496, if_false: boolean)
1493[184]: GotoWord(jump=1513)
1496[184]: ConstText(_value="Incorrect long") -> text
1512[200]: Panic(message: text)
1513[184]: [16] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1516[196]: CreateRef(var[152]) -> ref(reference)
1519[208]: Call(size=0, call=_tp_Lexer_position[3552])
1526[200]: ConstText(_value="Tokens:1:15") -> text
1539[216]: EqText(v1: text, v2: text) -> boolean
1540[185]: GotoFalseWord(jump=1546, if_false: boolean)
1543[184]: GotoWord(jump=1600)
1546[184]: ClearText(var[128]) var=__work_2[128]:text
1549[184]: ConstText(_value="Incorrect position ") -> text
1570[200]: AppendText(var[128], v1: text)
1573[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1576[196]: CreateRef(var[104]) -> ref(reference)
1579[208]: Call(size=0, call=_tp_Lexer_position[3552])
1586[200]: ConstInt(val=0) -> integer
1591[204]: FormatText(var[128], val: text, width: integer, dir=-1, token=32)
1596[184]: VarText(var[128]) -> text var=__work_2[128]:text
1599[200]: Panic(message: text)
1600[184]: [17] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1603[196]: ConstText(_value=">") -> text
1606[212]: Call(size=0, call=_tp_Lexer_matches[3490])
1613[185]: Not(v1: boolean) -> boolean
1614[185]: GotoFalseWord(jump=1620, if_false: boolean)
1617[184]: GotoWord(jump=1639)
1620[184]: ConstText(_value="Incorrect higher") -> text
1638[200]: Panic(message: text)
1639[184]: [18] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1642[196]: ConstText(_value=">>") -> text
1646[212]: Call(size=0, call=_tp_Lexer_matches[3490])
1653[185]: GotoFalseWord(jump=1659, if_false: boolean)
1656[184]: GotoWord(jump=1685)
1659[184]: ConstText(_value="Incorrect logical shift") -> text
1684[200]: Panic(message: text)
1685[184]: [19] VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1688[196]: CreateRef(var[80]) -> ref(reference)
1691[208]: Call(size=0, call=_tp_Lexer_position[3552])
1698[200]: ConstText(_value="Tokens:1:18") -> text
1711[216]: EqText(v1: text, v2: text) -> boolean
1712[185]: GotoFalseWord(jump=1718, if_false: boolean)
1715[184]: GotoWord(jump=1772)
1718[184]: ClearText(var[56]) var=__work_5[56]:text
1721[184]: ConstText(_value="Incorrect position ") -> text
1742[200]: AppendText(var[56], v1: text)
1745[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1748[196]: CreateRef(var[32]) -> ref(reference)
1751[208]: Call(size=0, call=_tp_Lexer_position[3552])
1758[200]: ConstInt(val=0) -> integer
1763[204]: FormatText(var[56], val: text, width: integer, dir=-1, token=32)
1768[184]: VarText(var[56]) -> text var=__work_5[56]:text
1771[200]: Panic(message: text)
1772[184]: VarRef(var[176]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[176]:ref(Lexer)
1775[196]: FreeRef(v1: ref(reference))
1776[184]: FreeText(var[152])
1779[184]: FreeText(var[128])
1782[184]: FreeText(var[104])
1785[184]: FreeText(var[80])
1788[184]: FreeText(var[56])
1791[184]: FreeText(var[32])
1794[184]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
1797[196]: FreeRef(v1: ref(reference))
1798[184]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
1801[196]: FreeRef(v1: ref(reference))
1802[184]: Return(ret=0, value=0, discard=184)

