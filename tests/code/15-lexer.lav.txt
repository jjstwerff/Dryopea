Type 17:Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])

Type 18:SKeyword[8]:
    name:text[4]

Type 19:Possible[8]:
    length:integer[0]
    token:text[4]

Type 20:SToken[12]:
    start:character[4]
    possible:sorted<Possible[-length,token]>[8]

Type 21:sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ]

Type 22:Lexer[44]:
    file:text[4]
    data:text[8]
    index:integer[12]
    line:integer[16]
    pos:integer[20]
    start:integer[24]
    scanned:Scanned[40]
    string:boolean[41]
    finished:boolean[42]
    keywords:hash<SKeyword[name]>[28]
    tokens:hash<SToken[start]>[32]
    behind:boolean[43]
    comment:text[36]

Type 23:hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ]

Type 24:hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ]

Type 25:Anchor[16]:
    index:integer[4]
    line:integer[8]
    pos:integer[12]

Type 26:vector<SKeyword>[4]:Vector(18)

Type 27:vector<Possible>[4]:Vector(19)

Type 28:vector<SToken>[4]:Vector(20)

fn _tp_Lexer_set_keywords(self:Lexer, keywords:vector<text>) {#block(1):void
  OpGetField(self(0), 28i32, 23i32);
  {#For block(2):void
    _vector_1(2):vector<text>["keywords"] = keywords(0);
    k#index(2):integer = -1i32;
    loop {#For loop_3
      k(3):text["_vector_1"] = {#iter next(4):text
        k#index(2):integer = OpAddInt(k#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, k#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(k(3))) {#break(5):void
        OpFreeText(k(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        _elm_2(6):ref(SKeyword)["self"] = OpNewRecord(self(0), 22i32, 9i32);
        OpSetText(_elm_2(6), 4i32, k(3));
        OpFinishRecord(self(0), _elm_2(6), 22i32, 9i32);
      }#block(6):void;
      OpFreeText(k(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_keywords(self: ref(Lexer)[0], keywords: vector<text>[12]) [1074]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
   6[40]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=keywords[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=k#index[56]:integer
  14[56]: Text() var=k[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=k#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["keywords"]
  30[92]: VarInt(var[56]) -> integer var=k#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=102)
  60[80]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  63[92]: NewRecord(data: ref(reference), parent_tp=22, fld=9) -> ref(reference)
  68[92]: VarRef(var[84]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(SKeyword)["self"]
  71[104]: VarText(var[60]) -> text var=k[60]:text["_vector_1"]
  74[120]: SetText(v1: ref(reference), fld=4, val: text)
  77[92]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[104]: VarRef(var[84]) -> ref(reference) type=SKeyword[8]:{name:text[4]}[18] var=_elm_2[84]:ref(SKeyword)["self"]
  83[116]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=9)
  88[92]: FreeStack(value=0, discard=12)
  92[80]: FreeText(var[60])
  95[80]: FreeStack(value=0, discard=24)
  99[56]: GotoWord(jump=14)
 102[56]: FreeStack(value=0, discard=16)
 106[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_set_tokens(self:Lexer, tokens:vector<text>) {#block(1):void
  OpGetField(self(0), 32i32, 24i32);
  {#For block(2):void
    _vector_1(2):vector<text>["tokens"] = tokens(0);
    t#index(2):integer = -1i32;
    loop {#For loop_3
      t(3):text["_vector_1"] = {#iter next(4):text
        t#index(2):integer = OpAddInt(t#index(2), 1i32);
        OpGetText(OpGetVector(_vector_1(2), 4i32, t#index(2)), 0i32);
      }#iter next(4):text;
      if OpNot(OpConvBoolFromText(t(3))) {#break(5):void
        OpFreeText(t(3));
        break(0);
      }#break(5):void else null;
      {#block(6):void
        f(6):character = OpTextCharacter(t(3), 0i32);
        if OpNot(OpConvBoolFromCharacter(f(6))) {#block(7):void
          OpFreeText(t(3));
          continue(0);
        }#block(7):void else null;
        if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6))) {#block(8):void
          _elm_2(8):ref(Possible)["self"] = OpNewRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), 20i32, 1i32);
          OpSetInt(_elm_2(8), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_2(8), 4i32, t(3));
          OpFinishRecord(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, f(6)), _elm_2(8), 20i32, 1i32);
        }#block(8):void else {#block(9):void
          _elm_3(9):ref(SToken)["self"] = OpNewRecord(self(0), 22i32, 10i32);
          OpSetInt(_elm_3(9), 4i32, f(6));
          OpSetInt(_elm_3(9), 8i32, 0i32);
          _elm_4(9):ref(Possible)["_elm_3"] = OpNewRecord(_elm_3(9), 20i32, 1i32);
          OpSetInt(_elm_4(9), 0i32, _tp_text_len(t(3)));
          OpSetText(_elm_4(9), 4i32, t(3));
          OpFinishRecord(_elm_3(9), _elm_4(9), 20i32, 1i32);
          OpFinishRecord(self(0), _elm_3(9), 22i32, 10i32);
        }#block(9):void;
      }#block(6):void;
      OpFreeText(t(3));
    }#For loop_3;
  }#For block(2):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_set_tokens(self: ref(Lexer)[0], tokens: vector<text>[12]) [1186]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
   6[40]: VarVector(var[16]) -> vector type=vector<text>[4]:Vector(5)[7] var=tokens[16]:vector<text>
   9[52]: ConstInt(val=-1) -> integer var=t#index[56]:integer
  14[56]: Text() var=t[60]:text["_vector_1"]
  15[80]: VarInt(var[56]) -> integer var=t#index[56]:integer
  18[84]: ConstInt(val=1) -> integer
  23[88]: AddInt(v1: integer, v2: integer) -> integer
  24[84]: PutInt(var[56], value: integer)
  27[80]: VarVector(var[44]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vector_1[44]:vector<text>["tokens"]
  30[92]: VarInt(var[56]) -> integer var=t#index[56]:integer
  33[96]: GetVector(r: vector, size=4, index: integer) -> ref(reference) type=text[4]:Base[5]
  36[92]: GetText(v1: ref(reference), fld=0) -> text["self"]
  39[96]: AppendText(var[60], v1: text)
  42[80]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  45[96]: ConvBoolFromText(v1: text) -> boolean
  46[81]: Not(v1: boolean) -> boolean
  47[81]: GotoFalseWord(jump=60, if_false: boolean)
  50[80]: FreeText(var[60])
  53[80]: FreeStack(value=0, discard=24)
  57[56]: GotoWord(jump=276)
  60[80]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
  63[96]: ConstInt(val=0) -> integer
  68[100]: TextCharacter(v1: text, v2: integer) -> character
  69[84]: VarCharacter(var[84]) -> character var=f[84]:character
  72[88]: ConvBoolFromCharacter(v1: character) -> boolean
  73[85]: Not(v1: boolean) -> boolean
  74[85]: GotoFalseWord(jump=87, if_false: boolean)
  77[84]: FreeText(var[60])
  80[84]: FreeStack(value=0, discard=28)
  84[56]: GotoWord(jump=14)
  87[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  90[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
  93[96]: VarCharacter(var[84]) -> character var=f[84]:character
  96[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 100[96]: ConvBoolFromRef(val: ref(reference)) -> boolean
 101[85]: GotoFalseWord(jump=175, if_false: boolean)
 104[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 107[96]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 110[96]: VarCharacter(var[84]) -> character var=f[84]:character
 113[100]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 117[96]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 122[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 125[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 128[124]: Call(size=0, call=_tp_text_len[318])
 135[112]: SetInt(v1: ref(reference), fld=0, val: integer)
 138[96]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 141[108]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 144[124]: SetText(v1: ref(reference), fld=4, val: text)
 147[96]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 150[108]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
 153[108]: VarCharacter(var[84]) -> character var=f[84]:character
 156[112]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
 160[108]: VarRef(var[88]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_2[88]:ref(Possible)["self"]
 163[120]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 168[96]: FreeStack(value=0, discard=12)
 172[84]: GotoWord(jump=262)
 175[84]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 178[96]: NewRecord(data: ref(reference), parent_tp=22, fld=10) -> ref(reference)
 183[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 186[108]: VarCharacter(var[84]) -> character var=f[84]:character
 189[112]: SetInt(v1: ref(reference), fld=4, val: integer)
 192[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 195[108]: ConstInt(val=0) -> integer
 200[112]: SetInt(v1: ref(reference), fld=8, val: integer)
 203[96]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 206[108]: NewRecord(data: ref(reference), parent_tp=20, fld=1) -> ref(reference)
 211[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 214[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 217[136]: Call(size=0, call=_tp_text_len[318])
 224[124]: SetInt(v1: ref(reference), fld=0, val: integer)
 227[108]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 230[120]: VarText(var[60]) -> text var=t[60]:text["_vector_1"]
 233[136]: SetText(v1: ref(reference), fld=4, val: text)
 236[108]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 239[120]: VarRef(var[100]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=_elm_4[100]:ref(Possible)["_elm_3"]
 242[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=20, fld=1)
 247[108]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 250[120]: VarRef(var[88]) -> ref(reference) type=SToken[12]:{start:character[4], possible:sorted<Possible[-length,token]>[8]}[20] var=_elm_3[88]:ref(SToken)["self"]
 253[132]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=22, fld=10)
 258[108]: FreeStack(value=0, discard=24)
 262[84]: FreeStack(value=0, discard=4)
 266[80]: FreeText(var[60])
 269[80]: FreeStack(value=0, discard=24)
 273[56]: GotoWord(jump=14)
 276[56]: FreeStack(value=0, discard=16)
 280[40]: Return(ret=24, value=0, discard=40)

fn _tp_Lexer_skip_whitespace(self:Lexer) {#block(1):void
  {#For block(2):void
    t#index(2):integer = OpConvIntFromNull();
    loop {#For loop_3
      t(3):integer = {#Iter range(4):integer
        t#index(2):integer = if OpNot(OpConvBoolFromInt(t#index(2))) 0i32 else OpAddInt(t#index(2), 1i32);
        if OpGeInt(t#index(2), 300i32) break(0) else null;
        t#index(2);
      }#Iter range(4):integer;
      {#block(5):void
        if if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(32i32)) true else OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(9i32)) {#block(6):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
        }#block(6):void else if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(7):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
          OpSetInt(self(0), 16i32, OpAddInt(OpGetInt(self(0), 16i32), 1i32));
          OpSetInt(self(0), 20i32, 1i32);
        }#block(7):void else if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), 2i32)), "//") {#block(8):void
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 2i32));
          OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
          {#For block(9):void
            c#index(9):integer = OpConvIntFromNull();
            loop {#For loop_10
              c(10):integer = {#Iter range(11):integer
                c#index(9):integer = if OpNot(OpConvBoolFromInt(c#index(9))) 0i32 else OpAddInt(c#index(9), 1i32);
                if OpGeInt(c#index(9), 1000i32) break(0) else null;
                c#index(9);
              }#Iter range(11):integer;
              {#block(12):void
                if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(10i32)) {#block(13):void
                  break(0);
                }#block(13):void else null;
                OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
                OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), 1i32));
              }#block(12):void;
            }#For loop_10;
          }#For block(9):void;
        }#block(8):void else {#block(14):void
          break(0);
        }#block(14):void;
      }#block(5):void;
    }#For loop_3;
  }#For block(2):void;
  OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), OpMinInt(OpGetInt(self(0), 12i32), OpGetInt(self(0), 24i32))));
  OpSetInt(self(0), 24i32, OpGetInt(self(0), 12i32));
  OpSetEnum(self(0), 40i32, 1u8(17));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_skip_whitespace(self: ref(Lexer)[0]) [1472]
   0[12]: return-address
   0[16]: ConvIntFromNull() -> integer var=t#index[20]:integer
   1[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
   4[24]: ConvBoolFromInt(v1: integer) -> boolean
   5[21]: Not(v1: boolean) -> boolean
   6[21]: GotoFalseWord(jump=17, if_false: boolean)
   9[20]: ConstInt(val=0) -> integer
  14[24]: GotoWord(jump=26)
  17[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  20[24]: ConstInt(val=1) -> integer
  25[28]: AddInt(v1: integer, v2: integer) -> integer
  26[24]: PutInt(var[20], value: integer)
  29[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  32[24]: ConstInt(val=300) -> integer
  37[28]: GeInt(v1: integer, v2: integer) -> boolean
  38[21]: GotoFalseWord(jump=44, if_false: boolean)
  41[20]: GotoWord(jump=423)
  44[20]: VarInt(var[20]) -> integer var=t#index[20]:integer
  47[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  50[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
  53[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  56[52]: GetInt(v1: ref(reference), fld=12) -> integer
  59[44]: TextCharacter(v1: text, v2: integer) -> character
  60[28]: ConvIntFromCharacter(v1: character) -> integer
  61[28]: ConstInt(val=32) -> integer
  66[32]: ConvIntFromCharacter(v1: character) -> integer
  67[32]: EqInt(v1: integer, v2: integer) -> boolean
  68[25]: GotoFalseWord(jump=75, if_false: boolean)
  71[24]: ConstTrue() -> boolean
  72[25]: GotoWord(jump=96)
  75[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  78[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
  81[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  84[52]: GetInt(v1: ref(reference), fld=12) -> integer
  87[44]: TextCharacter(v1: text, v2: integer) -> character
  88[28]: ConvIntFromCharacter(v1: character) -> integer
  89[28]: ConstInt(val=9) -> integer
  94[32]: ConvIntFromCharacter(v1: character) -> integer
  95[32]: EqInt(v1: integer, v2: integer) -> boolean
  96[25]: GotoFalseWord(jump=138, if_false: boolean)
  99[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 102[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 105[48]: GetInt(v1: ref(reference), fld=12) -> integer
 108[40]: ConstInt(val=1) -> integer
 113[44]: AddInt(v1: integer, v2: integer) -> integer
 114[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 117[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 120[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 123[48]: GetInt(v1: ref(reference), fld=20) -> integer
 126[40]: ConstInt(val=1) -> integer
 131[44]: AddInt(v1: integer, v2: integer) -> integer
 132[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 135[24]: GotoWord(jump=416)
 138[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 141[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
 144[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 147[52]: GetInt(v1: ref(reference), fld=12) -> integer
 150[44]: TextCharacter(v1: text, v2: integer) -> character
 151[28]: ConvIntFromCharacter(v1: character) -> integer
 152[28]: ConstInt(val=10) -> integer
 157[32]: ConvIntFromCharacter(v1: character) -> integer
 158[32]: EqInt(v1: integer, v2: integer) -> boolean
 159[25]: GotoFalseWord(jump=212, if_false: boolean)
 162[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 165[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 168[48]: GetInt(v1: ref(reference), fld=12) -> integer
 171[40]: ConstInt(val=1) -> integer
 176[44]: AddInt(v1: integer, v2: integer) -> integer
 177[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 180[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 183[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 186[48]: GetInt(v1: ref(reference), fld=16) -> integer
 189[40]: ConstInt(val=1) -> integer
 194[44]: AddInt(v1: integer, v2: integer) -> integer
 195[40]: SetInt(v1: ref(reference), fld=16, val: integer)
 198[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 201[36]: ConstInt(val=1) -> integer
 206[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 209[24]: GotoWord(jump=416)
 212[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 215[36]: GetText(v1: ref(reference), fld=8) -> text["self"]
 218[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 221[52]: GetInt(v1: ref(reference), fld=12) -> integer
 224[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 227[56]: GetInt(v1: ref(reference), fld=12) -> integer
 230[48]: ConstInt(val=2) -> integer
 235[52]: AddInt(v1: integer, v2: integer) -> integer
 236[48]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 237[40]: ConstText(_value="//") -> text
 241[56]: EqText(v1: text, v2: text) -> boolean
 242[25]: GotoFalseWord(jump=409, if_false: boolean)
 245[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 248[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 251[48]: GetInt(v1: ref(reference), fld=12) -> integer
 254[40]: ConstInt(val=2) -> integer
 259[44]: AddInt(v1: integer, v2: integer) -> integer
 260[40]: SetInt(v1: ref(reference), fld=12, val: integer)
 263[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 266[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 269[48]: GetInt(v1: ref(reference), fld=20) -> integer
 272[40]: ConstInt(val=1) -> integer
 277[44]: AddInt(v1: integer, v2: integer) -> integer
 278[40]: SetInt(v1: ref(reference), fld=20, val: integer)
 281[24]: ConvIntFromNull() -> integer var=c#index[28]:integer
 282[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 285[32]: ConvBoolFromInt(v1: integer) -> boolean
 286[29]: Not(v1: boolean) -> boolean
 287[29]: GotoFalseWord(jump=298, if_false: boolean)
 290[28]: ConstInt(val=0) -> integer
 295[32]: GotoWord(jump=307)
 298[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 301[32]: ConstInt(val=1) -> integer
 306[36]: AddInt(v1: integer, v2: integer) -> integer
 307[32]: PutInt(var[28], value: integer)
 310[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 313[32]: ConstInt(val=1000) -> integer
 318[36]: GeInt(v1: integer, v2: integer) -> boolean
 319[29]: GotoFalseWord(jump=325, if_false: boolean)
 322[28]: GotoWord(jump=402)
 325[28]: VarInt(var[28]) -> integer var=c#index[28]:integer
 328[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 331[44]: GetText(v1: ref(reference), fld=8) -> text["self"]
 334[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 337[60]: GetInt(v1: ref(reference), fld=12) -> integer
 340[52]: TextCharacter(v1: text, v2: integer) -> character
 341[36]: ConvIntFromCharacter(v1: character) -> integer
 342[36]: ConstInt(val=10) -> integer
 347[40]: ConvIntFromCharacter(v1: character) -> integer
 348[40]: EqInt(v1: integer, v2: integer) -> boolean
 349[33]: GotoFalseWord(jump=359, if_false: boolean)
 352[32]: FreeStack(value=0, discard=4)
 356[28]: GotoWord(jump=402)
 359[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 362[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 365[56]: GetInt(v1: ref(reference), fld=12) -> integer
 368[48]: ConstInt(val=1) -> integer
 373[52]: AddInt(v1: integer, v2: integer) -> integer
 374[48]: SetInt(v1: ref(reference), fld=12, val: integer)
 377[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 380[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 383[56]: GetInt(v1: ref(reference), fld=20) -> integer
 386[48]: ConstInt(val=1) -> integer
 391[52]: AddInt(v1: integer, v2: integer) -> integer
 392[48]: SetInt(v1: ref(reference), fld=20, val: integer)
 395[32]: FreeStack(value=0, discard=4)
 399[28]: GotoWord(jump=282)
 402[28]: FreeStack(value=0, discard=4)
 406[24]: GotoWord(jump=416)
 409[24]: FreeStack(value=0, discard=4)
 413[20]: GotoWord(jump=423)
 416[24]: FreeStack(value=0, discard=4)
 420[20]: GotoWord(jump=1)
 423[20]: FreeStack(value=0, discard=4)
 427[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 430[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 433[40]: GetInt(v1: ref(reference), fld=20) -> integer
 436[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 439[44]: GetInt(v1: ref(reference), fld=12) -> integer
 442[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 445[48]: GetInt(v1: ref(reference), fld=24) -> integer
 448[40]: MinInt(v1: integer, v2: integer) -> integer
 449[36]: AddInt(v1: integer, v2: integer) -> integer
 450[32]: SetInt(v1: ref(reference), fld=20, val: integer)
 453[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 456[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 459[40]: GetInt(v1: ref(reference), fld=12) -> integer
 462[32]: SetInt(v1: ref(reference), fld=24, val: integer)
 465[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 468[28]: ConstEnum(val=1) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 470[29]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 473[16]: Return(ret=12, value=0, discard=16)

fn _tp_Lexer_scan(self:Lexer) {#block(1):void
  _tp_Lexer_skip_whitespace(self(0));
  negative(1):boolean = false;
  l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
  if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(2):void
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    OpSetEnum(self(0), 40i32, 8u8(17));
    {#For block(3):void
      t#index(3):integer = OpConvIntFromNull();
      loop {#For loop_4
        t(4):integer = {#Iter range(5):integer
          t#index(3):integer = if OpNot(OpConvBoolFromInt(t#index(3))) 0i32 else OpAddInt(t#index(3), 1i32);
          if OpGeInt(t#index(3), 20i32) break(0) else null;
          t#index(3);
        }#Iter range(5):integer;
        {#block(6):void
          l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(39i32)) {#block(7):void
            OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            return null;
          }#block(7):void else null;
          if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(8):void
            OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(39i32)) {#block(9):void
              OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(9):void else null;
          }#block(8):void else null;
        }#block(6):void;
      }#For loop_4;
    }#For block(3):void;
  }#block(2):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(10):void
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    OpSetEnum(self(0), 40i32, 6u8(17));
    {#For block(11):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_12
        t(12):integer = {#Iter range(13):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 60000i32) break(0) else null;
          t#index(11);
        }#Iter range(13):integer;
        {#block(14):void
          l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(34i32)) {#block(15):void
            OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            return null;
          }#block(15):void else null;
          if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(92i32)) {#block(16):void
            OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            n(16):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
            if if OpEqInt(OpConvIntFromCharacter(n(16)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(n(16)), OpConvIntFromCharacter(10i32)) {#block(17):void
              OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
            }#block(17):void else null;
          }#block(16):void else null;
        }#block(14):void;
      }#For loop_12;
    }#For block(11):void;
  }#block(10):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(18):void
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
    negative(1):boolean = true;
  }#block(18):void else null;
  if if OpGeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(48i32)) OpLeInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32))), OpConvIntFromCharacter(57i32)) else false {#block(19):void
    OpSetEnum(self(0), 40i32, 2u8(17));
    {#For block(20):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_21
        t(12):integer = {#Iter range(22):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 30i32) break(0) else null;
          t#index(11);
        }#Iter range(22):integer;
        {#block(23):void
          l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(46i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(101i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(45i32)) {#block(24):void
            OpSetEnum(self(0), 40i32, 3u8(17));
          }#block(24):void else if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(108i32)) {#block(25):void
            OpSetEnum(self(0), 40i32, 5u8(17));
          }#block(25):void else if if if OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(120i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(111i32)) true else OpEqInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(98i32))  else if if OpNeInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(95i32)) if OpLtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(48i32)) true else OpGtInt(OpConvIntFromCharacter(l(1)), OpConvIntFromCharacter(57i32)) else false {#block(27):void
            break(0);
          }#block(27):void else null;
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(23):void;
      }#For loop_21;
    }#For block(20):void;
  }#block(19):void else if _tp_character_is_alphabetic(l(1)) {#block(28):void
    OpSetEnum(self(0), 40i32, 9u8(17));
    {#For block(29):void
      t#index(11):integer = OpConvIntFromNull();
      loop {#For loop_30
        t(12):integer = {#Iter range(31):integer
          t#index(11):integer = if OpNot(OpConvBoolFromInt(t#index(11))) 0i32 else OpAddInt(t#index(11), 1i32);
          if OpGeInt(t#index(11), 300i32) break(0) else null;
          t#index(11);
        }#Iter range(31):integer;
        {#block(32):void
          l(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32));
          if OpNot(_tp_character_is_alphanumeric(l(1))) {#block(33):void
            break(0);
          }#block(33):void else null;
          OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
        }#block(32):void;
      }#For loop_30;
    }#For block(29):void;
  }#block(28):void else {#block(34):void
    if negative(1) {#block(35):void
      OpSetEnum(self(0), 40i32, 10u8(17));
    }#block(35):void else null;
    OpSetEnum(self(0), 40i32, 10u8(17));
    {#For block(36):void
      pt#index(36):integer = OpIterate(OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32, &[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], 0i32, 0i32);
      loop {#For loop_37
        pt(37):ref(Possible)["self"] = OpStep(pt#index(36), OpGetField(OpGetRecord(OpGetField(self(0), 32i32, 24i32), 24i32, 1i32, l(1)), 8i32, 21i32), 130i32, 8i32);
        if OpNot(OpConvBoolFromRef(pt(37))) {#break(38):void
          break(0);
        }#break(38):void else null;
        {#block(39):void
          tok(39):text["pt"] = OpGetText(pt(37), 4i32);
          if OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 12i32), OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(39)))), tok(39)) {#block(40):void
            OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(tok(39))));
            OpFreeText(tok(39));
            return null;
          }#block(40):void else null;
          OpFreeText(tok(39));
        }#block(39):void;
      }#For loop_37;
    }#For block(36):void;
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(34):void;
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_scan(self: ref(Lexer)[0]) [1951]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: Call(size=0, call=_tp_Lexer_skip_whitespace[1472])
  10[16]: ConstFalse() -> boolean var=negative[20]:boolean
  11[17]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[29]: GetText(v1: ref(reference), fld=8) -> text["self"]
  17[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  20[45]: GetInt(v1: ref(reference), fld=12) -> integer
  23[37]: TextCharacter(v1: text, v2: integer) -> character
  24[21]: VarCharacter(var[21]) -> character var=l[21]:character
  27[25]: ConvIntFromCharacter(v1: character) -> integer
  28[25]: ConstInt(val=39) -> integer
  33[29]: ConvIntFromCharacter(v1: character) -> integer
  34[29]: EqInt(v1: integer, v2: integer) -> boolean
  35[22]: GotoFalseWord(jump=259, if_false: boolean)
  38[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  41[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  44[45]: GetInt(v1: ref(reference), fld=12) -> integer
  47[37]: ConstInt(val=1) -> integer
  52[41]: AddInt(v1: integer, v2: integer) -> integer
  53[37]: SetInt(v1: ref(reference), fld=12, val: integer)
  56[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  59[33]: ConstEnum(val=8) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
  61[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
  64[21]: ConvIntFromNull() -> integer var=t#index[25]:integer
  65[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  68[29]: ConvBoolFromInt(v1: integer) -> boolean
  69[26]: Not(v1: boolean) -> boolean
  70[26]: GotoFalseWord(jump=81, if_false: boolean)
  73[25]: ConstInt(val=0) -> integer
  78[29]: GotoWord(jump=90)
  81[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  84[29]: ConstInt(val=1) -> integer
  89[33]: AddInt(v1: integer, v2: integer) -> integer
  90[29]: PutInt(var[25], value: integer)
  93[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
  96[29]: ConstInt(val=20) -> integer
 101[33]: GeInt(v1: integer, v2: integer) -> boolean
 102[26]: GotoFalseWord(jump=108, if_false: boolean)
 105[25]: GotoWord(jump=252)
 108[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 111[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 114[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 117[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 120[57]: GetInt(v1: ref(reference), fld=12) -> integer
 123[49]: TextCharacter(v1: text, v2: integer) -> character
 124[33]: PutCharacter(var[21], value: character)
 127[29]: VarCharacter(var[21]) -> character var=l[21]:character
 130[33]: ConvIntFromCharacter(v1: character) -> integer
 131[33]: ConstInt(val=39) -> integer
 136[37]: ConvIntFromCharacter(v1: character) -> integer
 137[37]: EqInt(v1: integer, v2: integer) -> boolean
 138[30]: GotoFalseWord(jump=171, if_false: boolean)
 141[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 144[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 147[53]: GetInt(v1: ref(reference), fld=12) -> integer
 150[45]: ConstInt(val=1) -> integer
 155[49]: AddInt(v1: integer, v2: integer) -> integer
 156[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 159[29]: Return(ret=12, value=0, discard=29)
 165[29]: Return(ret=12, value=0, discard=29)
 171[29]: VarCharacter(var[21]) -> character var=l[21]:character
 174[33]: ConvIntFromCharacter(v1: character) -> integer
 175[33]: ConstInt(val=92) -> integer
 180[37]: ConvIntFromCharacter(v1: character) -> integer
 181[37]: EqInt(v1: integer, v2: integer) -> boolean
 182[30]: GotoFalseWord(jump=245, if_false: boolean)
 185[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 188[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 191[53]: GetInt(v1: ref(reference), fld=12) -> integer
 194[45]: ConstInt(val=1) -> integer
 199[49]: AddInt(v1: integer, v2: integer) -> integer
 200[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 203[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 206[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 209[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 212[57]: GetInt(v1: ref(reference), fld=12) -> integer
 215[49]: TextCharacter(v1: text, v2: integer) -> character
 216[33]: ConvIntFromCharacter(v1: character) -> integer
 217[33]: ConstInt(val=39) -> integer
 222[37]: ConvIntFromCharacter(v1: character) -> integer
 223[37]: EqInt(v1: integer, v2: integer) -> boolean
 224[30]: GotoFalseWord(jump=245, if_false: boolean)
 227[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 230[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 233[53]: GetInt(v1: ref(reference), fld=12) -> integer
 236[45]: ConstInt(val=1) -> integer
 241[49]: AddInt(v1: integer, v2: integer) -> integer
 242[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 245[29]: FreeStack(value=0, discard=4)
 249[25]: GotoWord(jump=65)
 252[25]: FreeStack(value=0, discard=4)
 256[21]: GotoWord(jump=555)
 259[21]: VarCharacter(var[21]) -> character var=l[21]:character
 262[25]: ConvIntFromCharacter(v1: character) -> integer
 263[25]: ConstInt(val=34) -> integer
 268[29]: ConvIntFromCharacter(v1: character) -> integer
 269[29]: EqInt(v1: integer, v2: integer) -> boolean
 270[22]: GotoFalseWord(jump=519, if_false: boolean)
 273[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 276[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 279[45]: GetInt(v1: ref(reference), fld=12) -> integer
 282[37]: ConstInt(val=1) -> integer
 287[41]: AddInt(v1: integer, v2: integer) -> integer
 288[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 291[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 294[33]: ConstEnum(val=6) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 296[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 299[21]: ConvIntFromNull() -> integer var=t#index[25]:integer
 300[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 303[29]: ConvBoolFromInt(v1: integer) -> boolean
 304[26]: Not(v1: boolean) -> boolean
 305[26]: GotoFalseWord(jump=316, if_false: boolean)
 308[25]: ConstInt(val=0) -> integer
 313[29]: GotoWord(jump=325)
 316[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 319[29]: ConstInt(val=1) -> integer
 324[33]: AddInt(v1: integer, v2: integer) -> integer
 325[29]: PutInt(var[25], value: integer)
 328[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 331[29]: ConstInt(val=60000) -> integer
 336[33]: GeInt(v1: integer, v2: integer) -> boolean
 337[26]: GotoFalseWord(jump=343, if_false: boolean)
 340[25]: GotoWord(jump=512)
 343[25]: VarInt(var[25]) -> integer var=t#index[25]:integer
 346[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 349[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 352[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 355[57]: GetInt(v1: ref(reference), fld=12) -> integer
 358[49]: TextCharacter(v1: text, v2: integer) -> character
 359[33]: PutCharacter(var[21], value: character)
 362[29]: VarCharacter(var[21]) -> character var=l[21]:character
 365[33]: ConvIntFromCharacter(v1: character) -> integer
 366[33]: ConstInt(val=34) -> integer
 371[37]: ConvIntFromCharacter(v1: character) -> integer
 372[37]: EqInt(v1: integer, v2: integer) -> boolean
 373[30]: GotoFalseWord(jump=406, if_false: boolean)
 376[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 379[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 382[53]: GetInt(v1: ref(reference), fld=12) -> integer
 385[45]: ConstInt(val=1) -> integer
 390[49]: AddInt(v1: integer, v2: integer) -> integer
 391[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 394[29]: Return(ret=12, value=0, discard=29)
 400[29]: Return(ret=12, value=0, discard=29)
 406[29]: VarCharacter(var[21]) -> character var=l[21]:character
 409[33]: ConvIntFromCharacter(v1: character) -> integer
 410[33]: ConstInt(val=92) -> integer
 415[37]: ConvIntFromCharacter(v1: character) -> integer
 416[37]: EqInt(v1: integer, v2: integer) -> boolean
 417[30]: GotoFalseWord(jump=505, if_false: boolean)
 420[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 423[41]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 426[53]: GetInt(v1: ref(reference), fld=12) -> integer
 429[45]: ConstInt(val=1) -> integer
 434[49]: AddInt(v1: integer, v2: integer) -> integer
 435[45]: SetInt(v1: ref(reference), fld=12, val: integer)
 438[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 441[41]: GetText(v1: ref(reference), fld=8) -> text["self"]
 444[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 447[57]: GetInt(v1: ref(reference), fld=12) -> integer
 450[49]: TextCharacter(v1: text, v2: integer) -> character
 451[33]: VarCharacter(var[33]) -> character var=n[33]:character
 454[37]: ConvIntFromCharacter(v1: character) -> integer
 455[37]: ConstInt(val=34) -> integer
 460[41]: ConvIntFromCharacter(v1: character) -> integer
 461[41]: EqInt(v1: integer, v2: integer) -> boolean
 462[34]: GotoFalseWord(jump=469, if_false: boolean)
 465[33]: ConstTrue() -> boolean
 466[34]: GotoWord(jump=480)
 469[33]: VarCharacter(var[33]) -> character var=n[33]:character
 472[37]: ConvIntFromCharacter(v1: character) -> integer
 473[37]: ConstInt(val=10) -> integer
 478[41]: ConvIntFromCharacter(v1: character) -> integer
 479[41]: EqInt(v1: integer, v2: integer) -> boolean
 480[34]: GotoFalseWord(jump=501, if_false: boolean)
 483[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 486[45]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 489[57]: GetInt(v1: ref(reference), fld=12) -> integer
 492[49]: ConstInt(val=1) -> integer
 497[53]: AddInt(v1: integer, v2: integer) -> integer
 498[49]: SetInt(v1: ref(reference), fld=12, val: integer)
 501[33]: FreeStack(value=0, discard=4)
 505[29]: FreeStack(value=0, discard=4)
 509[25]: GotoWord(jump=300)
 512[25]: FreeStack(value=0, discard=4)
 516[21]: GotoWord(jump=555)
 519[21]: VarCharacter(var[21]) -> character var=l[21]:character
 522[25]: ConvIntFromCharacter(v1: character) -> integer
 523[25]: ConstInt(val=45) -> integer
 528[29]: ConvIntFromCharacter(v1: character) -> integer
 529[29]: EqInt(v1: integer, v2: integer) -> boolean
 530[22]: GotoFalseWord(jump=555, if_false: boolean)
 533[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 536[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 539[45]: GetInt(v1: ref(reference), fld=12) -> integer
 542[37]: ConstInt(val=1) -> integer
 547[41]: AddInt(v1: integer, v2: integer) -> integer
 548[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 551[21]: ConstTrue() -> boolean var=negative[20]:boolean
 552[22]: PutBool(var=6, value: boolean)
 555[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 558[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 561[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 564[49]: GetInt(v1: ref(reference), fld=12) -> integer
 567[41]: TextCharacter(v1: text, v2: integer) -> character
 568[25]: ConvIntFromCharacter(v1: character) -> integer
 569[25]: ConstInt(val=48) -> integer
 574[29]: ConvIntFromCharacter(v1: character) -> integer
 575[29]: GeInt(v1: integer, v2: integer) -> boolean
 576[22]: GotoFalseWord(jump=603, if_false: boolean)
 579[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 582[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 585[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 588[49]: GetInt(v1: ref(reference), fld=12) -> integer
 591[41]: TextCharacter(v1: text, v2: integer) -> character
 592[25]: ConvIntFromCharacter(v1: character) -> integer
 593[25]: ConstInt(val=57) -> integer
 598[29]: ConvIntFromCharacter(v1: character) -> integer
 599[29]: LeInt(v1: integer, v2: integer) -> boolean
 600[22]: GotoWord(jump=604)
 603[21]: ConstFalse() -> boolean
 604[22]: GotoFalseWord(jump=900, if_false: boolean)
 607[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 610[33]: ConstEnum(val=2) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 612[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 615[21]: ConvIntFromNull() -> integer var=t#index[25]:integer
 616[25]: PutInt(var[25], value: integer)
 619[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 622[25]: ConvBoolFromInt(v1: integer) -> boolean
 623[22]: Not(v1: boolean) -> boolean
 624[22]: GotoFalseWord(jump=635, if_false: boolean)
 627[21]: ConstInt(val=0) -> integer
 632[25]: GotoWord(jump=644)
 635[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 638[25]: ConstInt(val=1) -> integer
 643[29]: AddInt(v1: integer, v2: integer) -> integer
 644[25]: PutInt(var[25], value: integer)
 647[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 650[25]: ConstInt(val=30) -> integer
 655[29]: GeInt(v1: integer, v2: integer) -> boolean
 656[22]: GotoFalseWord(jump=662, if_false: boolean)
 659[21]: GotoWord(jump=897)
 662[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 665[25]: PutInt(var[29], value: integer)
 668[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 671[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 674[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 677[49]: GetInt(v1: ref(reference), fld=12) -> integer
 680[41]: TextCharacter(v1: text, v2: integer) -> character
 681[25]: PutCharacter(var[21], value: character)
 684[21]: VarCharacter(var[21]) -> character var=l[21]:character
 687[25]: ConvIntFromCharacter(v1: character) -> integer
 688[25]: ConstInt(val=46) -> integer
 693[29]: ConvIntFromCharacter(v1: character) -> integer
 694[29]: EqInt(v1: integer, v2: integer) -> boolean
 695[22]: GotoFalseWord(jump=702, if_false: boolean)
 698[21]: ConstTrue() -> boolean
 699[22]: GotoWord(jump=713)
 702[21]: VarCharacter(var[21]) -> character var=l[21]:character
 705[25]: ConvIntFromCharacter(v1: character) -> integer
 706[25]: ConstInt(val=101) -> integer
 711[29]: ConvIntFromCharacter(v1: character) -> integer
 712[29]: EqInt(v1: integer, v2: integer) -> boolean
 713[22]: GotoFalseWord(jump=720, if_false: boolean)
 716[21]: ConstTrue() -> boolean
 717[22]: GotoWord(jump=731)
 720[21]: VarCharacter(var[21]) -> character var=l[21]:character
 723[25]: ConvIntFromCharacter(v1: character) -> integer
 724[25]: ConstInt(val=45) -> integer
 729[29]: ConvIntFromCharacter(v1: character) -> integer
 730[29]: EqInt(v1: integer, v2: integer) -> boolean
 731[22]: GotoFalseWord(jump=745, if_false: boolean)
 734[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 737[33]: ConstEnum(val=3) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 739[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 742[21]: GotoWord(jump=876)
 745[21]: VarCharacter(var[21]) -> character var=l[21]:character
 748[25]: ConvIntFromCharacter(v1: character) -> integer
 749[25]: ConstInt(val=108) -> integer
 754[29]: ConvIntFromCharacter(v1: character) -> integer
 755[29]: EqInt(v1: integer, v2: integer) -> boolean
 756[22]: GotoFalseWord(jump=770, if_false: boolean)
 759[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 762[33]: ConstEnum(val=5) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 764[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 767[21]: GotoWord(jump=876)
 770[21]: VarCharacter(var[21]) -> character var=l[21]:character
 773[25]: ConvIntFromCharacter(v1: character) -> integer
 774[25]: ConstInt(val=120) -> integer
 779[29]: ConvIntFromCharacter(v1: character) -> integer
 780[29]: EqInt(v1: integer, v2: integer) -> boolean
 781[22]: GotoFalseWord(jump=788, if_false: boolean)
 784[21]: ConstTrue() -> boolean
 785[22]: GotoWord(jump=799)
 788[21]: VarCharacter(var[21]) -> character var=l[21]:character
 791[25]: ConvIntFromCharacter(v1: character) -> integer
 792[25]: ConstInt(val=111) -> integer
 797[29]: ConvIntFromCharacter(v1: character) -> integer
 798[29]: EqInt(v1: integer, v2: integer) -> boolean
 799[22]: GotoFalseWord(jump=806, if_false: boolean)
 802[21]: ConstTrue() -> boolean
 803[22]: GotoWord(jump=817)
 806[21]: VarCharacter(var[21]) -> character var=l[21]:character
 809[25]: ConvIntFromCharacter(v1: character) -> integer
 810[25]: ConstInt(val=98) -> integer
 815[29]: ConvIntFromCharacter(v1: character) -> integer
 816[29]: EqInt(v1: integer, v2: integer) -> boolean
 817[22]: GotoFalseWord(jump=823, if_false: boolean)
 820[21]: GotoWord(jump=876)
 823[21]: VarCharacter(var[21]) -> character var=l[21]:character
 826[25]: ConvIntFromCharacter(v1: character) -> integer
 827[25]: ConstInt(val=95) -> integer
 832[29]: ConvIntFromCharacter(v1: character) -> integer
 833[29]: NeInt(v1: integer, v2: integer) -> boolean
 834[22]: GotoFalseWord(jump=869, if_false: boolean)
 837[21]: VarCharacter(var[21]) -> character var=l[21]:character
 840[25]: ConvIntFromCharacter(v1: character) -> integer
 841[25]: ConstInt(val=48) -> integer
 846[29]: ConvIntFromCharacter(v1: character) -> integer
 847[29]: LtInt(v1: integer, v2: integer) -> boolean
 848[22]: GotoFalseWord(jump=855, if_false: boolean)
 851[21]: ConstTrue() -> boolean
 852[22]: GotoWord(jump=866)
 855[21]: VarCharacter(var[21]) -> character var=l[21]:character
 858[25]: ConvIntFromCharacter(v1: character) -> integer
 859[25]: ConstInt(val=57) -> integer
 864[29]: ConvIntFromCharacter(v1: character) -> integer
 865[29]: GtInt(v1: integer, v2: integer) -> boolean
 866[22]: GotoWord(jump=870)
 869[21]: ConstFalse() -> boolean
 870[22]: GotoFalseWord(jump=876, if_false: boolean)
 873[21]: GotoWord(jump=897)
 876[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 879[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 882[45]: GetInt(v1: ref(reference), fld=12) -> integer
 885[37]: ConstInt(val=1) -> integer
 890[41]: AddInt(v1: integer, v2: integer) -> integer
 891[37]: SetInt(v1: ref(reference), fld=12, val: integer)
 894[21]: GotoWord(jump=619)
 897[21]: GotoWord(jump=1232)
 900[21]: VarCharacter(var[21]) -> character var=l[21]:character
 903[25]: StaticCall(_tp_character_is_alphabetic)
 906[22]: GotoFalseWord(jump=1023, if_false: boolean)
 909[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 912[33]: ConstEnum(val=9) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
 914[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
 917[21]: ConvIntFromNull() -> integer var=t#index[25]:integer
 918[25]: PutInt(var[25], value: integer)
 921[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 924[25]: ConvBoolFromInt(v1: integer) -> boolean
 925[22]: Not(v1: boolean) -> boolean
 926[22]: GotoFalseWord(jump=937, if_false: boolean)
 929[21]: ConstInt(val=0) -> integer
 934[25]: GotoWord(jump=946)
 937[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 940[25]: ConstInt(val=1) -> integer
 945[29]: AddInt(v1: integer, v2: integer) -> integer
 946[25]: PutInt(var[25], value: integer)
 949[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 952[25]: ConstInt(val=300) -> integer
 957[29]: GeInt(v1: integer, v2: integer) -> boolean
 958[22]: GotoFalseWord(jump=964, if_false: boolean)
 961[21]: GotoWord(jump=1020)
 964[21]: VarInt(var[25]) -> integer var=t#index[25]:integer
 967[25]: PutInt(var[29], value: integer)
 970[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 973[33]: GetText(v1: ref(reference), fld=8) -> text["self"]
 976[37]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 979[49]: GetInt(v1: ref(reference), fld=12) -> integer
 982[41]: TextCharacter(v1: text, v2: integer) -> character
 983[25]: PutCharacter(var[21], value: character)
 986[21]: VarCharacter(var[21]) -> character var=l[21]:character
 989[25]: StaticCall(_tp_character_is_alphanumeric)
 992[22]: Not(v1: boolean) -> boolean
 993[22]: GotoFalseWord(jump=999, if_false: boolean)
 996[21]: GotoWord(jump=1020)
 999[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1002[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1005[45]: GetInt(v1: ref(reference), fld=12) -> integer
1008[37]: ConstInt(val=1) -> integer
1013[41]: AddInt(v1: integer, v2: integer) -> integer
1014[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1017[21]: GotoWord(jump=921)
1020[21]: GotoWord(jump=1232)
1023[21]: VarBool(var[20]) -> boolean var=negative[20]:boolean
1026[22]: GotoFalseWord(jump=1037, if_false: boolean)
1029[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1032[33]: ConstEnum(val=10) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
1034[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
1037[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1040[33]: ConstEnum(val=10) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
1042[34]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
1045[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1048[33]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1051[33]: VarCharacter(var[21]) -> character var=l[21]:character
1054[37]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1058[33]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1061[33]: Iterate(data: ref(reference), on=130, arg=8, keys=[Key { type_nr: -1, position: 0 }, Key { type_nr: 6, position: 4 }], from_key=0, till_key=0) -> long
1074[29]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1077[41]: GetField(v1: ref(reference), fld=32) -> ref(reference) type=hash<SToken[start]>[4]:Hash(20, [0]) keys [tp:7 desc:false field:4, ][24]
1080[41]: VarCharacter(var[21]) -> character var=l[21]:character
1083[45]: GetRecord(data: ref(reference), db_tp=24, no_keys=1) -> ref(reference)
1087[41]: GetField(v1: ref(reference), fld=8) -> ref(reference) type=sorted<Possible[-length,token]>[4]:Sorted(19, [(0, false), (1, true)]) keys [tp:1 desc:true field:0, tp:6 desc:false field:4, ][21]
1090[41]: Step(state_var=20, data: ref(reference), on=130, arg=8) -> ref(reference)
1096[41]: VarRef(var[33]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[33]:ref(Possible)["self"]
1099[53]: ConvBoolFromRef(val: ref(reference)) -> boolean
1100[42]: Not(v1: boolean) -> boolean
1101[42]: GotoFalseWord(jump=1111, if_false: boolean)
1104[41]: FreeStack(value=0, discard=12)
1108[29]: GotoWord(jump=1210)
1111[41]: Text() var=tok[45]:text["pt"]
1112[65]: VarRef(var[33]) -> ref(reference) type=Possible[8]:{length:integer[0], token:text[4]}[19] var=pt[33]:ref(Possible)["self"]
1115[77]: GetText(v1: ref(reference), fld=4) -> text["self"]
1118[81]: AppendText(var[45], v1: text)
1121[65]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1124[77]: GetText(v1: ref(reference), fld=8) -> text["self"]
1127[81]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1130[93]: GetInt(v1: ref(reference), fld=12) -> integer
1133[85]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1136[97]: GetInt(v1: ref(reference), fld=12) -> integer
1139[89]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1142[105]: Call(size=0, call=_tp_text_len[318])
1149[93]: AddInt(v1: integer, v2: integer) -> integer
1150[89]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
1151[81]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1154[97]: EqText(v1: text, v2: text) -> boolean
1155[66]: GotoFalseWord(jump=1196, if_false: boolean)
1158[65]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1161[77]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1164[89]: GetInt(v1: ref(reference), fld=12) -> integer
1167[81]: VarText(var[45]) -> text var=tok[45]:text["pt"]
1170[97]: Call(size=0, call=_tp_text_len[318])
1177[85]: AddInt(v1: integer, v2: integer) -> integer
1178[81]: SetInt(v1: ref(reference), fld=12, val: integer)
1181[65]: FreeText(var[45])
1184[65]: Return(ret=12, value=0, discard=65)
1190[65]: Return(ret=12, value=0, discard=65)
1196[65]: FreeText(var[45])
1199[65]: FreeStack(value=0, discard=24)
1203[41]: FreeStack(value=0, discard=12)
1207[29]: GotoWord(jump=1074)
1210[29]: FreeStack(value=0, discard=8)
1214[21]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1217[33]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
1220[45]: GetInt(v1: ref(reference), fld=12) -> integer
1223[37]: ConstInt(val=1) -> integer
1228[41]: AddInt(v1: integer, v2: integer) -> integer
1229[37]: SetInt(v1: ref(reference), fld=12, val: integer)
1232[21]: Return(ret=12, value=0, discard=21)

fn _tp_Lexer_parse(self:Lexer, filename:text) {#block(1):void
  __ref_1(1):ref(File) = null;
  __work_1(1):text = "";
  v(1):integer = _tp_text_rfind(filename(0), "/");
  OpSetText(self(0), 4i32, if OpConvBoolFromInt(v(1)) {#block(2):text["filename"]
    OpGetTextSub(filename(0), OpAddInt(v(1), 1i32), 2147483647i32);
  }#block(2):text["filename"] else {#block(3):text["filename"]
    filename(0);
  }#block(3):text["filename"]);
  OpSetText(self(0), 8i32, _tp_File_content(file(filename(0), __ref_1(1)), {#default ref(4):ref(reference)["__work_1"]
    OpCreateRef(__work_1(1));
  }#default ref(4):ref(reference)["__work_1"]));
  OpSetInt(self(0), 12i32, 0i32);
  OpSetInt(self(0), 16i32, 1i32);
  OpSetInt(self(0), 20i32, 1i32);
  _tp_Lexer_scan(self(0));
  OpFreeRef(__ref_1(1));
  OpFreeText(__work_1(1));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse(self: ref(Lexer)[0], filename: text[12]) [3189]
   0[28]: return-address
   0[32]: ConvRefFromNull() -> ref(reference) var=__ref_1[36]:ref(File)
   1[44]: Text() var=__work_1[48]:text
   2[68]: ArgText(var[16]) -> text var=filename[16]:text
   5[84]: ConstText(_value="/") -> text
   8[100]: StaticCall(_tp_text_rfind)
  11[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  14[84]: VarInt(var[72]) -> integer var=v[72]:integer
  17[88]: ConvBoolFromInt(v1: integer) -> boolean
  18[85]: GotoFalseWord(jump=42, if_false: boolean)
  21[84]: ArgText(var[16]) -> text var=filename[16]:text
  24[100]: VarInt(var[72]) -> integer var=v[72]:integer
  27[104]: ConstInt(val=1) -> integer
  32[108]: AddInt(v1: integer, v2: integer) -> integer
  33[104]: ConstInt(val=2147483647) -> integer
  38[108]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  39[100]: GotoWord(jump=45)
  42[84]: ArgText(var[16]) -> text var=filename[16]:text
  45[100]: SetText(v1: ref(reference), fld=4, val: text)
  48[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  51[84]: ArgText(var[16]) -> text var=filename[16]:text
  54[100]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
  57[112]: Call(size=0, call=file[695])
  64[96]: CreateRef(var[48]) -> ref(reference)
  67[108]: Call(size=0, call=_tp_File_content[414])
  74[100]: SetText(v1: ref(reference), fld=8, val: text)
  77[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[84]: ConstInt(val=0) -> integer
  85[88]: SetInt(v1: ref(reference), fld=12, val: integer)
  88[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  91[84]: ConstInt(val=1) -> integer
  96[88]: SetInt(v1: ref(reference), fld=16, val: integer)
  99[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 102[84]: ConstInt(val=1) -> integer
 107[88]: SetInt(v1: ref(reference), fld=20, val: integer)
 110[72]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 113[84]: Call(size=0, call=_tp_Lexer_scan[1951])
 120[72]: VarRef(var[36]) -> ref(reference) type=File[17]:{path:text[4], size:long[8], dir:boolean[16]}[13] var=__ref_1[36]:ref(File)
 123[84]: FreeRef(v1: ref(reference))
 124[72]: FreeText(var[48])
 127[72]: Return(ret=28, value=0, discard=72)

fn _tp_Lexer_parse_string(self:Lexer, name:text, content:text) {#block(1):void
  OpSetText(self(0), 4i32, name(0));
  OpSetText(self(0), 8i32, content(0));
  OpSetInt(self(0), 12i32, 0i32);
  OpSetInt(self(0), 16i32, 1i32);
  OpSetInt(self(0), 20i32, 1i32);
  _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_parse_string(self: ref(Lexer)[0], name: text[12], content: text[28]) [3322]
   0[44]: return-address
   0[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[60]: ArgText(var[16]) -> text var=name[16]:text
   6[76]: SetText(v1: ref(reference), fld=4, val: text)
   9[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[60]: ArgText(var[32]) -> text var=content[32]:text
  15[76]: SetText(v1: ref(reference), fld=8, val: text)
  18[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  21[60]: ConstInt(val=0) -> integer
  26[64]: SetInt(v1: ref(reference), fld=12, val: integer)
  29[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  32[60]: ConstInt(val=1) -> integer
  37[64]: SetInt(v1: ref(reference), fld=16, val: integer)
  40[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  43[60]: ConstInt(val=1) -> integer
  48[64]: SetInt(v1: ref(reference), fld=20, val: integer)
  51[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  54[60]: Call(size=0, call=_tp_Lexer_scan[1951])
  61[48]: Return(ret=44, value=0, discard=48)

fn _tp_Lexer_test(self:Lexer, with:text) -> boolean {#block(1):boolean
  _tp_Lexer_skip_whitespace(self(0));
  OpEqText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)), with(0));
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_test(self: ref(Lexer)[0], with: text[12]) [3389] -> boolean
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: Call(size=0, call=_tp_Lexer_skip_whitespace[1472])
  10[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  13[44]: GetText(v1: ref(reference), fld=8) -> text["self"]
  16[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  19[60]: GetInt(v1: ref(reference), fld=24) -> integer
  22[52]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  25[64]: GetInt(v1: ref(reference), fld=12) -> integer
  28[56]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  29[48]: ArgText(var[16]) -> text var=with[16]:text
  32[64]: EqText(v1: text, v2: text) -> boolean
  33[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_matches(self:Lexer, with:text) -> boolean {#block(1):boolean
  if _tp_Lexer_test(self(0), with(0)) {#block(2):boolean
    OpSetInt(self(0), 20i32, OpAddInt(OpGetInt(self(0), 20i32), _tp_text_len(with(0))));
    OpSetInt(self(0), 12i32, OpAddInt(OpGetInt(self(0), 12i32), _tp_text_len(with(0))));
    OpSetByte(self(0), 43i32, 0i32, if false 1i32 else 0i32);
    OpSetText(self(0), 36i32, "");
    true;
  }#block(2):boolean else {#block(3):boolean
    false;
  }#block(3):boolean;
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_matches(self: ref(Lexer)[0], with: text[12]) [3428] -> boolean
   0[28]: return-address
   0[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[44]: ArgText(var[16]) -> text var=with[16]:text
   6[60]: Call(size=0, call=_tp_Lexer_test[3389])
  13[33]: GotoFalseWord(jump=99, if_false: boolean)
  16[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  19[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  22[56]: GetInt(v1: ref(reference), fld=20) -> integer
  25[48]: ArgText(var[16]) -> text var=with[16]:text
  28[64]: Call(size=0, call=_tp_text_len[318])
  35[52]: AddInt(v1: integer, v2: integer) -> integer
  36[48]: SetInt(v1: ref(reference), fld=20, val: integer)
  39[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  42[44]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  45[56]: GetInt(v1: ref(reference), fld=12) -> integer
  48[48]: ArgText(var[16]) -> text var=with[16]:text
  51[64]: Call(size=0, call=_tp_text_len[318])
  58[52]: AddInt(v1: integer, v2: integer) -> integer
  59[48]: SetInt(v1: ref(reference), fld=12, val: integer)
  62[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  65[44]: ConstFalse() -> boolean
  66[45]: GotoFalseWord(jump=77, if_false: boolean)
  69[44]: ConstInt(val=1) -> integer
  74[48]: GotoWord(jump=82)
  77[44]: ConstInt(val=0) -> integer
  82[48]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
  87[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  90[44]: ConstText(_value="") -> text
  92[60]: SetText(v1: ref(reference), fld=36, val: text)
  95[32]: ConstTrue() -> boolean
  96[33]: GotoWord(jump=100)
  99[32]: ConstFalse() -> boolean
 100[33]: Return(ret=28, value=1, discard=33) type=boolean[1]:Base[4]

fn _tp_Lexer_peek(self:Lexer) -> text["self"] {#block(1):text["self"]
  OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_peek(self: ref(Lexer)[0]) [3534] -> text["self"]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   9[44]: GetInt(v1: ref(reference), fld=24) -> integer
  12[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[48]: GetInt(v1: ref(reference), fld=12) -> integer
  18[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  19[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_position(self:Lexer) -> text {#block(1):text
  __work_1(1):text = "";
  {#Formatted string(2):text
    __work_1(1):text = "";
    OpFormatText(__work_1(1), OpGetText(self(0), 4i32), 0i32, -1i32, 32i32);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 16i32), 10i32, 0i32, 32i32, false, false);
    OpAppendText(__work_1(1), ":");
    OpFormatInt(__work_1(1), OpGetInt(self(0), 20i32), 10i32, 0i32, 32i32, false, false);
    __work_1(1);
  }#Formatted string(2):text;
}#block(1):text

byte-code for lib/lexer.lav:_tp_Lexer_position(self: ref(Lexer)[0]) [3559] -> text
   0[12]: return-address
   0[16]: Text() var=__work_1[20]:text
   1[40]: ClearText(var[20]) var=__work_1[20]:text
   4[40]: ConstText(_value="") -> text
   6[56]: AppendText(var[20], v1: text)
   9[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[52]: GetText(v1: ref(reference), fld=4) -> text["self"]
  15[56]: ConstInt(val=0) -> integer
  20[60]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
  25[40]: ConstText(_value=":") -> text
  28[56]: AppendText(var[20], v1: text)
  31[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  34[52]: GetInt(v1: ref(reference), fld=16) -> integer
  37[44]: ConstInt(val=0) -> integer
  42[48]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  49[40]: ConstText(_value=":") -> text
  52[56]: AppendText(var[20], v1: text)
  55[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  58[52]: GetInt(v1: ref(reference), fld=20) -> integer
  61[44]: ConstInt(val=0) -> integer
  66[48]: FormatInt(var[20], val: integer, radix=10, width: integer, token=32, plus=false, note=false)
  73[40]: VarText(var[20]) -> text var=__work_1[20]:text
  76[56]: Return(ret=12, value=16, discard=56) type=text[4]:Base[5]

fn _tp_Lexer_identifier(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  result(0):&text = OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32));
  if OpConvBoolFromRef(OpGetRecord(OpGetField(self(0), 28i32, 23i32), 23i32, 1i32, result(0))) {#block(2):text
    OpConvTextFromNull();
  }#block(2):text else {#block(3):text
    _tp_Lexer_scan(self(0));
    result(0);
  }#block(3):text;
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_identifier(self: ref(Lexer)[0], result: &text[12]) [3641] -> text["result"]
   0[24]: return-address
   0[28]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
   3[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   6[52]: GetText(v1: ref(reference), fld=8) -> text["self"]
   9[56]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[68]: GetInt(v1: ref(reference), fld=24) -> integer
  15[60]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  18[72]: GetInt(v1: ref(reference), fld=12) -> integer
  21[64]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  22[56]: AppendRefText(r: ref(reference), fld=0, v1: text)
  25[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  28[40]: GetField(v1: ref(reference), fld=28) -> ref(reference) type=hash<SKeyword[name]>[4]:Hash(18, [0]) keys [tp:6 desc:false field:4, ][23]
  31[40]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
  34[52]: GetRefText(r: ref(reference), fld=0) -> text["self"]
  37[56]: GetRecord(data: ref(reference), db_tp=23, no_keys=1) -> ref(reference)
  41[40]: ConvBoolFromRef(val: ref(reference)) -> boolean
  42[29]: GotoFalseWord(jump=49, if_false: boolean)
  45[28]: ConvTextFromNull() -> text
  46[44]: GotoWord(jump=65)
  49[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  52[40]: Call(size=0, call=_tp_Lexer_scan[1951])
  59[28]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
  62[40]: GetRefText(r: ref(reference), fld=0) -> text["self"]
  65[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_int(self:Lexer) -> integer {#block(1):integer
  if OpNeEnum(OpGetEnum(self(0), 40i32), 2u8(17)) {#block(2):void
    return OpConvIntFromNull();
  }#block(2):void else null;
  result(1):integer = OpCastIntFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  if OpConvBoolFromInt(result(1)) {#block(3):integer
    _tp_Lexer_scan(self(0));
    result(1);
  }#block(3):integer else {#block(4):integer
    OpConvIntFromNull();
  }#block(4):integer;
}#block(1):integer

byte-code for lib/lexer.lav:_tp_Lexer_int(self: ref(Lexer)[0]) [3712] -> integer
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[17]: ConstEnum(val=2) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[17]: GotoFalseWord(jump=30, if_false: boolean)
  12[16]: ConvIntFromNull() -> integer
  13[20]: Return(ret=12, value=4, discard=20)
  19[20]: ConvIntFromNull() -> integer
  20[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]
  26[24]: FreeStack(value=0, discard=8)
  30[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  33[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  36[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  39[44]: GetInt(v1: ref(reference), fld=24) -> integer
  42[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  45[48]: GetInt(v1: ref(reference), fld=12) -> integer
  48[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  49[32]: CastIntFromText(v1: text) -> integer
  50[20]: VarInt(var[20]) -> integer var=result[20]:integer
  53[24]: ConvBoolFromInt(v1: integer) -> boolean
  54[21]: GotoFalseWord(jump=73, if_false: boolean)
  57[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  60[32]: Call(size=0, call=_tp_Lexer_scan[1951])
  67[20]: VarInt(var[20]) -> integer var=result[20]:integer
  70[24]: GotoWord(jump=74)
  73[20]: ConvIntFromNull() -> integer
  74[24]: Return(ret=12, value=4, discard=24) type=integer[4]:Base[0]

fn _tp_Lexer_long_int(self:Lexer) -> long {#block(1):long
  if if OpNeEnum(OpGetEnum(self(0), 40i32), 5u8(17)) OpNeEnum(OpGetEnum(self(0), 40i32), 2u8(17)) else false {#block(2):void
    return OpConvLongFromNull();
  }#block(2):void else null;
  result(1):long = OpCastLongFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  if OpConvBoolFromLong(result(1)) {#block(3):long
    _tp_Lexer_scan(self(0));
    result(1);
  }#block(3):long else {#block(4):long
    OpConvLongFromNull();
  }#block(4):long;
}#block(1):long

byte-code for lib/lexer.lav:_tp_Lexer_long_int(self: ref(Lexer)[0]) [3792] -> long
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[17]: ConstEnum(val=5) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[17]: GotoFalseWord(jump=24, if_false: boolean)
  12[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
  18[17]: ConstEnum(val=2) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
  20[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
  21[17]: GotoWord(jump=25)
  24[16]: ConstFalse() -> boolean
  25[17]: GotoFalseWord(jump=46, if_false: boolean)
  28[16]: ConvLongFromNull() -> long
  29[24]: Return(ret=12, value=8, discard=24)
  35[24]: ConvLongFromNull() -> long
  36[32]: Return(ret=12, value=8, discard=32) type=long[8]:Base[1]
  42[32]: FreeStack(value=0, discard=16)
  46[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  49[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  52[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  55[44]: GetInt(v1: ref(reference), fld=24) -> integer
  58[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  61[48]: GetInt(v1: ref(reference), fld=12) -> integer
  64[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  65[32]: CastLongFromText(v1: text) -> long
  66[24]: VarLong(var[20]) -> long var=result[20]:long
  69[32]: ConvBoolFromLong(v1: long) -> boolean
  70[25]: GotoFalseWord(jump=89, if_false: boolean)
  73[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  76[36]: Call(size=0, call=_tp_Lexer_scan[1951])
  83[24]: VarLong(var[20]) -> long var=result[20]:long
  86[32]: GotoWord(jump=90)
  89[24]: ConvLongFromNull() -> long
  90[32]: Return(ret=12, value=8, discard=32) type=long[8]:Base[1]

fn _tp_Lexer_long_float(self:Lexer) -> float {#block(1):float
  if OpNeEnum(OpGetEnum(self(0), 40i32), 3u8(17)) {#block(2):void
    return OpConvFloatFromNull();
  }#block(2):void else null;
  result(1):float = OpCastFloatFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  if OpConvBoolFromFloat(result(1)) {#block(3):float
    _tp_Lexer_scan(self(0));
    result(1);
  }#block(3):float else {#block(4):float
    OpConvFloatFromNull();
  }#block(4):float;
}#block(1):float

byte-code for lib/lexer.lav:_tp_Lexer_long_float(self: ref(Lexer)[0]) [3888] -> float
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[17]: ConstEnum(val=3) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[17]: GotoFalseWord(jump=30, if_false: boolean)
  12[16]: ConvFloatFromNull() -> float
  13[24]: Return(ret=12, value=8, discard=24)
  19[24]: ConvFloatFromNull() -> float
  20[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]
  26[32]: FreeStack(value=0, discard=16)
  30[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  33[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  36[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  39[44]: GetInt(v1: ref(reference), fld=24) -> integer
  42[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  45[48]: GetInt(v1: ref(reference), fld=12) -> integer
  48[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  49[32]: CastFloatFromText(v1: text) -> float
  50[24]: VarFloat(var[20]) -> float var=result[20]:float
  53[32]: ConvBoolFromFloat(v1: float) -> boolean
  54[25]: GotoFalseWord(jump=73, if_false: boolean)
  57[24]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  60[36]: Call(size=0, call=_tp_Lexer_scan[1951])
  67[24]: VarFloat(var[20]) -> float var=result[20]:float
  70[32]: GotoWord(jump=74)
  73[24]: ConvFloatFromNull() -> float
  74[32]: Return(ret=12, value=8, discard=32) type=float[8]:Base[3]

fn _tp_Lexer_single_float(self:Lexer) -> single {#block(1):single
  if OpNeEnum(OpGetEnum(self(0), 40i32), 3u8(17)) {#block(2):void
    return OpConvSingleFromNull();
  }#block(2):void else null;
  result(1):single = OpCastSingleFromText(OpGetTextSub(OpGetText(self(0), 8i32), OpGetInt(self(0), 24i32), OpGetInt(self(0), 12i32)));
  if OpConvBoolFromSingle(result(1)) {#block(3):single
    _tp_Lexer_scan(self(0));
    result(1);
  }#block(3):single else {#block(4):single
    OpConvSingleFromNull();
  }#block(4):single;
}#block(1):single

byte-code for lib/lexer.lav:_tp_Lexer_single_float(self: ref(Lexer)[0]) [3968] -> single
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[17]: ConstEnum(val=3) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[17]: GotoFalseWord(jump=30, if_false: boolean)
  12[16]: ConvSingleFromNull() -> single
  13[20]: Return(ret=12, value=4, discard=20)
  19[20]: ConvSingleFromNull() -> single
  20[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]
  26[24]: FreeStack(value=0, discard=8)
  30[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  33[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  36[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  39[44]: GetInt(v1: ref(reference), fld=24) -> integer
  42[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  45[48]: GetInt(v1: ref(reference), fld=12) -> integer
  48[40]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
  49[32]: CastSingleFromText(v1: text) -> single
  50[20]: VarSingle(var[20]) -> single var=result[20]:single
  53[24]: ConvBoolFromSingle(v1: single) -> boolean
  54[21]: GotoFalseWord(jump=73, if_false: boolean)
  57[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  60[32]: Call(size=0, call=_tp_Lexer_scan[1951])
  67[20]: VarSingle(var[20]) -> single var=result[20]:single
  70[24]: GotoWord(jump=74)
  73[20]: ConvSingleFromNull() -> single
  74[24]: Return(ret=12, value=4, discard=24) type=single[4]:Base[2]

fn _tp_Lexer_escaped(self:Lexer, i:integer) -> character {#block(1):character
  c(1):character = OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32));
  if if if if if if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(34i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(39i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(92i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(10i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(123i32)) true else OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(125i32)) {#block(2):character
    c(1);
  }#block(2):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(116i32)) {#block(3):character
    9i32;
  }#block(3):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(114i32)) {#block(4):character
    13i32;
  }#block(4):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(110i32)) {#block(5):character
    10i32;
  }#block(5):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(120i32)) {#block(6):character
    total(6):text["total"] = "";
    OpAppendText(total(6), "0");
    OpAppendText(total(6), OpGetTextSub(OpGetText(self(0), 8i32), OpAddInt(i(0), 1i32), OpAddInt(i(0), 4i32)));
    nr(6):integer = OpCastIntFromText(total(6));
    OpCastCharacterFromInt(nr(6));
    OpFreeText(total(6));
  }#block(6):character else if OpEqInt(OpConvIntFromCharacter(c(1)), OpConvIntFromCharacter(117i32)) {#block(7):character
    OpCastCharacterFromInt(0i32);
  }#block(7):character else {#block(8):character
    OpCastCharacterFromInt(0i32);
  }#block(8):character;
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_escaped(self: ref(Lexer)[0], i: integer[12]) [4048] -> character
   0[16]: return-address
   0[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[32]: GetText(v1: ref(reference), fld=8) -> text["self"]
   6[36]: VarInt(var[16]) -> integer var=i[16]:integer
   9[40]: ConstInt(val=1) -> integer
  14[44]: AddInt(v1: integer, v2: integer) -> integer
  15[40]: TextCharacter(v1: text, v2: integer) -> character
  16[24]: VarCharacter(var[24]) -> character var=c[24]:character
  19[28]: ConvIntFromCharacter(v1: character) -> integer
  20[28]: ConstInt(val=34) -> integer
  25[32]: ConvIntFromCharacter(v1: character) -> integer
  26[32]: EqInt(v1: integer, v2: integer) -> boolean
  27[25]: GotoFalseWord(jump=34, if_false: boolean)
  30[24]: ConstTrue() -> boolean
  31[25]: GotoWord(jump=45)
  34[24]: VarCharacter(var[24]) -> character var=c[24]:character
  37[28]: ConvIntFromCharacter(v1: character) -> integer
  38[28]: ConstInt(val=39) -> integer
  43[32]: ConvIntFromCharacter(v1: character) -> integer
  44[32]: EqInt(v1: integer, v2: integer) -> boolean
  45[25]: GotoFalseWord(jump=52, if_false: boolean)
  48[24]: ConstTrue() -> boolean
  49[25]: GotoWord(jump=63)
  52[24]: VarCharacter(var[24]) -> character var=c[24]:character
  55[28]: ConvIntFromCharacter(v1: character) -> integer
  56[28]: ConstInt(val=92) -> integer
  61[32]: ConvIntFromCharacter(v1: character) -> integer
  62[32]: EqInt(v1: integer, v2: integer) -> boolean
  63[25]: GotoFalseWord(jump=70, if_false: boolean)
  66[24]: ConstTrue() -> boolean
  67[25]: GotoWord(jump=81)
  70[24]: VarCharacter(var[24]) -> character var=c[24]:character
  73[28]: ConvIntFromCharacter(v1: character) -> integer
  74[28]: ConstInt(val=10) -> integer
  79[32]: ConvIntFromCharacter(v1: character) -> integer
  80[32]: EqInt(v1: integer, v2: integer) -> boolean
  81[25]: GotoFalseWord(jump=88, if_false: boolean)
  84[24]: ConstTrue() -> boolean
  85[25]: GotoWord(jump=99)
  88[24]: VarCharacter(var[24]) -> character var=c[24]:character
  91[28]: ConvIntFromCharacter(v1: character) -> integer
  92[28]: ConstInt(val=123) -> integer
  97[32]: ConvIntFromCharacter(v1: character) -> integer
  98[32]: EqInt(v1: integer, v2: integer) -> boolean
  99[25]: GotoFalseWord(jump=106, if_false: boolean)
 102[24]: ConstTrue() -> boolean
 103[25]: GotoWord(jump=117)
 106[24]: VarCharacter(var[24]) -> character var=c[24]:character
 109[28]: ConvIntFromCharacter(v1: character) -> integer
 110[28]: ConstInt(val=125) -> integer
 115[32]: ConvIntFromCharacter(v1: character) -> integer
 116[32]: EqInt(v1: integer, v2: integer) -> boolean
 117[25]: GotoFalseWord(jump=126, if_false: boolean)
 120[24]: VarCharacter(var[24]) -> character var=c[24]:character
 123[28]: GotoWord(jump=288)
 126[24]: VarCharacter(var[24]) -> character var=c[24]:character
 129[28]: ConvIntFromCharacter(v1: character) -> integer
 130[28]: ConstInt(val=116) -> integer
 135[32]: ConvIntFromCharacter(v1: character) -> integer
 136[32]: EqInt(v1: integer, v2: integer) -> boolean
 137[25]: GotoFalseWord(jump=148, if_false: boolean)
 140[24]: ConstInt(val=9) -> integer
 145[28]: GotoWord(jump=288)
 148[24]: VarCharacter(var[24]) -> character var=c[24]:character
 151[28]: ConvIntFromCharacter(v1: character) -> integer
 152[28]: ConstInt(val=114) -> integer
 157[32]: ConvIntFromCharacter(v1: character) -> integer
 158[32]: EqInt(v1: integer, v2: integer) -> boolean
 159[25]: GotoFalseWord(jump=170, if_false: boolean)
 162[24]: ConstInt(val=13) -> integer
 167[28]: GotoWord(jump=288)
 170[24]: VarCharacter(var[24]) -> character var=c[24]:character
 173[28]: ConvIntFromCharacter(v1: character) -> integer
 174[28]: ConstInt(val=110) -> integer
 179[32]: ConvIntFromCharacter(v1: character) -> integer
 180[32]: EqInt(v1: integer, v2: integer) -> boolean
 181[25]: GotoFalseWord(jump=192, if_false: boolean)
 184[24]: ConstInt(val=10) -> integer
 189[28]: GotoWord(jump=288)
 192[24]: VarCharacter(var[24]) -> character var=c[24]:character
 195[28]: ConvIntFromCharacter(v1: character) -> integer
 196[28]: ConstInt(val=120) -> integer
 201[32]: ConvIntFromCharacter(v1: character) -> integer
 202[32]: EqInt(v1: integer, v2: integer) -> boolean
 203[25]: GotoFalseWord(jump=259, if_false: boolean)
 206[24]: Text() var=total[28]:text["total"]
 207[48]: ConstText(_value="0") -> text
 210[64]: AppendText(var[28], v1: text)
 213[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 216[60]: GetText(v1: ref(reference), fld=8) -> text["self"]
 219[64]: VarInt(var[16]) -> integer var=i[16]:integer
 222[68]: ConstInt(val=1) -> integer
 227[72]: AddInt(v1: integer, v2: integer) -> integer
 228[68]: VarInt(var[16]) -> integer var=i[16]:integer
 231[72]: ConstInt(val=4) -> integer
 236[76]: AddInt(v1: integer, v2: integer) -> integer
 237[72]: GetTextSub(v1: text, from: integer, till: integer) -> text["self"]
 238[64]: AppendText(var[28], v1: text)
 241[48]: VarText(var[28]) -> text var=total[28]:text["total"]
 244[64]: CastIntFromText(v1: text) -> integer
 245[52]: VarInt(var[52]) -> integer var=nr[52]:integer
 248[56]: CastCharacterFromInt(v1: integer) -> character
 249[56]: FreeText(var[28])
 252[56]: FreeStack(value=4, discard=32)
 256[28]: GotoWord(jump=288)
 259[24]: VarCharacter(var[24]) -> character var=c[24]:character
 262[28]: ConvIntFromCharacter(v1: character) -> integer
 263[28]: ConstInt(val=117) -> integer
 268[32]: ConvIntFromCharacter(v1: character) -> integer
 269[32]: EqInt(v1: integer, v2: integer) -> boolean
 270[25]: GotoFalseWord(jump=282, if_false: boolean)
 273[24]: ConstInt(val=0) -> integer
 278[28]: CastCharacterFromInt(v1: integer) -> character
 279[28]: GotoWord(jump=288)
 282[24]: ConstInt(val=0) -> integer
 287[28]: CastCharacterFromInt(v1: integer) -> character
 288[28]: Return(ret=16, value=4, discard=28) type=character[4]:Base[6]

fn _tp_Lexer_constant_text(self:Lexer, result:&text) -> text["result"] {#block(1):text["result"]
  if OpNeEnum(OpGetEnum(self(0), 40i32), 6u8(17)) {#block(2):void
    return OpConvTextFromNull();
  }#block(2):void else null;
  result(0):&text = "";
  {#For block(3):void
    i#index(3):integer = OpConvIntFromNull();
    loop {#For loop_4
      i(4):integer = {#Iter range(5):integer
        i#index(3):integer = if OpNot(OpConvBoolFromInt(i#index(3))) OpAddInt(OpGetInt(self(0), 24i32), 1i32) else OpAddInt(i#index(3), 1i32);
        if OpGeInt(i#index(3), OpMinInt(OpGetInt(self(0), 12i32), 1i32)) break(0) else null;
        i#index(3);
      }#Iter range(5):integer;
      {#block(6):void
        if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), i(4))), OpConvIntFromCharacter(92i32)) {#block(7):void
          OpAppendRefText(OpVarRef(result(0)), 0i32, "");
          OpAppendRefText(OpVarRef(result(0)), 0i32, _tp_Lexer_escaped(self(0), i(4)));
        }#block(7):void else {#block(8):void
          OpAppendRefText(OpVarRef(result(0)), 0i32, "");
          OpAppendRefText(OpVarRef(result(0)), 0i32, OpTextCharacter(OpGetText(self(0), 8i32), i(4)));
        }#block(8):void;
      }#block(6):void;
    }#For loop_4;
  }#For block(3):void;
  _tp_Lexer_scan(self(0));
  result(0);
}#block(1):text["result"]

byte-code for lib/lexer.lav:_tp_Lexer_constant_text(self: ref(Lexer)[0], result: &text[12]) [4342] -> text["result"]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[29]: ConstEnum(val=6) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[30]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[29]: GotoFalseWord(jump=30, if_false: boolean)
  12[28]: ConvTextFromNull() -> text
  13[44]: Return(ret=24, value=16, discard=44)
  19[44]: ConvTextFromNull() -> text
  20[60]: Return(ret=24, value=16, discard=60) type=text[4]:Base[5]
  26[60]: FreeStack(value=0, discard=32)
  30[28]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
  33[40]: ConstText(_value="") -> text
  35[56]: AppendRefText(r: ref(reference), fld=0, v1: text)
  38[28]: ConvIntFromNull() -> integer var=i#index[32]:integer
  39[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  42[36]: ConvBoolFromInt(v1: integer) -> boolean
  43[33]: Not(v1: boolean) -> boolean
  44[33]: GotoFalseWord(jump=62, if_false: boolean)
  47[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  50[44]: GetInt(v1: ref(reference), fld=24) -> integer
  53[36]: ConstInt(val=1) -> integer
  58[40]: AddInt(v1: integer, v2: integer) -> integer
  59[36]: GotoWord(jump=71)
  62[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  65[36]: ConstInt(val=1) -> integer
  70[40]: AddInt(v1: integer, v2: integer) -> integer
  71[36]: PutInt(var[32], value: integer)
  74[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  77[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  80[48]: GetInt(v1: ref(reference), fld=12) -> integer
  83[40]: ConstInt(val=1) -> integer
  88[44]: MinInt(v1: integer, v2: integer) -> integer
  89[40]: GeInt(v1: integer, v2: integer) -> boolean
  90[33]: GotoFalseWord(jump=96, if_false: boolean)
  93[32]: GotoWord(jump=181)
  96[32]: VarInt(var[32]) -> integer var=i#index[32]:integer
  99[36]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 102[48]: GetText(v1: ref(reference), fld=8) -> text["self"]
 105[52]: VarInt(var[36]) -> integer var=i[36]:integer
 108[56]: TextCharacter(v1: text, v2: integer) -> character
 109[40]: ConvIntFromCharacter(v1: character) -> integer
 110[40]: ConstInt(val=92) -> integer
 115[44]: ConvIntFromCharacter(v1: character) -> integer
 116[44]: EqInt(v1: integer, v2: integer) -> boolean
 117[37]: GotoFalseWord(jump=150, if_false: boolean)
 120[36]: VarRef(var[16]) -> ref(reference)
 123[48]: ConstText(_value="") -> text
 125[64]: AppendRefText(r: ref(reference), fld=0, v1: text)
 128[36]: VarRef(var[16]) -> ref(reference)
 131[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 134[60]: VarInt(var[36]) -> integer var=i[36]:integer
 137[64]: Call(size=0, call=_tp_Lexer_escaped[4048])
 144[52]: AppendRefText(r: ref(reference), fld=0, v1: text)
 147[36]: GotoWord(jump=174)
 150[36]: VarRef(var[16]) -> ref(reference)
 153[48]: ConstText(_value="") -> text
 155[64]: AppendRefText(r: ref(reference), fld=0, v1: text)
 158[36]: VarRef(var[16]) -> ref(reference)
 161[48]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 164[60]: GetText(v1: ref(reference), fld=8) -> text["self"]
 167[64]: VarInt(var[36]) -> integer var=i[36]:integer
 170[68]: TextCharacter(v1: text, v2: integer) -> character
 171[52]: AppendRefText(r: ref(reference), fld=0, v1: text)
 174[36]: FreeStack(value=0, discard=4)
 178[32]: GotoWord(jump=39)
 181[32]: FreeStack(value=0, discard=4)
 185[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 188[40]: Call(size=0, call=_tp_Lexer_scan[1951])
 195[28]: VarRef(var[16]) -> ref(reference) var=result[16]:&text
 198[40]: GetRefText(r: ref(reference), fld=0) -> text["self"]
 201[44]: Return(ret=24, value=16, discard=44) type=text[4]:Base[5]

fn _tp_Lexer_constant_character(self:Lexer) -> character {#block(1):character
  if OpNeEnum(OpGetEnum(self(0), 40i32), 8u8(17)) {#block(2):void
    return OpCastCharacterFromInt(0i32);
  }#block(2):void else null;
  result(1):character = if OpEqInt(OpConvIntFromCharacter(OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 12i32), 1i32))), OpConvIntFromCharacter(92i32)) {#block(3):character
    _tp_Lexer_escaped(self(0), OpAddInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(3):character else {#block(4):character
    OpTextCharacter(OpGetText(self(0), 8i32), OpAddInt(OpGetInt(self(0), 12i32), 1i32));
  }#block(4):character;
  _tp_Lexer_scan(self(0));
  result(1);
}#block(1):character

byte-code for lib/lexer.lav:_tp_Lexer_constant_character(self: ref(Lexer)[0]) [4549] -> character
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetEnum(v1: ref(reference), fld=40) -> enumerate
   6[17]: ConstEnum(val=8) -> enumerate type=Scanned[1]:Enum(["Unknown", "Integer", "Float", "Double", "Long", "Text", "Partial", "Character", "Identifier", "Token", "Keyword"])[17]
   8[18]: NeEnum(v1: enumerate, v2: enumerate) -> boolean
   9[17]: GotoFalseWord(jump=40, if_false: boolean)
  12[16]: ConstInt(val=0) -> integer
  17[20]: CastCharacterFromInt(v1: integer) -> character
  18[20]: Return(ret=12, value=4, discard=20)
  24[20]: ConstInt(val=0) -> integer
  29[24]: CastCharacterFromInt(v1: integer) -> character
  30[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]
  36[24]: FreeStack(value=0, discard=8)
  40[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  43[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
  46[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  49[44]: GetInt(v1: ref(reference), fld=12) -> integer
  52[36]: ConstInt(val=1) -> integer
  57[40]: AddInt(v1: integer, v2: integer) -> integer
  58[36]: TextCharacter(v1: text, v2: integer) -> character
  59[20]: ConvIntFromCharacter(v1: character) -> integer
  60[20]: ConstInt(val=92) -> integer
  65[24]: ConvIntFromCharacter(v1: character) -> integer
  66[24]: EqInt(v1: integer, v2: integer) -> boolean
  67[17]: GotoFalseWord(jump=95, if_false: boolean)
  70[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  73[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  76[40]: GetInt(v1: ref(reference), fld=12) -> integer
  79[32]: ConstInt(val=1) -> integer
  84[36]: AddInt(v1: integer, v2: integer) -> integer
  85[32]: Call(size=0, call=_tp_Lexer_escaped[4048])
  92[20]: GotoWord(jump=114)
  95[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  98[28]: GetText(v1: ref(reference), fld=8) -> text["self"]
 101[32]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 104[44]: GetInt(v1: ref(reference), fld=12) -> integer
 107[36]: ConstInt(val=1) -> integer
 112[40]: AddInt(v1: integer, v2: integer) -> integer
 113[36]: TextCharacter(v1: text, v2: integer) -> character
 114[20]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
 117[32]: Call(size=0, call=_tp_Lexer_scan[1951])
 124[20]: VarCharacter(var[20]) -> character var=result[20]:character
 127[24]: Return(ret=12, value=4, discard=24) type=character[4]:Base[6]

fn _tp_Lexer_string_finished(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 42i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_string_finished(self: ref(Lexer)[0]) [4682] -> boolean
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=42, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_last_comment(self:Lexer) -> text["self"] {#block(1):text["self"]
  OpGetText(self(0), 36i32);
}#block(1):text["self"]

byte-code for lib/lexer.lav:_tp_Lexer_last_comment(self: ref(Lexer)[0]) [4702] -> text["self"]
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetText(v1: ref(reference), fld=36) -> text["self"]
   6[32]: Return(ret=12, value=16, discard=32) type=text[4]:Base[5]

fn _tp_Lexer_comment_behind(self:Lexer) -> boolean {#block(1):boolean
  OpEqInt(OpGetByte(self(0), 43i32, 0i32), 1i32);
}#block(1):boolean

byte-code for lib/lexer.lav:_tp_Lexer_comment_behind(self: ref(Lexer)[0]) [4714] -> boolean
   0[12]: return-address
   0[16]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[28]: GetByte(v1: ref(reference), fld=43, min=0) -> integer
   8[20]: ConstInt(val=1) -> integer
  13[24]: EqInt(v1: integer, v2: integer) -> boolean
  14[17]: Return(ret=12, value=1, discard=17) type=boolean[1]:Base[4]

fn _tp_Lexer_anchor(self:Lexer) -> Anchor {#block(1):ref(Anchor)
  __ref_1(1):ref(Anchor) = null;
  {#Object(2):ref(Anchor)["__ref_1"]
    OpDatabase(__ref_1(1), 25i32);
    OpSetInt(__ref_1(1), 4i32, OpGetInt(self(0), 12i32));
    OpSetInt(__ref_1(1), 8i32, OpGetInt(self(0), 16i32));
    OpSetInt(__ref_1(1), 12i32, OpGetInt(self(0), 20i32));
    __ref_1(1);
  }#Object(2):ref(Anchor)["__ref_1"];
}#block(1):ref(Anchor)

byte-code for lib/lexer.lav:_tp_Lexer_anchor(self: ref(Lexer)[0]) [4734] -> ref(Anchor)
   0[12]: return-address
   0[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(Anchor)
   1[28]: Database(var[20], db_tp=25) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]
   6[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
   9[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  12[52]: GetInt(v1: ref(reference), fld=12) -> integer
  15[44]: SetInt(v1: ref(reference), fld=4, val: integer)
  18[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  21[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  24[52]: GetInt(v1: ref(reference), fld=16) -> integer
  27[44]: SetInt(v1: ref(reference), fld=8, val: integer)
  30[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  33[40]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  36[52]: GetInt(v1: ref(reference), fld=20) -> integer
  39[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  42[28]: VarRef(var[20]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=__ref_1[20]:ref(Anchor)
  45[40]: Return(ret=12, value=12, discard=40) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25]

fn _tp_Lexer_revert(self:Lexer, to:Anchor) {#block(1):void
  OpSetInt(self(0), 12i32, OpGetInt(to(0), 4i32));
  OpSetInt(self(0), 16i32, OpGetInt(to(0), 8i32));
  OpSetInt(self(0), 20i32, OpGetInt(to(0), 12i32));
  _tp_Lexer_scan(self(0));
}#block(1):void

byte-code for lib/lexer.lav:_tp_Lexer_revert(self: ref(Lexer)[0], to: ref(Anchor)[12]) [4785]
   0[24]: return-address
   0[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
   3[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
   6[52]: GetInt(v1: ref(reference), fld=4) -> integer
   9[44]: SetInt(v1: ref(reference), fld=12, val: integer)
  12[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  15[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  18[52]: GetInt(v1: ref(reference), fld=8) -> integer
  21[44]: SetInt(v1: ref(reference), fld=16, val: integer)
  24[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  27[40]: VarRef(var[16]) -> ref(reference) type=Anchor[16]:{index:integer[4], line:integer[8], pos:integer[12]}[25] var=to[16]:ref(Anchor)
  30[52]: GetInt(v1: ref(reference), fld=12) -> integer
  33[44]: SetInt(v1: ref(reference), fld=20, val: integer)
  36[28]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=self[4]:ref(Lexer)
  39[40]: Call(size=0, call=_tp_Lexer_scan[1951])
  46[28]: Return(ret=24, value=0, discard=28)

fn testing(l:Lexer) {#block(1):void
  __work_2(1):text = "";
  __work_1(1):text = "";
  if OpNot(_tp_Lexer_matches(l(0), "+")) null else OpPanic("Incorrect plus");
  if OpNeText(_tp_Lexer_peek(l(0)), "+") null else OpPanic("Incorrect plus");
  if _tp_Lexer_matches(l(0), "+=") null else OpPanic("Incorrect plus_is");
  if OpEqInt(_tp_Lexer_int(l(0)), OpMinSingleInt(2i32)) null else OpPanic("Integer");
  if _tp_Lexer_matches(l(0), "*") null else OpPanic("Incorrect multi");
  if OpNeInt(_tp_Lexer_int(l(0)), 3i32) null else OpPanic("Incorrect integer");
  if OpEqLong(_tp_Lexer_long_int(l(0)), OpConvLongFromInt(3i32)) null else OpPanic("Incorrect long");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:14") null else OpPanic({#Formatted string(2):text
    __work_1(1):text = "Incorrect position ";
    OpFormatText(__work_1(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_1(1);
  }#Formatted string(2):text);
  if OpNot(_tp_Lexer_matches(l(0), ">")) null else OpPanic("Incorrect higher");
  if OpEqText(_tp_Lexer_position(l(0)), "Tokens:1:15") null else OpPanic({#Formatted string(3):text
    __work_2(1):text = "Incorrect position ";
    OpFormatText(__work_2(1), _tp_Lexer_position(l(0)), 0i32, -1i32, 32i32);
    __work_2(1);
  }#Formatted string(3):text);
  if _tp_Lexer_matches(l(0), ">>") null else OpPanic("Incorrect logical shift");
  OpFreeText(__work_1(1));
  OpFreeText(__work_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:testing(l: ref(Lexer)[0]) [4837]
   0[12]: return-address
   0[16]: Text() var=__work_2[20]:text
   1[40]: Text() var=__work_1[44]:text
   2[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
   5[76]: ConstText(_value="+") -> text
   8[92]: Call(size=0, call=_tp_Lexer_matches[3428])
  15[65]: Not(v1: boolean) -> boolean
  16[65]: GotoFalseWord(jump=22, if_false: boolean)
  19[64]: GotoWord(jump=39)
  22[64]: ConstText(_value="Incorrect plus") -> text
  38[80]: Panic(message: text)
  39[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
  42[76]: Call(size=0, call=_tp_Lexer_peek[3534])
  49[80]: ConstText(_value="+") -> text
  52[96]: NeText(v1: text, v2: text) -> boolean
  53[65]: GotoFalseWord(jump=59, if_false: boolean)
  56[64]: GotoWord(jump=76)
  59[64]: ConstText(_value="Incorrect plus") -> text
  75[80]: Panic(message: text)
  76[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
  79[76]: ConstText(_value="+=") -> text
  83[92]: Call(size=0, call=_tp_Lexer_matches[3428])
  90[65]: GotoFalseWord(jump=96, if_false: boolean)
  93[64]: GotoWord(jump=116)
  96[64]: ConstText(_value="Incorrect plus_is") -> text
 115[80]: Panic(message: text)
 116[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 119[76]: Call(size=0, call=_tp_Lexer_int[3712])
 126[68]: ConstInt(val=2) -> integer
 131[72]: MinSingleInt(v1: integer) -> integer
 132[72]: EqInt(v1: integer, v2: integer) -> boolean
 133[65]: GotoFalseWord(jump=139, if_false: boolean)
 136[64]: GotoWord(jump=149)
 139[64]: ConstText(_value="Integer") -> text
 148[80]: Panic(message: text)
 149[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 152[76]: ConstText(_value="*") -> text
 155[92]: Call(size=0, call=_tp_Lexer_matches[3428])
 162[65]: GotoFalseWord(jump=168, if_false: boolean)
 165[64]: GotoWord(jump=186)
 168[64]: ConstText(_value="Incorrect multi") -> text
 185[80]: Panic(message: text)
 186[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 189[76]: Call(size=0, call=_tp_Lexer_int[3712])
 196[68]: ConstInt(val=3) -> integer
 201[72]: NeInt(v1: integer, v2: integer) -> boolean
 202[65]: GotoFalseWord(jump=208, if_false: boolean)
 205[64]: GotoWord(jump=228)
 208[64]: ConstText(_value="Incorrect integer") -> text
 227[80]: Panic(message: text)
 228[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 231[76]: Call(size=0, call=_tp_Lexer_long_int[3792])
 238[72]: ConstInt(val=3) -> integer
 243[76]: ConvLongFromInt(v1: integer) -> long
 244[80]: EqLong(v1: long, v2: long) -> boolean
 245[65]: GotoFalseWord(jump=251, if_false: boolean)
 248[64]: GotoWord(jump=268)
 251[64]: ConstText(_value="Incorrect long") -> text
 267[80]: Panic(message: text)
 268[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 271[76]: Call(size=0, call=_tp_Lexer_position[3559])
 278[80]: ConstText(_value="Tokens:1:14") -> text
 291[96]: EqText(v1: text, v2: text) -> boolean
 292[65]: GotoFalseWord(jump=298, if_false: boolean)
 295[64]: GotoWord(jump=349)
 298[64]: ClearText(var[44]) var=__work_1[44]:text
 301[64]: ConstText(_value="Incorrect position ") -> text
 322[80]: AppendText(var[44], v1: text)
 325[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 328[76]: Call(size=0, call=_tp_Lexer_position[3559])
 335[80]: ConstInt(val=0) -> integer
 340[84]: FormatText(var[44], val: text, width: integer, dir=-1, token=32)
 345[64]: VarText(var[44]) -> text var=__work_1[44]:text
 348[80]: Panic(message: text)
 349[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 352[76]: ConstText(_value=">") -> text
 355[92]: Call(size=0, call=_tp_Lexer_matches[3428])
 362[65]: Not(v1: boolean) -> boolean
 363[65]: GotoFalseWord(jump=369, if_false: boolean)
 366[64]: GotoWord(jump=388)
 369[64]: ConstText(_value="Incorrect higher") -> text
 387[80]: Panic(message: text)
 388[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 391[76]: Call(size=0, call=_tp_Lexer_position[3559])
 398[80]: ConstText(_value="Tokens:1:15") -> text
 411[96]: EqText(v1: text, v2: text) -> boolean
 412[65]: GotoFalseWord(jump=418, if_false: boolean)
 415[64]: GotoWord(jump=469)
 418[64]: ClearText(var[20]) var=__work_2[20]:text
 421[64]: ConstText(_value="Incorrect position ") -> text
 442[80]: AppendText(var[20], v1: text)
 445[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 448[76]: Call(size=0, call=_tp_Lexer_position[3559])
 455[80]: ConstInt(val=0) -> integer
 460[84]: FormatText(var[20], val: text, width: integer, dir=-1, token=32)
 465[64]: VarText(var[20]) -> text var=__work_2[20]:text
 468[80]: Panic(message: text)
 469[64]: VarRef(var[4]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[4]:ref(Lexer)
 472[76]: ConstText(_value=">>") -> text
 476[92]: Call(size=0, call=_tp_Lexer_matches[3428])
 483[65]: GotoFalseWord(jump=489, if_false: boolean)
 486[64]: GotoWord(jump=515)
 489[64]: ConstText(_value="Incorrect logical shift") -> text
 514[80]: Panic(message: text)
 515[64]: FreeText(var[44])
 518[64]: FreeText(var[20])
 521[64]: Return(ret=12, value=0, discard=64)

fn main() {#block(1):void
  __ref_2(1):ref(main_vector<text>) = null;
  __ref_1(1):ref(main_vector<text>) = null;
  l(1):ref(Lexer) = null;
  OpDatabase(l(1), 22i32);
  OpSetText(l(1), 4i32, "");
  OpSetText(l(1), 8i32, "");
  OpSetInt(l(1), 12i32, 0i32);
  OpSetInt(l(1), 16i32, 0i32);
  OpSetInt(l(1), 20i32, 0i32);
  OpSetInt(l(1), 24i32, 0i32);
  OpSetEnum(l(1), 40i32, 0i32);
  OpSetByte(l(1), 41i32, 0i32, if false 1i32 else 0i32);
  OpSetByte(l(1), 42i32, 0i32, if false 1i32 else 0i32);
  OpSetInt(l(1), 28i32, 0i32);
  OpSetInt(l(1), 32i32, 0i32);
  OpSetByte(l(1), 43i32, 0i32, if false 1i32 else 0i32);
  OpSetText(l(1), 36i32, "");
  _tp_Lexer_set_tokens(l(1), {#Vector(2):vector<text>
    OpDatabase(__ref_1(1), 14i32);
    _vec_1(2):vector<text>["__ref_1"] = OpGetField(__ref_1(1), 4i32, 7i32);
    OpSetInt(__ref_1(1), 4i32, 0i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "+=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "*=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "-=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "!=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "==");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "<<");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "->");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "=>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, ">>>");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "..=");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "&&");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _elm_2(2):ref(boolean)["_vec_1"] = OpNewRecord(_vec_1(2), 7i32, 65535i32);
    OpSetText(_elm_2(2), 0i32, "||");
    OpFinishRecord(_vec_1(2), _elm_2(2), 7i32, 65535i32);
    _vec_1(2);
  }#Vector(2):vector<text>);
  _tp_Lexer_set_keywords(l(1), {#Vector(3):vector<text>
    OpDatabase(__ref_2(1), 14i32);
    _vec_3(3):vector<text>["__ref_2"] = OpGetField(__ref_2(1), 4i32, 7i32);
    OpSetInt(__ref_2(1), 4i32, 0i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "for");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "in");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "if");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "else");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "fn");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "pub");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "use");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "struct");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "enum");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "match");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "and");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _elm_4(3):ref(boolean)["_vec_3"] = OpNewRecord(_vec_3(3), 7i32, 65535i32);
    OpSetText(_elm_4(3), 0i32, "or");
    OpFinishRecord(_vec_3(3), _elm_4(3), 7i32, 65535i32);
    _vec_3(3);
  }#Vector(3):vector<text>);
  _tp_Lexer_parse_string(l(1), "Tokens", "12 += -2 * 3l >> 4");
  if OpEqInt(_tp_Lexer_int(l(1)), 12i32) null else OpPanic("Integer");
  if OpNot(_tp_Lexer_matches(l(1), "+")) null else OpPanic("Incorrect plus");
  OpFreeRef(l(1));
  OpFreeRef(__ref_1(1));
  OpFreeRef(__ref_2(1));
}#block(1):void

byte-code for tests/suite/15-lexer.lav:main() [5364]
   0[0]: return-address
   0[4]: ConvRefFromNull() -> ref(reference) var=__ref_2[8]:ref(main_vector<text>)
   1[16]: ConvRefFromNull() -> ref(reference) var=__ref_1[20]:ref(main_vector<text>)
   2[28]: ConvRefFromNull() -> ref(reference) var=l[32]:ref(Lexer)
   3[40]: Database(var[32], db_tp=22) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22]
   8[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  11[52]: ConstText(_value="") -> text
  13[68]: SetText(v1: ref(reference), fld=4, val: text)
  16[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  19[52]: ConstText(_value="") -> text
  21[68]: SetText(v1: ref(reference), fld=8, val: text)
  24[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  27[52]: ConstInt(val=0) -> integer
  32[56]: SetInt(v1: ref(reference), fld=12, val: integer)
  35[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  38[52]: ConstInt(val=0) -> integer
  43[56]: SetInt(v1: ref(reference), fld=16, val: integer)
  46[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  49[52]: ConstInt(val=0) -> integer
  54[56]: SetInt(v1: ref(reference), fld=20, val: integer)
  57[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  60[52]: ConstInt(val=0) -> integer
  65[56]: SetInt(v1: ref(reference), fld=24, val: integer)
  68[40]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  71[52]: ConstInt(val=0) -> integer
  76[56]: SetEnum(v1: ref(reference), fld=40, val: enumerate)
  79[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
  82[55]: ConstFalse() -> boolean
  83[56]: GotoFalseWord(jump=94, if_false: boolean)
  86[55]: ConstInt(val=1) -> integer
  91[59]: GotoWord(jump=99)
  94[55]: ConstInt(val=0) -> integer
  99[59]: SetByte(v1: ref(reference), fld=41, min=0, val: integer)
 104[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 107[55]: ConstFalse() -> boolean
 108[56]: GotoFalseWord(jump=119, if_false: boolean)
 111[55]: ConstInt(val=1) -> integer
 116[59]: GotoWord(jump=124)
 119[55]: ConstInt(val=0) -> integer
 124[59]: SetByte(v1: ref(reference), fld=42, min=0, val: integer)
 129[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 132[55]: ConstInt(val=0) -> integer
 137[59]: SetInt(v1: ref(reference), fld=28, val: integer)
 140[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 143[55]: ConstInt(val=0) -> integer
 148[59]: SetInt(v1: ref(reference), fld=32, val: integer)
 151[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 154[55]: ConstFalse() -> boolean
 155[56]: GotoFalseWord(jump=166, if_false: boolean)
 158[55]: ConstInt(val=1) -> integer
 163[59]: GotoWord(jump=171)
 166[55]: ConstInt(val=0) -> integer
 171[59]: SetByte(v1: ref(reference), fld=43, min=0, val: integer)
 176[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 179[55]: ConstText(_value="") -> text
 181[71]: SetText(v1: ref(reference), fld=36, val: text)
 184[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 187[55]: Database(var[20], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 192[55]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
 195[67]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 198[67]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
 201[79]: ConstInt(val=0) -> integer
 206[83]: SetInt(v1: ref(reference), fld=4, val: integer)
 209[67]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 212[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 217[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 220[91]: ConstText(_value="+=") -> text
 224[107]: SetText(v1: ref(reference), fld=0, val: text)
 227[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 230[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 233[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 238[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 241[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 246[91]: PutRef(var[71], value: ref(reference))
 249[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 252[91]: ConstText(_value="*=") -> text
 256[107]: SetText(v1: ref(reference), fld=0, val: text)
 259[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 262[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 265[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 270[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 273[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 278[91]: PutRef(var[71], value: ref(reference))
 281[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 284[91]: ConstText(_value="-=") -> text
 288[107]: SetText(v1: ref(reference), fld=0, val: text)
 291[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 294[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 297[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 302[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 305[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 310[91]: PutRef(var[71], value: ref(reference))
 313[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 316[91]: ConstText(_value="<=") -> text
 320[107]: SetText(v1: ref(reference), fld=0, val: text)
 323[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 326[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 329[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 334[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 337[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 342[91]: PutRef(var[71], value: ref(reference))
 345[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 348[91]: ConstText(_value=">=") -> text
 352[107]: SetText(v1: ref(reference), fld=0, val: text)
 355[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 358[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 361[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 366[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 369[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 374[91]: PutRef(var[71], value: ref(reference))
 377[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 380[91]: ConstText(_value="!=") -> text
 384[107]: SetText(v1: ref(reference), fld=0, val: text)
 387[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 390[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 393[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 398[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 401[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 406[91]: PutRef(var[71], value: ref(reference))
 409[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 412[91]: ConstText(_value="==") -> text
 416[107]: SetText(v1: ref(reference), fld=0, val: text)
 419[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 422[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 425[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 430[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 433[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 438[91]: PutRef(var[71], value: ref(reference))
 441[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 444[91]: ConstText(_value=">>") -> text
 448[107]: SetText(v1: ref(reference), fld=0, val: text)
 451[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 454[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 457[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 462[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 465[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 470[91]: PutRef(var[71], value: ref(reference))
 473[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 476[91]: ConstText(_value="<<") -> text
 480[107]: SetText(v1: ref(reference), fld=0, val: text)
 483[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 486[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 489[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 494[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 497[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 502[91]: PutRef(var[71], value: ref(reference))
 505[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 508[91]: ConstText(_value="->") -> text
 512[107]: SetText(v1: ref(reference), fld=0, val: text)
 515[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 518[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 521[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 526[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 529[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 534[91]: PutRef(var[71], value: ref(reference))
 537[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 540[91]: ConstText(_value="=>") -> text
 544[107]: SetText(v1: ref(reference), fld=0, val: text)
 547[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 550[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 553[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 558[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 561[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 566[91]: PutRef(var[71], value: ref(reference))
 569[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 572[91]: ConstText(_value=">>>") -> text
 577[107]: SetText(v1: ref(reference), fld=0, val: text)
 580[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 583[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 586[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 591[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 594[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 599[91]: PutRef(var[71], value: ref(reference))
 602[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 605[91]: ConstText(_value="..") -> text
 609[107]: SetText(v1: ref(reference), fld=0, val: text)
 612[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 615[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 618[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 623[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 626[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 631[91]: PutRef(var[71], value: ref(reference))
 634[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 637[91]: ConstText(_value="..=") -> text
 642[107]: SetText(v1: ref(reference), fld=0, val: text)
 645[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 648[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 651[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 656[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 659[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 664[91]: PutRef(var[71], value: ref(reference))
 667[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 670[91]: ConstText(_value="&&") -> text
 674[107]: SetText(v1: ref(reference), fld=0, val: text)
 677[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 680[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 683[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 688[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 691[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 696[91]: PutRef(var[71], value: ref(reference))
 699[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 702[91]: ConstText(_value="||") -> text
 706[107]: SetText(v1: ref(reference), fld=0, val: text)
 709[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 712[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_2[71]:ref(boolean)["_vec_1"]
 715[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 720[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_1[59]:vector<text>["__ref_1"]
 723[91]: FreeStack(value=12, discard=36)
 727[67]: Call(size=0, call=_tp_Lexer_set_tokens[1186])
 734[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
 737[55]: Database(var[8], db_tp=14) type=main_vector<text>[8]:{vector:vector<text>[4]}[14]
 742[55]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
 745[67]: GetField(v1: ref(reference), fld=4) -> ref(reference) type=vector<text>[4]:Vector(5)[7]
 748[67]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
 751[79]: ConstInt(val=0) -> integer
 756[83]: SetInt(v1: ref(reference), fld=4, val: integer)
 759[67]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 762[79]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 767[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 770[91]: ConstText(_value="for") -> text
 775[107]: SetText(v1: ref(reference), fld=0, val: text)
 778[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 781[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 784[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 789[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 792[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 797[91]: PutRef(var[71], value: ref(reference))
 800[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 803[91]: ConstText(_value="in") -> text
 807[107]: SetText(v1: ref(reference), fld=0, val: text)
 810[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 813[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 816[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 821[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 824[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 829[91]: PutRef(var[71], value: ref(reference))
 832[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 835[91]: ConstText(_value="if") -> text
 839[107]: SetText(v1: ref(reference), fld=0, val: text)
 842[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 845[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 848[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 853[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 856[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 861[91]: PutRef(var[71], value: ref(reference))
 864[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 867[91]: ConstText(_value="else") -> text
 873[107]: SetText(v1: ref(reference), fld=0, val: text)
 876[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 879[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 882[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 887[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 890[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 895[91]: PutRef(var[71], value: ref(reference))
 898[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 901[91]: ConstText(_value="fn") -> text
 905[107]: SetText(v1: ref(reference), fld=0, val: text)
 908[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 911[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 914[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 919[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 922[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 927[91]: PutRef(var[71], value: ref(reference))
 930[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 933[91]: ConstText(_value="pub") -> text
 938[107]: SetText(v1: ref(reference), fld=0, val: text)
 941[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 944[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 947[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 952[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 955[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 960[91]: PutRef(var[71], value: ref(reference))
 963[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 966[91]: ConstText(_value="use") -> text
 971[107]: SetText(v1: ref(reference), fld=0, val: text)
 974[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 977[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 980[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
 985[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
 988[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
 993[91]: PutRef(var[71], value: ref(reference))
 996[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
 999[91]: ConstText(_value="struct") -> text
1007[107]: SetText(v1: ref(reference), fld=0, val: text)
1010[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1013[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1016[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1021[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1024[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1029[91]: PutRef(var[71], value: ref(reference))
1032[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1035[91]: ConstText(_value="enum") -> text
1041[107]: SetText(v1: ref(reference), fld=0, val: text)
1044[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1047[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1050[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1055[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1058[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1063[91]: PutRef(var[71], value: ref(reference))
1066[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1069[91]: ConstText(_value="match") -> text
1076[107]: SetText(v1: ref(reference), fld=0, val: text)
1079[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1082[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1085[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1090[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1093[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1098[91]: PutRef(var[71], value: ref(reference))
1101[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1104[91]: ConstText(_value="and") -> text
1109[107]: SetText(v1: ref(reference), fld=0, val: text)
1112[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1115[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1118[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1123[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1126[91]: NewRecord(data: ref(reference), parent_tp=7, fld=65535) -> ref(reference)
1131[91]: PutRef(var[71], value: ref(reference))
1134[79]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1137[91]: ConstText(_value="or") -> text
1141[107]: SetText(v1: ref(reference), fld=0, val: text)
1144[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1147[91]: VarRef(var[71]) -> ref(reference) type=boolean[1]:Base[4] var=_elm_4[71]:ref(boolean)["_vec_3"]
1150[103]: FinishRecord(data: ref(reference), rec: ref(reference), parent_tp=7, fld=65535)
1155[79]: VarVector(var[59]) -> vector type=vector<text>[4]:Vector(5)[7] var=_vec_3[59]:vector<text>["__ref_2"]
1158[91]: FreeStack(value=12, discard=36)
1162[67]: Call(size=0, call=_tp_Lexer_set_keywords[1074])
1169[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
1172[55]: ConstText(_value="Tokens") -> text
1180[71]: ConstText(_value="12 += -2 * 3l >> 4") -> text
1200[87]: Call(size=0, call=_tp_Lexer_parse_string[3322])
1207[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
1210[55]: Call(size=0, call=_tp_Lexer_int[3712])
1217[47]: ConstInt(val=12) -> integer
1222[51]: EqInt(v1: integer, v2: integer) -> boolean
1223[44]: GotoFalseWord(jump=1229, if_false: boolean)
1226[43]: GotoWord(jump=1239)
1229[43]: ConstText(_value="Integer") -> text
1238[59]: Panic(message: text)
1239[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
1242[55]: ConstText(_value="+") -> text
1245[71]: Call(size=0, call=_tp_Lexer_matches[3428])
1252[44]: Not(v1: boolean) -> boolean
1253[44]: GotoFalseWord(jump=1259, if_false: boolean)
1256[43]: GotoWord(jump=1276)
1259[43]: ConstText(_value="Incorrect plus") -> text
1275[59]: Panic(message: text)
1276[43]: VarRef(var[32]) -> ref(reference) type=Lexer[44]:{file:text[4], data:text[8], index:integer[12], line:integer[16], pos:integer[20], start:integer[24], scanned:Scanned[40], string:boolean[41], finished:boolean[42], keywords:hash<SKeyword[name]>[28], tokens:hash<SToken[start]>[32], behind:boolean[43], comment:text[36]}[22] var=l[32]:ref(Lexer)
1279[55]: FreeRef(v1: ref(reference))
1280[43]: VarRef(var[20]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_1[20]:ref(main_vector<text>)
1283[55]: FreeRef(v1: ref(reference))
1284[43]: VarRef(var[8]) -> ref(reference) type=main_vector<text>[8]:{vector:vector<text>[4]}[14] var=__ref_2[8]:ref(main_vector<text>)
1287[55]: FreeRef(v1: ref(reference))
1288[43]: Return(ret=0, value=0, discard=43)

Execute main:
    0:[8] ConvRefFromNull() -> ref(1,0,0)[8]
    1:[20] ConvRefFromNull() -> ref(2,0,0)[20]
    2:[32] ConvRefFromNull() -> ref(3,0,0)[32]
    3:[44] Database(var[32], db_tp=22)
    8:[44] VarRef(var[32]) -> ref(3,1,0)={string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   11:[56] ConstText(_value="") -> ""[56]
   13:[72] SetText(v1=ref(3,1,0)[44], fld=4, val=""[56])
   16:[44] VarRef(var[32]) -> ref(3,1,0)={string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   19:[56] ConstText(_value="") -> ""[56]
   21:[72] SetText(v1=ref(3,1,0)[44], fld=8, val=""[56])
   24:[44] VarRef(var[32]) -> ref(3,1,0)={string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   27:[56] ConstInt(val=0) -> 0[56]
   32:[60] SetInt(v1=ref(3,1,0)[44], fld=12, val=0[56])
   35:[44] VarRef(var[32]) -> ref(3,1,0)={index:0,string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   38:[56] ConstInt(val=0) -> 0[56]
   43:[60] SetInt(v1=ref(3,1,0)[44], fld=16, val=0[56])
   46:[44] VarRef(var[32]) -> ref(3,1,0)={index:0,line:0,string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   49:[56] ConstInt(val=0) -> 0[56]
   54:[60] SetInt(v1=ref(3,1,0)[44], fld=20, val=0[56])
   57:[44] VarRef(var[32]) -> ref(3,1,0)={index:0,line:0,pos:0,string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   60:[56] ConstInt(val=0) -> 0[56]
   65:[60] SetInt(v1=ref(3,1,0)[44], fld=24, val=0[56])
   68:[44] VarRef(var[32]) -> ref(3,1,0)={index:0,line:0,pos:0,start:0,string:false,finished:false,keywords:[],tokens:[],behind:false}[44]
   71:[56] ConstInt(val=0) -> 0[56]
   76:[60] SetEnum(v1=ref(0,0,768)[47], fld=40, val=0[59])