// Copyright (c) 2025 Jurjen Stellingwerff
// SPDX-License-Identifier: LGPL-3.0-or-later

use crate::data::{Block, Data, DefType, Type, Value, v_set};
use crate::variables::Function;
use std::collections::{BTreeMap, HashMap, HashSet};

struct Scopes {
    /// The definition number of the current analyzed function.
    d_nr: u32,
    /// The next scope number that will be created.
    max_scope: u16,
    /// The current scope during traversal of the code. 0 is the scope of the function arguments.
    scope: u16,
    /// The currently open scopes.
    stack: Vec<u16>,
    /// Per encountered variable the scope where it was created. Later copied into the definition.
    var_scope: BTreeMap<u16, u16>,
    /// Variables that are redefined after running out-of-scope gets copied with this mapping.
    var_mapping: HashMap<u16, u16>,
    /// The scopes of the currently traversed loops.
    loops: Vec<u16>,
}

/// Perform scope analysis on all currently known function.
pub fn check(data: &mut Data) {
    for d_nr in 0..data.definitions() {
        if !matches!(data.def(d_nr).def_type, DefType::Function) || data.def(d_nr).variables.done {
            continue;
        }
        let mut scopes = Scopes {
            d_nr,
            max_scope: 1,
            scope: 0,
            stack: Vec::new(),
            var_scope: BTreeMap::new(),
            var_mapping: HashMap::new(),
            loops: vec![],
        };
        let mut function = Function::copy(&data.def(d_nr).variables);
        for a in function.arguments() {
            scopes.var_scope.insert(a, 0);
        }
        let code = scopes.scan(&data.definitions[d_nr as usize].code, &mut function, data);
        data.definitions[d_nr as usize].code = code;
        data.definitions[d_nr as usize].variables = function;
        for (v_nr, scope) in scopes.var_scope {
            data.definitions[d_nr as usize]
                .variables
                .set_scope(v_nr, scope);
        }
    }
}

impl Scopes {
    fn enter_scope(&mut self) -> u16 {
        self.stack.push(self.scope);
        self.scope = self.max_scope;
        self.max_scope += 1;
        self.scope
    }

    fn exit_scope(&mut self) {
        if let Some(scope) = self.stack.pop() {
            self.scope = scope;
        }
    }

    fn scan(&mut self, val: &Value, function: &mut Function, data: &Data) -> Value {
        match val {
            Value::Var(ov) => Value::Var(*self.var_mapping.get(ov).unwrap_or(ov)),
            Value::Set(ov, value) => {
                assert_ne!(
                    *ov,
                    u16::MAX,
                    "Incorrect variable in {} fn {}",
                    function.file,
                    function.name
                );
                if let Some(s) = self.var_scope.get(ov)
                    && self.scope != *s
                    && !self.stack.contains(s)
                    && !self.var_mapping.contains_key(ov)
                {
                    self.var_mapping.insert(*ov, function.copy_variable(*ov));
                }
                let v = self.var_mapping.get(ov).unwrap_or(ov);
                if self.var_scope.contains_key(v) && **value == Value::Null {
                    return Value::Insert(Vec::new());
                }
                // remember scope of variable
                let mut depend = Vec::new();
                for d in function.tp(*v).depend() {
                    if !self.var_scope.contains_key(&d) {
                        depend.push(d);
                        self.var_scope.insert(d, self.scope);
                    }
                }
                if !self.var_scope.contains_key(v) {
                    self.var_scope.insert(*v, self.scope);
                }
                if depend.is_empty() {
                    Value::Set(*v, Box::new(self.scan(value, function, data)))
                } else {
                    let mut ls = Vec::new();
                    for d in depend {
                        if d == *v {
                            continue;
                        }
                        if matches!(function.tp(d), Type::Text(_)) {
                            ls.push(v_set(d, Value::Text(String::new())));
                        } else {
                            ls.push(v_set(d, Value::Null));
                        }
                        self.var_scope.insert(d, self.scope);
                    }
                    ls.push(Value::Set(*v, Box::new(self.scan(value, function, data))));
                    Value::Insert(ls)
                }
            }
            Value::Loop(lp) => {
                let scope = self.enter_scope();
                self.loops.push(scope);
                let ls = self.convert(lp, function, data);
                self.loops.pop();
                self.exit_scope();
                Value::Loop(Box::new(Block {
                    operators: ls,
                    result: Type::Void,
                    name: lp.name,
                    scope,
                }))
            }
            Value::If(test, t_val, f_val) => Value::If(
                Box::new(self.scan(test, function, data)),
                Box::new(self.scan(t_val, function, data)),
                Box::new(self.scan(f_val, function, data)),
            ),
            Value::Break(lv) => {
                let mut ls = self.get_free_vars(
                    function,
                    data,
                    self.loops[self.loops.len() - *lv as usize - 1],
                    &Type::Void,
                    u16::MAX,
                );
                if ls.is_empty() {
                    Value::Break(*lv)
                } else {
                    ls.push(Value::Break(*lv));
                    Value::Insert(ls)
                }
            }
            Value::Continue(lv) => {
                let mut ls = self.get_free_vars(
                    function,
                    data,
                    self.loops[self.loops.len() - *lv as usize - 1],
                    &Type::Void,
                    u16::MAX,
                );
                if ls.is_empty() {
                    Value::Continue(*lv)
                } else {
                    ls.push(Value::Continue(*lv));
                    Value::Insert(ls)
                }
            }
            Value::Return(v) => {
                let expr = self.scan(v, function, data);
                Value::Insert(self.free_vars(
                    true,
                    &expr,
                    function,
                    data,
                    &data.def(self.d_nr).returned,
                    1,
                ))
            }
            Value::Block(bl) => {
                let scope = self.enter_scope();
                let ls = self.convert(bl, function, data);
                self.exit_scope();
                Value::Block(Box::new(Block {
                    operators: ls,
                    result: bl.result.clone(),
                    name: bl.name,
                    scope,
                }))
            }
            Value::Call(d_nr, args) => {
                let mut ls = Vec::new();
                for v in args {
                    ls.push(self.scan(v, function, data));
                }
                Value::Call(*d_nr, ls)
            }
            _ => val.clone(),
        }
    }

    /// Convert the content of loops and blocks
    fn convert(&mut self, bl: &Block, function: &mut Function, data: &Data) -> Vec<Value> {
        let mut ls = Vec::new();
        for v in &bl.operators {
            let sv = self.scan(v, function, data);
            if let Value::Insert(to_insert) = sv {
                for i in to_insert {
                    ls.push(i.clone());
                }
            } else {
                ls.push(sv);
            }
        }
        let expr = if ls.is_empty() || bl.result == Type::Void {
            Value::Null
        } else {
            ls.pop().unwrap()
        };
        for v in self.variables(self.scope) {
            self.var_mapping.remove(&v);
        }
        for v in self.free_vars(false, &expr, function, data, &bl.result, self.scope) {
            ls.push(v);
        }
        ls
    }

    #[must_use]
    fn variables(&self, to_scope: u16) -> Vec<u16> {
        let mut scopes = HashSet::new();
        let mut sc = self.scope;
        let mut scope_pos = self.stack.len();
        loop {
            if sc == 0 {
                // never return function arguments
                break;
            }
            scopes.insert(sc);
            if sc == to_scope {
                break;
            }
            if scope_pos == 0 {
                break;
            }
            scope_pos -= 1;
            sc = self.stack[scope_pos];
        }
        let mut res = Vec::new();
        for (v_nr, sc) in &self.var_scope {
            if scopes.contains(sc) {
                res.push(*v_nr);
            }
        }
        res
    }

    fn free_vars(
        &mut self,
        is_return: bool,
        expr: &Value,
        function: &mut Function,
        data: &Data,
        tp: &Type,
        to_scope: u16,
    ) -> Vec<Value> {
        let ret_var = returned_var(expr);
        let mut ls = self.get_free_vars(function, data, to_scope, tp, ret_var);
        if ls.is_empty() || matches!(expr, Value::Null | Value::Var(_)) {
            if is_return {
                ls.push(Value::Return(Box::new(expr.clone())));
            } else if !matches!(expr, Value::Null) {
                ls.push(expr.clone());
            }
        } else if let Value::Block(bl) = expr {
            return insert_free(bl, &ls, is_return);
        } else {
            ls.insert(0, expr.clone());
            if is_return {
                ls.push(Value::Return(Box::new(Value::Null)));
            }
        }
        ls
    }

    fn get_free_vars(
        &mut self,
        function: &mut Function,
        data: &Data,
        to_scope: u16,
        tp: &Type,
        ret_var: u16,
    ) -> Vec<Value> {
        let mut ls = Vec::new();
        for v in self.variables(to_scope) {
            if v == ret_var {
                continue;
            }
            if matches!(function.tp(v), Type::Text(_)) {
                ls.push(call("OpFreeText", v, data));
            }
            if let Type::Reference(_, dep) | Type::Vector(_, dep) | Type::Enum(_, true, dep) =
                function.tp(v)
                && dep.is_empty()
                && !tp.depend().contains(&v)
            {
                ls.push(call("OpFreeRef", v, data));
            }
        }
        ls
    }
}

fn call(to: &'static str, v: u16, data: &Data) -> Value {
    Value::Call(data.def_nr(to), vec![Value::Var(v)])
}

fn insert_free(block: &Block, free: &[Value], is_return: bool) -> Vec<Value> {
    let mut res = Vec::new();
    let mut ls = Vec::new();
    for (o_nr, o) in block.operators.iter().enumerate() {
        if o_nr + 1 == block.operators.len() {
            if let Value::Block(bl) = &block.operators[o_nr] {
                for v in insert_free(bl, free, is_return) {
                    ls.push(v);
                }
            } else if block.result == Type::Void {
                ls.push(o.clone());
                ls.push(Value::Return(Box::new(Value::Null)));
            } else {
                for v in free {
                    ls.push(v.clone());
                }
                if is_return {
                    ls.push(Value::Return(Box::new(o.clone())));
                } else {
                    ls.push(o.clone());
                }
            }
        } else {
            ls.push(o.clone());
        }
    }
    res.push(Value::Block(Box::new(Block {
        name: block.name,
        operators: ls,
        result: block.result.clone(),
        scope: block.scope,
    })));
    res
}

fn returned_var(expr: &Value) -> u16 {
    match expr {
        Value::Var(v) => *v,
        Value::Block(bl) => {
            let mut v = u16::MAX;
            for o in &bl.operators {
                v = returned_var(o);
            }
            v
        }
        _ => u16::MAX,
    }
}
