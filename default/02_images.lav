// Copyright (c) 2024 Jurjen Stellingwerff
// SPDX-License-Identifier: LGPL-3.0-or-later

pub struct EnvVariable {
    name: text,
    value: text
}

// Data per pixel of the png graph
pub struct Pixel {
    r: integer limit(0, 255) not null,
    g: integer limit(0, 255) not null,
    b: integer limit(0, 255) not null
}

// Database structure with image data
// The actual data is in height rows of width length.
pub struct Image {
    name: text,
    width: integer,
    height: integer,
    data: vector<Pixel>
}

pub enum Format {
    TextFile,
    LittleEndian,
    BigEndian,
    Directory
}

// Hold the complete path to a file.
pub struct File {
    path: text, // 8
    size: long, // 0
    format: Format, // 16
    ref: i32 // 12
}

fn OpGetFile(file: File) -> boolean;
#rust "stores.get_file(&@file)"

fn OpGetDir(path: text, result: vector<File>) -> boolean;
#rust "stores.get_dir(@path, &@result)"

fn OpGetPngImage(path: text, image: Image) -> boolean;
#rust "stores.get_png(@path, &@image)"

fn OpGetFileText(file: File, content: &text);

fn OpWriteFile(file: File, val: reference, db_tp: const u16);

fn OpReadFile(file: File, val: reference, db_tp: const u16);

fn OpSeekFile(file: File, pos: long);

pub fn value(self: Pixel) -> integer {
    self.r * 0x10000 + self.g * 0x100 + self.b
}

pub fn toLittleEndian(self: File) {
    if self.format == Format.TextFile {
        self.format = Format.LittleEndian;
    } else {
        panic("Cannot set '{self.path}' to little endian binary.");
    }
}

pub fn toBigEndian(self: File) {
    if self.format == Format.TextFile {
        self.format = Format.BigEndian;
    } else {
        panic("Cannot set '{self.path}' to big endian binary.");
    }
}

pub fn write_bin(self: File, v: reference) {
    if self.format == Format.BigEndian || self.format == Format.LittleEndian {
        OpWriteFile(self, v, typedef(v));
    } else {
        panic("Set file '{self.path}' to binary format first.");
    }
}

pub fn read(self: File, v: reference) {
    if self.format == Format.BigEndian || self.format == Format.LittleEndian {
        OpReadFile(self, v, typedef(v));
    } else {
        panic("Set file '{self.path}' to binary format first.");
    }
}

pub fn seek(self: File, pos: long) {
    if self.format == Format.BigEndian || self.format == Format.LittleEndian {
        OpSeekFile(self, pos);
    } else {
        panic("Set file '{self.path}' to binary format first.");
    }
}

pub fn content(self: File) -> text {
    result = "";
    txt = "";
    OpGetFileText(self, txt);
    result += txt;
    result
}

pub fn lines(self: File) -> vector<text> {
    result = [];
    c = self.content();
    p = 0;
    for ch in c {
        if ch == '\n' {
            result += [ c[p..ch#index-1] ];
            p = ch#index;
        }
    }
    if p > 0 {
        result += [ c[p..c.len()] ];
    }
    result
}

pub fn split(self: text, separator: character) -> vector<text> {
    result = [];
    p = 0;
    for c in self {
        if c == separator {
            result += [ self[p..c#index-1] ];
            p = c#index;
        }
    }
    if p > 0 {
        result += [ self[p..self.len()] ];
    }
    result
}

pub fn file(path: text) -> File {
    result = File { path: path, ref: null };
    OpGetFile(result);
    result
}

pub fn files(self: File) -> vector<File> {
    result = [];
    if self.format == Format.Directory {
        OpGetDir(self.path, result);
    }
    result
}

pub fn write(self: File, v: text);
#rust "stores.write_file(&@self, @v);"

pub fn png(self: File) -> Image {
    if self.format == Format.TextFile {
        result = Image { };
        OpGetPngImage(self.path, result);
        result
    } else {
        null
    }
}

pub fn env_variables() -> vector<EnvVariable>;
#rust "stores.os_variables()"

pub fn env_variable(name: text) -> text;
#rust "Stores::os_variable(@name)"
