// Copyright (c) 2022 Jurjen Stellingwerff
// SPDX-License-Identifier: LGPL-3.0-or-later

pub type boolean;
pub type integer;
pub type long;
pub type single;
pub type float;
pub type text;

// Boolean operations
fn OpNot(v1: boolean) -> boolean;
#rust "!@v1"

fn OpAnd(v1: boolean, v2: boolean) -> boolean;
#rust "(@v1 $$ @v2)"

fn OpOr(v1: boolean, v2: boolean) -> boolean;
#rust "(@v1 || @v2)"

fn OpFormatBool(res: text, val: boolean, radix: integer, width: integer, dir: integer, token: integer);
#rust "format_text(&mut @res, if @val {{\"true\"}} else {{\"false\"}}, @width, @dir, @token)"

// Integer operations
fn OpConvIntFromNull() -> integer;
#rust "i32::MIN"

fn OpAbsInt(v1: integer) -> integer;
#rust "op_abs_int(@v1)"
pub fn abs(both: integer) -> integer { OpAbsInt(both) }

fn OpMinSingleInt(v1: integer) -> integer;
#rust "op_min_single_int(@v1)"

fn OpConvLongFromInt(v1: integer) -> long;
#rust "op_conv_long_from_int(@v1)"

fn OpConvFloatFromInt(v1: integer) -> float;
#rust "op_conv_float_from_int(@v1)"

fn OpConvSingleFromInt(v1: integer) -> single;
#rust "op_conv_single_from_int(@v1)"

fn OpConvBoolFromInt(v1: integer) -> boolean;
#rust "op_conv_bool_from_int(@v1)"

fn OpAddInt(v1: integer, v2: integer) -> integer;
#rust "op_add_int(@v1, @v2)"

fn OpMinInt(v1: integer, v2: integer) -> integer;
#rust "op_min_int(@v1, @v2)"

fn OpMulInt(v1: integer, v2: integer) -> integer;
#rust "op_mul_int(@v1, @v2)"

fn OpDivInt(v1: integer, v2: integer) -> integer;
#rust "op_div_int(@v1, @v2)"

fn OpRemInt(v1: integer, v2: integer) -> integer;
#rust "op_rem_int(@v1, @v2)"

fn OpEqInt(v1: integer, v2: integer) -> boolean;
#rust "op_eq_int(@v1, @v2)"

fn OpNeInt(v1: integer, v2: integer) -> boolean;
#rust "op_ne_int(@v1, @v2)"

fn OpLtInt(v1: integer, v2: integer) -> boolean;
#rust "op_lt_int(@v1, @v2)"

fn OpLeInt(v1: integer, v2: integer) -> boolean;
#rust "op_le_int(@v1, @v2)"

fn OpGtInt(v1: integer, v2: integer) -> boolean;
#rust "op_lt_int(@v2, @v1)"

fn OpGeInt(v1: integer, v2: integer) -> boolean;
#rust "op_le_int(@v2, @v1)"

fn OpFormatInt(val: integer, radix: integer, width: integer, token: integer, plus: boolean, note: boolean) -> text;
#rust "format_int(@val, @width, @token, @plus, @note)"

// Long operations
fn OpConvLongFromNull() -> long;
#rust "i64::MIN"

fn OpAbsLong(v1: long) -> long;
#rust "op_abs_long(@v1)"
pub fn abs(both: long) -> long { OpAbsLong(both) }

fn OpMinSingleLong(v1: long) -> long;
#rust "op_min_single_long(@v1)"

fn OpCastIntFromLong(v1: long) -> integer;
#rust "op_cast_int_from_long(@v1)"

fn OpConvFloatFromLong(v1: long) -> float;
#rust "op_conv_float_from_long(@v1)"

fn OpConvBoolFromLong(v1: long) -> boolean;
#rust "op_conv_bool_from_long(@v1)"

fn OpAddLong(v1: long, v2: long) -> long;
#rust "op_add_long(@v1, @v2)"

fn OpMinLong(v1: long, v2: long) -> long;
#rust "op_min_long(@v1, @v2)"

fn OpMulLong(v1: long, v2: long) -> long;
#rust "op_mul_long(@v1, @v2)"

fn OpDivLong(v1: long, v2: long) -> long;
#rust "op_div_long(@v1, @v2)"

fn OpRemLong(v1: long, v2: long) -> long;
#rust "op_rem_long(@v1, @v2)"

fn OpEqLong(v1: long, v2: long) -> boolean;
#rust "op_eq_long(@v1, @v2)"

fn OpNeLong(v1: long, v2: long) -> boolean;
#rust "op_ne_long(@v1, @v2)"

fn OpLtLong(v1: long, v2: long) -> boolean;
#rust "op_lt_long(@v1, @v2)"

fn OpLeLong(v1: long, v2: long) -> boolean;
#rust "op_le_long(@v1, @v2)"

fn OpGtLong(v1: long, v2: long) -> boolean;
#rust "op_lt_long(@v2, @v1)"

fn OpGeLong(v1: long, v2: long) -> boolean;
#rust "op_le_long(@v2, @v1)"

fn OpFormatLong(val: long, radix: integer, width: integer, token: integer, plus: boolean, note: boolean) -> text;
#rust "format_long(&mut @res, @val, @width, @token, @plus, @note)"

// Single operations
fn OpConvSingleFromNull() -> single;
#rust "f32::NAN"

fn OpAbsSingle(v1: single) -> single;
#rust "@v1.abs()"
pub fn abs(both: single) -> single { OpAbsSingle(both) }

fn OpMinSingleSingle(v1: single) -> single;
#rust "(-@v1)"

fn OpCastIntFromSingle(v1: single) -> integer;
#rust "op_cast_int_from_single(@v1)"

fn OpCastLongFromSingle(v1: single) -> long;
#rust "op_cast_long_from_single(@v1)"

fn OpConvFloatFromSingle(v1: single) -> float;
#rust "(@v1 as f64)"

fn OpConvBoolFromSingle(v1: single) -> boolean;
#rust "(!@v1.is_nan())"

fn OpAddSingle(v1: single, v2: single) -> single;
#rust "(@v1 + @v2)"

fn OpMinSingle(v1: single, v2: single) -> single;
#rust "(@v1 - @v2)"

fn OpMulSingle(v1: single, v2: single) -> single;
#rust "(@v1 * @v2)"

fn OpDivSingle(v1: single, v2: single) -> single;
#rust "(@v1 / @v2)"

fn OpRemSingle(v1: single, v2: single) -> single;
#rust "(@v1 % @v2)"

fn OpEqSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 == @v2)"

fn OpNeSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 != @v2)"

fn OpLtSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 < @v2)"

fn OpLeSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 <= @v2)"

fn OpGtSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 > @v2)"

fn OpGeSingle(v1: single, v2: single) -> boolean;
#rust "(@v1 >= @v2)"

fn OpFormatSingle(val: single, width: integer, precision: integer) -> text;
#rust "format_single(@val, @width, @precision)"

fn OpConvFloatFromNull() -> float;
#rust "f64::NAN"

fn OpAbsFloat(v1: float) -> float;
#rust "@v1.abs()"
pub fn abs(both: float) -> float { OpAbsFloat(both) }

fn OpMinSingleFloat(v1: float) -> float;
#rust "(-@v1)"

fn OpCastSingleFromFloat(v1: float) -> single;
#rust "(@v1 as f32)"

fn OpCastIntFromFloat(v1: float) -> integer;
#rust "op_cast_int_from_float(@v1)"

fn OpCastLongFromFloat(v1: float) -> long;
#rust "op_cast_long_from_float(@v1)"

fn OpConvBoolFromFloat(v1: float) -> boolean;
#rust "(!@v1.is_nan())"

fn OpAddFloat(v1: float, v2: float) -> float;
#rust "(@v1 + @v2)"

fn OpMinFloat(v1: float, v2: float) -> float;
#rust "(@v1 - @v2)"

fn OpMulFloat(v1: float, v2: float) -> float;
#rust "(@v1 * @v2)"

fn OpDivFloat(v1: float, v2: float) -> float;
#rust "(@v1 / @v2)"

fn OpRemFloat(v1: float, v2: float) -> float;
#rust "(@v1 % @v2)"

fn OpEqFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 == @v2)"

fn OpNeFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 != @v2)"

fn OpLtFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 < @v2)"

fn OpLeFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 <= @v2)"

fn OpGtFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 > @v2)"

fn OpGeFloat(v1: float, v2: float) -> boolean;
#rust "(@v1 >= @v2)"

fn OpFormatFloat(v1: text, val: float, width: integer, precision: integer);
#rust "format_float(@val, @width, @precision)"

fn OpConvTextFromNull() -> text;
#rust "\"\""

fn OpLengthText(v1: text) -> integer;
#rust "(@v1.len() as i32)"

pub fn len(both: text) -> integer { OpLengthText(both) }
fn OpConvBoolFromText(v1: text) -> boolean;
#rust "!@v1.is_empty()"
fn OpAddText(v1: text, v2: text) -> text;
#rust "(@v1 + &@v2)"
fn OpClearText(v1: text);
#rust "@v1.clear()"
pub fn clear(self: text) { OpClearText(self) }
fn OpEqText(v1: text, v2: text) -> boolean;
#rust "(@v1 == @v2)"
fn OpNeText(v1: text, v2: text) -> boolean;
#rust "(@v1 != @v2)"
fn OpLtText(v1: text, v2: text) -> boolean;
#rust "(@v1 < @v2)"
fn OpLeText(v1: text, v2: text) -> boolean;
#rust "(@v1 <= @v2)"
fn OpGtText(v1: text, v2: text) -> boolean;
#rust "(@v1 > @v2)"
fn OpGeText(v1: text, v2: text) -> boolean;
#rust "(@v1 >= @v2)"
fn OpFormatText(val: text, width: integer, dir: integer, token: integer) -> text;
#rust "format_text(@val, @width, @dir, @token)"

type enumerate;
fn OpConvBoolFromEnum(v1: enumerate) -> boolean;
fn OpConvEnumFromNull() -> enumerate;
fn OpEqEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpNeEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpLtEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpLeEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpGtEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpGeEnum(v1: enumerate, v2: enumerate) -> boolean;
fn OpFormatEnum(v1: text, val: enumerate, width: integer);

type reference;
fn OpDatabase(size: integer) -> reference;
fn OpAppend(db: reference, size: integer) -> reference;
fn OpGet(v1: reference, fld: integer) -> reference;
fn OpConvRefFromNull() -> reference;
fn OpConvBoolFromRef(v1: reference) -> boolean;
fn OpEqRef(v1: reference, v2: reference) -> boolean;
fn OpNeRef(v1: reference, v2: reference) -> boolean;
fn OpLtRef(v1: reference, v2: reference) -> boolean;
fn OpLeRef(v1: reference, v2: reference) -> boolean;
fn OpGtRef(v1: reference, v2: reference) -> boolean;
fn OpGeRef(v1: reference, v2: reference) -> boolean;
pub fn remove(self: reference);
fn OpFormatRef(v1: text, val: reference, width: integer);
fn OpGetInt(v1: reference, fld: integer) -> integer;
fn OpGetLong(v1: reference, fld: integer) -> long;
fn OpGetSingle(v1: reference, fld: integer) -> single;
fn OpGetFloat(v1: reference, fld: integer) -> float;
fn OpGetByte(v1: reference, fld: integer, min: integer) -> integer;
fn OpGetShort(v1: reference, fld: integer, min: integer) -> integer;
fn OpGetText(v1: reference, fld: integer) -> text;
fn OpSetInt(v1: reference, fld: integer, val: integer);
fn OpSetLong(v1: reference, fld: integer, val: long);
fn OpSetSingle(v1: reference, fld: integer, val: single);
fn OpSetFloat(v1: reference, fld: integer, val: float);
fn OpSetByte(v1: reference, fld: integer, min: integer, val: integer);
fn OpSetShort(v1: reference, fld: integer, min: integer, val: integer);
fn OpSetText(v1: reference, fld: integer, val: text);
fn OpGetReference(v1: reference, fld: integer) -> reference;
fn OpSetReference(v1: reference, fld: integer, val: reference);

pub type vector;
fn OpLengthVector(r: vector) -> integer;
#rust "@r.len()"
pub fn len(both: vector) -> integer { OpLengthVector(both) }

fn OpClearVector(r: vector);
#rust "@r.len()"
pub fn clear(self: vector) { OpClearVector(self) }

fn OpFinishSorted(r: vector);
fn OpGetVector<T>(r: vector<T>, size: integer, index: integer) -> T;
fn OpRemoveVector(r: vector, size: integer, index: integer) -> boolean;
fn OpInsertVector<T>(r: vector<T>, size: integer, index: integer) -> T;
fn OpAppendVector<T>(r: vector<T>, size: integer) -> T;

pub type hash;
fn OpLengthHash(r: hash) -> integer;
#rust "@r.len()"
pub fn len(both: hash) -> integer { OpLengthHash(both) }
fn OpClearHash(r: hash);
#rust "@r.clear()"
pub fn clear(self: hash) { OpClearHash(self); }
fn OpFormatHash(v1: text, val: hash, width: integer);

pub type index;
fn OpLengthIndex(r: index) -> integer;
#rust "@r.len()"
pub fn len(both: index) -> integer { OpLengthIndex(both) }
fn OpClearIndex(r: index);
#rust "@r.clear()"

pub fn clear(self: index) { OpClearIndex(self) }
fn OpFormatIndex(v1: text, val: index, width: integer);

pub type radix;
fn OpLengthRadix(r: radix) -> integer;
#rust "@r.len()"
pub fn len(both: radix) -> integer { OpLengthRadix(both) }

fn OpClearRadix(r: radix);
#rust "@r.clear()"
pub fn clear(self: radix) { OpClearRadix(self) }
fn OpFormatRadix(v1: text, val: radix, width: integer);

fn OpEqBool(v1: boolean, v2: boolean) -> boolean;
fn OpNeBool(v1: boolean, v2: boolean) -> boolean;

fn OpAssert(v1: boolean, v2: text);
#rust "if !@v1 {{ panic!(\"{{}}\", @v2); }};"
fn assert(v1: boolean, v2: text) { OpAssert(v1, v2); }

fn OpPrint(v1: text);
#rust "print!(\"{{}}\", @v1)"
fn print(v1: text) { OpPrint(v1); }